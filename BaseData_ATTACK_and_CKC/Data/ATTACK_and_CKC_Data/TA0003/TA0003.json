{
    "id": "TA0003",
    "name_eng": "Persistence",
    "name_jp": "永続性",
    "description_eng": "The adversary is trying to maintain their foothold.\n\nPersistence consists of techniques that adversaries use to keep access to systems across restarts, changed credentials, and other interruptions that could cut off their access. Techniques used for persistence include any access, action, or configuration changes that let them maintain their foothold on systems, such as replacing or hijacking legitimate code or adding startup code.",
    "description_jp": "敵は足場を固めようとしている。\n\n永続性とは、再起動、認証情報の変更、およびアクセスを遮断する可能性のあるその他の中断を越えて、敵対者がシステムへのアクセスを維持するために使用する技術で構成される。永続性のために使用されるテクニックには、正当なコードを置き換えたり、乗っ取ったり、スタートアップコードを追加するなど、システムの足場を維持するためのあらゆるアクセス、アクション、設定の変更が含まれます。",
    "ckc_map_info": [
        {
            "ckc_id": "ckc-005",
            "ckc_phase_number": 5,
            "ckc_phase_name_en": "Installation",
            "ckc_description_en": "Attacker installs malware or establishes persistent access on the compromised system. This allows the attacker to maintain control for future activities.",
            "ckc_phase_name_jp": "インストール",
            "ckc_description_jp": "攻撃者は、侵害されたシステムにマルウェアをインストールするか、永続的なアクセスを確立します。これにより、攻撃者は将来の活動のために制御を維持できます。"
        }
    ],
    "ckc_mapping_rational": "システム再起動後もアクセスを維持する活動。CKCのインストールフェーズでバックドアなどを設置し、永続的なアクセスを確保する点と一致する。",
    "techniques": [
        {
            "id": "T1037",
            "name_eng": "Boot or Logon Initialization Scripts",
            "name_jp": "ブートまたはログオン初期化スクリプト",
            "description_eng": "Adversaries may use scripts automatically executed at boot or logon initialization to establish persistence.(Citation: Mandiant APT29 Eye Spy Email Nov 22)(Citation: Anomali Rocke March 2019) Initialization scripts can be used to perform administrative functions, which may often execute other programs or send information to an internal logging server. These scripts can vary based on operating system and whether applied locally or remotely.  \n\nAdversaries may use these scripts to maintain persistence on a single system. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary. \n\nAn adversary may also be able to escalate their privileges since some boot or logon initialization scripts run with higher privileges.",
            "description_jp": "攻撃者は、ブートやログオンの初期化時に自動的に実行されるスクリプトを使用して、永続性を確立する可能性があります（引用：Mandiant APT29 Eye Spy Email 11月22日）（引用：Anomali Rocke 2019年3月）初期化スクリプトは、管理機能を実行するために使用することができ、多くの場合、他のプログラムを実行したり、内部のログサーバーに情報を送信したりすることがあります。これらのスクリプトは、オペレーティング システムや、ローカルまたはリモートで適用されるかどうかによって異なります。  \n\n攻撃者は、これらのスクリプトを使用して、1つのシステム上で永続性を維持することがある。ログオンスクリプトのアクセス構成によっては、ローカル認証情報または管理者アカウントのいずれかが必要となる場合がある。\n\nまた、ブートスクリプトやログオン初期化スクリプトの中には、より高い特権で実行されるものがあるため、敵対者は特権をエスカレートできる可能性があります。",
            "subtechniques": [
                {
                    "id": "T1037.004",
                    "name_eng": "RC Scripts",
                    "name_jp": "RCスクリプト",
                    "description_eng": "Adversaries may establish persistence by modifying RC scripts, which are executed during a Unix-like system’s startup. These files allow system administrators to map and start custom services at startup for different run levels. RC scripts require root privileges to modify.\n\nAdversaries may establish persistence by adding a malicious binary path or shell commands to <code>rc.local</code>, <code>rc.common</code>, and other RC scripts specific to the Unix-like distribution.(Citation: IranThreats Kittens Dec 2017)(Citation: Intezer HiddenWasp Map 2019) Upon reboot, the system executes the script's contents as root, resulting in persistence.\n\nAdversary abuse of RC scripts is especially effective for lightweight Unix-like distributions using the root user as default, such as ESXi hypervisors, IoT, or embedded systems.(Citation: intezer-kaiji-malware) As ESXi servers store most system files in memory and therefore discard changes on shutdown, leveraging `/etc/rc.local.d/local.sh` is one of the few mechanisms for enabling persistence across reboots.(Citation: Juniper Networks ESXi Backdoor 2022)\n\nSeveral Unix-like systems have moved to Systemd and deprecated the use of RC scripts. This is now a deprecated mechanism in macOS in favor of [Launchd](https://attack.mitre.org/techniques/T1053/004).(Citation: Apple Developer Doco Archive Launchd)(Citation: Startup Items) This technique can be used on Mac OS X Panther v10.3 and earlier versions which still execute the RC scripts.(Citation: Methods of Mac Malware Persistence) To maintain backwards compatibility some systems, such as Ubuntu, will execute the RC scripts if they exist with the correct file permissions.(Citation: Ubuntu Manpage systemd rc)",
                    "description_jp": "攻撃者は、Unixライクなシステムのスタートアップ時に実行されるRCスクリプトを修正することで、永続性を確立することができる。これらのファイルにより、システム管理者はスタートアップ時に異なるランレベル用のカスタムサービスをマッピングして起動することができる。RCスクリプトを変更するには、root権限が必要である。\n\n攻撃者は、悪意のあるバイナリパスやシェルコマンドを<code>rc.local</code>、<code>rc.common</code>、およびUnixライクなディストリビューションに固有のその他のRCスクリプトに追加することで、永続性を確立する可能性があります。(引用: IranThreats Kittens Dec 2017)(Citation: Intezer HiddenWasp Map 2019) 再起動時に、システムはスクリプトの内容をrootとして実行し、永続性をもたらします。\n\nRCスクリプトを悪用する攻撃者は、ESXiハイパーバイザー、IoT、組み込みシステムなど、デフォルトでrootユーザーを使用する軽量のUnix系ディストリビューションで特に効果的です。(引用：intezer-kaiji-malware) ESXiサーバーはほとんどのシステムファイルをメモリに保存するため、シャットダウン時に変更を破棄します。\n\nいくつかのUnixライクなシステムはSystemdに移行し、RCスクリプトの使用を非推奨とした。これは現在、macOSでは非推奨のメカニズムであり、[Launchd](https://attack.mitre.org/techniques/T1053/004)を採用しています。(引用: Apple Developer Doco Archive Launchd)(Citation: Startup Items) このテクニックは、RCスクリプトをまだ実行しているMac OS X Panther v10.3以前のバージョンでも使用できます。(引用: Methods of Mac Malware Persistence) 後方互換性を維持するために、Ubuntuなどの一部のシステムでは、RCスクリプトが正しいファイルパーミッションで存在する場合、RCスクリプトを実行します。(引用: Ubuntu Manpage systemd rc)"
                },
                {
                    "id": "T1037.001",
                    "name_eng": "Logon Script (Windows)",
                    "name_jp": "ログオン・スクリプト（Windows）",
                    "description_eng": "Adversaries may use Windows logon scripts automatically executed at logon initialization to establish persistence. Windows allows logon scripts to be run whenever a specific user or group of users log into a system.(Citation: TechNet Logon Scripts) This is done via adding a path to a script to the <code>HKCU\\Environment\\UserInitMprLogonScript</code> Registry key.(Citation: Hexacorn Logon Scripts)\n\nAdversaries may use these scripts to maintain persistence on a single system. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.",
                    "description_jp": "攻撃者は、ログオン初期化時に自動的に実行されるWindowsログオンスクリプトを使用して、永続性を確立する可能性がある。Windowsでは、特定のユーザーまたはユーザーグループがシステムにログインするたびにログオンスクリプトを実行することができます（引用：TechNet Logon Scripts）。これは、スクリプトへのパスを<code>HKCUUentEnvormentUserInitMprLogonScript</code>レジストリキーに追加することで実行されます（引用：Hexacorn Logon Scripts）。\n\n攻撃者はこれらのスクリプトを使用して、1つのシステム上で永続性を維持する可能性がある。ログオンスクリプトのアクセス構成によっては、ローカル認証情報または管理者アカウントが必要になる場合があります。"
                },
                {
                    "id": "T1037.003",
                    "name_eng": "Network Logon Script",
                    "name_jp": "ネットワークログオンスクリプト",
                    "description_eng": "Adversaries may use network logon scripts automatically executed at logon initialization to establish persistence. Network logon scripts can be assigned using Active Directory or Group Policy Objects.(Citation: Petri Logon Script AD) These logon scripts run with the privileges of the user they are assigned to. Depending on the systems within the network, initializing one of these scripts could apply to more than one or potentially all systems.  \n \nAdversaries may use these scripts to maintain persistence on a network. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.",
                    "description_jp": "攻撃者は、ログオン初期化時に自動的に実行されるネットワークログオンスクリプトを使用して、永続性を確立する可能性がある。ネットワークログオンスクリプトは、Active Directoryまたはグループポリシーオブジェクトを使用して割り当てることができます（引用：Petri Logon Script AD）。これらのログオンスクリプトは、割り当てられたユーザーの権限で実行されます。ネットワーク内のシステムによっては、これらのスクリプトの1つを初期化すると、複数のシステム、またはすべてのシステムに適用される可能性がある。  \n \n攻撃者は、これらのスクリプトを使用して、ネットワーク上の永続性を維持する可能性がある。ログオンスクリプトのアクセス構成によっては、ローカル認証情報または管理者アカウ ントが必要になる場合があります。"
                },
                {
                    "id": "T1037.005",
                    "name_eng": "Startup Items",
                    "name_jp": "スタートアップ・アイテム",
                    "description_eng": "Adversaries may use startup items automatically executed at boot initialization to establish persistence. Startup items execute during the final phase of the boot process and contain shell scripts or other executable files along with configuration information used by the system to determine the execution order for all startup items.(Citation: Startup Items)\n\nThis is technically a deprecated technology (superseded by [Launch Daemon](https://attack.mitre.org/techniques/T1543/004)), and thus the appropriate folder, <code>/Library/StartupItems</code> isn’t guaranteed to exist on the system by default, but does appear to exist by default on macOS Sierra. A startup item is a directory whose executable and configuration property list (plist), <code>StartupParameters.plist</code>, reside in the top-level directory. \n\nAn adversary can create the appropriate folders/files in the StartupItems directory to register their own persistence mechanism.(Citation: Methods of Mac Malware Persistence) Additionally, since StartupItems run during the bootup phase of macOS, they will run as the elevated root user.",
                    "description_jp": "攻撃者は、ブート初期化時に自動的に実行されるスタートアップ項目を使用して、永続性を確立する可能性がある。スタートアップアイテムは、ブートプロセスの最終段階で実行され、シェルスクリプトやその他の実行可能ファイルを、システムがすべてのスタートアップアイテムの実行順序を決定するために使用する設定情報とともに含んでいる(引用：スタートアップアイテム)。\n\nこれは技術的に非推奨の技術であり（[Launch Daemon](https://attack.mitre.org/techniques/T1543/004) に取って代わられた）、したがって適切なフォルダ <code>/Library/StartupItems</code> がデフォルトでシステムに存在することは保証されていませんが、macOS Sierra ではデフォルトで存在するようです。スタートアップアイテムは、実行ファイルと設定プロパティリスト（plist）である<code>StartupParameters.plist</code>が最上位ディレクトリに存在するディレクトリです。\n\n敵対者は、StartupItemsディレクトリ内に適切なフォルダ/ファイルを作成し、独自の永続化メカニズムを登録することができる（引用：Methods of Mac Malware Persistence）。さらに、StartupItemsはmacOSの起動フェーズで実行されるため、昇格したルートユーザーとして実行される。"
                },
                {
                    "id": "T1037.002",
                    "name_eng": "Login Hook",
                    "name_jp": "ログインフック",
                    "description_eng": "Adversaries may use a Login Hook to establish persistence executed upon user logon. A login hook is a plist file that points to a specific script to execute with root privileges upon user logon. The plist file is located in the <code>/Library/Preferences/com.apple.loginwindow.plist</code> file and can be modified using the <code>defaults</code> command-line utility. This behavior is the same for logout hooks where a script can be executed upon user logout. All hooks require administrator permissions to modify or create hooks.(Citation: Login Scripts Apple Dev)(Citation: LoginWindowScripts Apple Dev) \n\nAdversaries can add or insert a path to a malicious script in the <code>com.apple.loginwindow.plist</code> file, using the <code>LoginHook</code> or <code>LogoutHook</code> key-value pair. The malicious script is executed upon the next user login. If a login hook already exists, adversaries can add additional commands to an existing login hook. There can be only one login and logout hook on a system at a time.(Citation: S1 macOs Persistence)(Citation: Wardle Persistence Chapter)\n\n**Note:** Login hooks were deprecated in 10.11 version of macOS in favor of [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) and [Launch Agent](https://attack.mitre.org/techniques/T1543/001)",
                    "description_jp": "攻撃者は、ユーザーログオン時に実行される永続性を確立するために、ログインフックを使用する可能性がある。ログインフックは、ユーザーログオン時にroot権限で実行される特定のスクリプトを指すplistファイルです。plistファイルは<code>/Library/Preferences/com.apple.loginwindow.plist<//code>ファイルにあり、<code>defaults<//code>コマンドラインユーティリティを使って変更できます。この動作は、ユーザーのログアウト時にスクリプトを実行できるログアウトフックでも同じです。すべてのフックには、フックを変更または作成するための管理者権限が必要です。(引用: Login Scripts Apple Dev)(Citation: LoginWindowScripts Apple Dev)\n\n攻撃者は、<code>LoginHook</code>または<code>LogoutHook</code>のキーと値のペアを使用して、悪意のあるスクリプトへのパスを<code>com.apple.loginwindow.plist</code>ファイルに追加または挿入できます。悪意のあるスクリプトは、次のユーザーログイン時に実行されます。ログインフックがすでに存在する場合、敵対者は既存のログインフックにコマンドを追加することができます。ログインフックとログアウトフックは、システム上に一度に1つしか存在できない(引用：S1 macOs Persistence)(引用：Wardle Persistence Chapter)\n\n**注: **ログインフックは、macOSの10.11バージョンで非推奨となり、[Launch Daemon](https://attack.mitre.org/techniques/T1543/004) と [Launch Agent](https://attack.mitre.org/techniques/T1543/001) が採用されました。"
                }
            ]
        },
        {
            "id": "T1543",
            "name_eng": "Create or Modify System Process",
            "name_jp": "システムプロセスの作成または変更",
            "description_eng": "Adversaries may create or modify system-level processes to repeatedly execute malicious payloads as part of persistence. When operating systems boot up, they can start processes that perform background system functions. On Windows and Linux, these system processes are referred to as services.(Citation: TechNet Services) On macOS, launchd processes known as [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) and [Launch Agent](https://attack.mitre.org/techniques/T1543/001) are run to finish system initialization and load user specific parameters.(Citation: AppleDocs Launch Agent Daemons) \n\nAdversaries may install new services, daemons, or agents that can be configured to execute at startup or a repeatable interval in order to establish persistence. Similarly, adversaries may modify existing services, daemons, or agents to achieve the same effect.  \n\nServices, daemons, or agents may be created with administrator privileges but executed under root/SYSTEM privileges. Adversaries may leverage this functionality to create or modify system processes in order to escalate privileges.(Citation: OSX Malware Detection)",
            "description_jp": "攻撃者は、システムレベルのプロセスを作成または変更し、永続化の一環として悪意のあるペイロードを繰り返し実行する可能性があります。オペレーティングシステムが起動すると、バックグラウンドのシステム機能を実行するプロセスを開始することができる。引用：TechNet Services） macOSでは、[Launch Daemon](https://attack.mitre.org/techniques/T1543/004)および[Launch Agent](https://attack.mitre.org/techniques/T1543/001)として知られるlaunchdプロセスが実行され、システムの初期化を完了し、ユーザー固有のパラメータをロードします。\n\n攻撃者は、永続性を確立するために、起動時または繰り返し実行されるように設定できる新しいサービス、デーモン、またはエージェントをインストールすることができる。同様に、敵対者は既存のサービス、デーモン、またはエージェントを変更して、同じ効果を得ることもできる。  \n\nサービス、デーモン、またはエージェントは、管理者権限で作成されるが、root/SYSTEM 権限で実行されるかもしれない。敵はこの機能を利用して、特権をエスカレートさせるためにシステムプロセスを作成または変更する可能性があります。 引用：OSXマルウェア検出",
            "subtechniques": [
                {
                    "id": "T1543.004",
                    "name_eng": "Launch Daemon",
                    "name_jp": "デーモン起動",
                    "description_eng": "Adversaries may create or modify Launch Daemons to execute malicious payloads as part of persistence. Launch Daemons are plist files used to interact with Launchd, the service management framework used by macOS. Launch Daemons require elevated privileges to install, are executed for every user on a system prior to login, and run in the background without the need for user interaction. During the macOS initialization startup, the launchd process loads the parameters for launch-on-demand system-level daemons from plist files found in <code>/System/Library/LaunchDaemons/</code> and <code>/Library/LaunchDaemons/</code>. Required Launch Daemons parameters include a <code>Label</code> to identify the task, <code>Program</code> to provide a path to the executable, and <code>RunAtLoad</code> to specify when the task is run. Launch Daemons are often used to provide access to shared resources, updates to software, or conduct automation tasks.(Citation: AppleDocs Launch Agent Daemons)(Citation: Methods of Mac Malware Persistence)(Citation: launchd Keywords for plists)\n\nAdversaries may install a Launch Daemon configured to execute at startup by using the <code>RunAtLoad</code> parameter set to <code>true</code> and the <code>Program</code> parameter set to the malicious executable path. The daemon name may be disguised by using a name from a related operating system or benign software (i.e. [Masquerading](https://attack.mitre.org/techniques/T1036)). When the Launch Daemon is executed, the program inherits administrative permissions.(Citation: WireLurker)(Citation: OSX Malware Detection)\n\nAdditionally, system configuration changes (such as the installation of third party package managing software) may cause folders such as <code>usr/local/bin</code> to become globally writeable. So, it is possible for poor configurations to allow an adversary to modify executables referenced by current Launch Daemon's plist files.(Citation: LaunchDaemon Hijacking)(Citation: sentinelone macos persist Jun 2019)",
                    "description_jp": "攻撃者は、永続化の一環として悪意のあるペイロードを実行するためにLaunch Daemonを作成または変更する可能性があります。Launch Daemonは、macOSで使用されるサービス管理フレームワークであるLaunchdとやり取りするために使用されるplistファイルです。Launch Daemonのインストールには昇格権限が必要で、ログイン前にシステム上のすべてのユーザーに対して実行され、ユーザーの操作を必要とせずにバックグラウンドで実行されます。macOS の初期化起動中に、launchd プロセスは、<code>/System/Library/LaunchDaemons/</code> および <code>/Library/LaunchDaemons/</code> にある plist ファイルから、起動オンデマンドのシステムレベルデーモンのパラメータをロードします。Launch Daemons の必須パラメータには、タスクを識別するための <code>Label</code> 、実行ファイルへのパスを提供する <code>Program</code> 、タスクが実行されるタイミングを指定する <code>RunAtLoad</code> が含まれます。Launchデーモンは、共有リソースへのアクセス、ソフトウェアのアップデート、自動化タスクの実行によく使用されます。 (引用: AppleDocs Launch Agent Daemons)(Citation: Methods of Mac Malware Persistence)(Citation: launchd Plistsのキーワード)\n\n攻撃者は、<code>RunAtLoad</code> パラメータを <code>true</code> に設定し、<code>Program</code> パラメータを悪意のある実行可能パスに設定することで、起動時に実行するように設定された Launch Daemon をインストールすることができます。デーモン名は、関連するオペレーティングシステムまたは良性のソフトウェアからの名前を使用して偽装することができます（すなわち、[Masquerading](https://attack.mitre.org/techniques/T1036)）。Launch Daemonが実行されると、プログラムは管理者権限を継承します。(引用：WireLurker)(引用：OSX Malware Detection)\n\nさらに、システム設定の変更（サードパーティ製のパッケージ管理ソフトウェアのインストールなど）によって、<code>usr/local/bin</code>などのフォルダがグローバルに書き込み可能になることがあります。そのため、設定の不備によって、現在のLaunch Daemonのplistファイルによって参照される実行可能ファイルを敵対者が変更できる可能性があります。 引用：LaunchDaemonハイジャック）（引用：sentinelone macos persist 2019年6月号"
                },
                {
                    "id": "T1543.005",
                    "name_eng": "Container Service",
                    "name_jp": "コンテナサービス",
                    "description_eng": "Adversaries may create or modify container or container cluster management tools that run as daemons, agents, or services on individual hosts. These include software for creating and managing individual containers, such as Docker and Podman, as well as container cluster node-level agents such as kubelet. By modifying these services, an adversary may be able to achieve persistence or escalate their privileges on a host.\n\nFor example, by using the `docker run` or `podman run` command with the `restart=always` directive, a container can be configured to persistently restart on the host.(Citation: AquaSec TeamTNT 2023) A user with access to the (rootful) docker command may also be able to escalate their privileges on the host.(Citation: GTFOBins Docker)\n\nIn Kubernetes environments, DaemonSets allow an adversary to persistently [Deploy Container](https://attack.mitre.org/techniques/T1610)s on all nodes, including ones added later to the cluster.(Citation: Aquasec Kubernetes Attack 2023)(Citation: Kubernetes DaemonSet) Pods can also be deployed to specific nodes using the `nodeSelector` or `nodeName` fields in the pod spec.(Citation: Kubernetes Assigning Pods to Nodes)(Citation: AppSecco Kubernetes Namespace Breakout 2020)\n\nNote that containers can also be configured to run as [Systemd Service](https://attack.mitre.org/techniques/T1543/002)s.(Citation: Podman Systemd)(Citation: Docker Systemd)",
                    "description_jp": "攻撃者は、個々のホスト上でデーモン、エージェント、またはサービスとして実行されるコンテナまたはコンテナ・クラスタ管理ツールを作成または変更する可能性があります。これには、DockerやPodmanなどの個々のコンテナを作成および管理するソフトウェアや、kubeletなどのコンテナ・クラスタ・ノード・レベルのエージェントが含まれます。これらのサービスを変更することで、敵はホスト上で永続性を実現したり、特権をエスカレートしたりできる可能性があります。\n\n例えば、`docker run`コマンドや`podman run`コマンドに`restart=always`ディレクティブを指定することで、コンテナをホスト上で持続的に再起動するように設定することができる。(引用：AquaSec TeamTNT 2023) また、(rootfulな)dockerコマンドにアクセスできるユーザーであれば、ホスト上で特権をエスカレートできる可能性がある。\n\nKubernetes環境では、DaemonSetによって、敵対者は、クラスタに後から追加されたものも含め、すべてのノード上で永続的に[Deploy Container](https://attack.mitre.org/techniques/T1610)することができます。(引用: Aquasec Kubernetes Attack 2023)(引用: Kubernetes DaemonSet) Podは、Pod specの`nodeSelector`または`nodeName`フィールドを使用して特定のノードにデプロイすることもできます(引用: Kubernetes Assigning Pods to Nodes)(引用: AppSecco Kubernetes Namespace Breakout 2020)\n\nコンテナは[Systemd Service](https://attack.mitre.org/techniques/T1543/002)として実行するように設定することもできることに注意してください。(引用: Podman Systemd)(引用: Docker Systemd)"
                },
                {
                    "id": "T1543.001",
                    "name_eng": "Launch Agent",
                    "name_jp": "ローンチエージェント",
                    "description_eng": "Adversaries may create or modify launch agents to repeatedly execute malicious payloads as part of persistence. When a user logs in, a per-user launchd process is started which loads the parameters for each launch-on-demand user agent from the property list (.plist) file found in <code>/System/Library/LaunchAgents</code>, <code>/Library/LaunchAgents</code>, and <code>~/Library/LaunchAgents</code>.(Citation: AppleDocs Launch Agent Daemons)(Citation: OSX Keydnap malware) (Citation: Antiquated Mac Malware) Property list files use the <code>Label</code>, <code>ProgramArguments </code>, and <code>RunAtLoad</code> keys to identify the Launch Agent's name, executable location, and execution time.(Citation: OSX.Dok Malware) Launch Agents are often installed to perform updates to programs, launch user specified programs at login, or to conduct other developer tasks.\n\n Launch Agents can also be executed using the [Launchctl](https://attack.mitre.org/techniques/T1569/001) command.\n \nAdversaries may install a new Launch Agent that executes at login by placing a .plist file into the appropriate folders with the <code>RunAtLoad</code> or <code>KeepAlive</code> keys set to <code>true</code>.(Citation: Sofacy Komplex Trojan)(Citation: Methods of Mac Malware Persistence) The Launch Agent name may be disguised by using a name from the related operating system or benign software. Launch Agents are created with user level privileges and execute with user level permissions.(Citation: OSX Malware Detection)(Citation: OceanLotus for OS X)",
                    "description_jp": "攻撃者は、永続性の一部として悪意のあるペイロードを繰り返し実行するために、ローンチエージェントを作成または変更する可能性があります。ユーザーがログインすると、ユーザーごとの launchd プロセスが開始され、<code>/System/Library/LaunchAgents</code>、<code>/Library/LaunchAgents</code>、<code>~/Library/LaunchAgents</code> にあるプロパティリスト (.plist) ファイルから、各 launch-on-demand ユーザーエージェントのパラメータがロードされます。(引用：AppleDocs Launch Agent Daemons)(引用：OSX Keydnap malware)(引用：Antiquated Mac Malware) プロパティリストファイルは、<code>Label</code>、<code>ProgramArguments</code>、<code>RunAtLoad</code>キーを使用して、Launch Agentの名前、実行可能な場所、および実行時間を特定します。(引用：OSX.Dok Malware) Launch Agentは、プログラムのアップデートを実行したり、ログイン時にユーザーが指定したプログラムを起動したり、その他の開発者タスクを実行したりするためにインストールされることがよくあります。\n\n 起動エージェントは、[Launchctl](https://attack.mitre.org/techniques/T1569/001)コマンドを使用して実行することもできます。\n \n攻撃者は、<code>RunAtLoad</code>キーまたは<code>KeepAlive</code>キーを<code>true</code>に設定した.plistファイルを適切なフォルダに配置することで、ログイン時に実行される新しいLaunch Agentをインストールすることができます（引用：Sofacy Komplex Trojan）（引用：Methods of Mac Malware Persistence）Launch Agentの名前は、関連するオペレーティングシステムまたは良性のソフトウェアの名前を使用して偽装することができます。起動エージェントは、ユーザーレベルの権限で作成され、ユーザーレベルの権限で実行されます。 引用：OSXマルウェア検出）（引用：OceanLotus for OS X"
                },
                {
                    "id": "T1543.002",
                    "name_eng": "Systemd Service",
                    "name_jp": "Systemdサービス",
                    "description_eng": "Adversaries may create or modify systemd services to repeatedly execute malicious payloads as part of persistence. Systemd is a system and service manager commonly used for managing background daemon processes (also known as services) and other system resources.(Citation: Linux man-pages: systemd January 2014) Systemd is the default initialization (init) system on many Linux distributions replacing legacy init systems, including SysVinit and Upstart, while remaining backwards compatible.  \n\nSystemd utilizes unit configuration files with the `.service` file extension to encode information about a service's process. By default, system level unit files are stored in the `/systemd/system` directory of the root owned directories (`/`). User level unit files are stored in the `/systemd/user` directories of the user owned directories (`$HOME`).(Citation: lambert systemd 2022) \n\nInside the `.service` unit files, the following directives are used to execute commands:(Citation: freedesktop systemd.service)  \n\n* `ExecStart`, `ExecStartPre`, and `ExecStartPost` directives execute when a service is started manually by `systemctl` or on system start if the service is set to automatically start.\n* `ExecReload` directive executes when a service restarts. \n* `ExecStop`, `ExecStopPre`, and `ExecStopPost` directives execute when a service is stopped.  \n\nAdversaries have created new service files, altered the commands a `.service` file’s directive executes, and modified the user directive a `.service` file executes as, which could result in privilege escalation. Adversaries may also place symbolic links in these directories, enabling systemd to find these payloads regardless of where they reside on the filesystem.(Citation: Anomali Rocke March 2019)(Citation: airwalk backdoor unix systems)(Citation: Rapid7 Service Persistence 22JUNE2016) \n\nThe `.service` file’s User directive can be used to run service as a specific user, which could result in privilege escalation based on specific user/group permissions. \n\nSystemd services can be created via systemd generators, which support the dynamic generation of unit files. Systemd generators are small executables that run during boot or configuration reloads to dynamically create or modify systemd unit files by converting non-native configurations into services, symlinks, or drop-ins (i.e., [Boot or Logon Initialization Scripts](https://attack.mitre.org/techniques/T1037)).(Citation: Elastic Security Labs Linux Persistence 2024)(Citation: Pepe Berba Systemd 2022)",
                    "description_jp": "攻撃者は、永続化の一環として悪意のあるペイロードを繰り返し実行するために、systemdサービスを作成または変更する可能性があります。Systemdは、バックグラウンドのデーモンプロセス（サービスとも呼ばれる）やその他のシステムリソースを管理するために一般的に使用されるシステムおよびサービスマネージャです。(引用: Linux man-pages: systemd January 2014) Systemdは、多くのLinuxディストリビューションで、SysVinitやUpstartなどのレガシーなinitシステムに取って代わるデフォルトの初期化（init）システムです。  \n\nSystemd はサービスのプロセスに関する情報をエンコードするために `.service` ファイル拡張子を持つユニット設定ファイルを利用します。デフォルトでは、システムレベルのユニットファイルはルート所有ディレクトリ (`//`) の `/systemd/system` ディレクトリに格納されます。ユーザーレベルのユニットファイルは、ユーザー所有のディレクトリ (`$HOME`) の `/systemd/user` ディレクトリに格納される。(引用: lambert systemd 2022)\n\nユニットファイル `.service` 内では、以下のディレクティブがコマンド実行に使用される:(引用: freedesktop systemd.service)\n\n* ExecStart`、`ExecStartPre`、`ExecStartPost` ディレクティブは、サービスが `systemctl` によって手動で起動されたとき、またはサービスが自動的に起動するように設定されている場合はシステム起動時に実行されます。\n* ExecReload` ディレクティブはサービスが再起動したときに実行される。\n* ExecStop`, `ExecStopPre`, `ExecStopPost` ディレクティブはサービスが停止したときに実行される。  \n\n逆境者は新しいサービスファイルを作成したり、`.service` ファイルのディレクティブが実行するコマンドを変更したり、`.service` ファイルが実行するユーザディレクティブを変更したりして、特権を昇格させる可能性があります。攻撃者はまた、これらのディレクトリにシンボリックリンクを設置し、ファイルシステムのどこに存在するかに関係なく、systemd がこれらのペイロードを見つけられるようにする可能性があります。(引用: Anomali Rocke March 2019)(引用: airwalk backdoor unix systems)(引用: Rapid7 Service Persistence 22JUNE2016)\n\n.service`ファイルのUserディレクティブは、特定のユーザーとしてサービスを実行するために使用することができ、特定のユーザー/グループのパーミッションに基づいて特権の昇格を引き起こす可能性があります。\n\nSystemd サービスは、ユニットファイルの動的生成をサポートする systemd ジェネレータを使って作成できます。Systemd ジェネレータは、ブートや設定のリロード中に実行される小さな実行ファイルで、ネイティブでない設定をサービスやシンボリックリンク、ドロップイン（[Boot or Logon Initialization Scripts](https://attack.mitre.org/techniques/T1037)など）に変換することで、systemd ユニットファイルを動的に作成または変更します。(引用: Elastic Security Labs Linux Persistence 2024)(Citation: Pepe Berba Systemd 2022)"
                },
                {
                    "id": "T1543.003",
                    "name_eng": "Windows Service",
                    "name_jp": "Windowsサービス",
                    "description_eng": "Adversaries may create or modify Windows services to repeatedly execute malicious payloads as part of persistence. When Windows boots up, it starts programs or applications called services that perform background system functions.(Citation: TechNet Services) Windows service configuration information, including the file path to the service's executable or recovery programs/commands, is stored in the Windows Registry.\n\nAdversaries may install a new service or modify an existing service to execute at startup in order to persist on a system. Service configurations can be set or modified using system utilities (such as sc.exe), by directly modifying the Registry, or by interacting directly with the Windows API. \n\nAdversaries may also use services to install and execute malicious drivers. For example, after dropping a driver file (ex: `.sys`) to disk, the payload can be loaded and registered via [Native API](https://attack.mitre.org/techniques/T1106) functions such as `CreateServiceW()` (or manually via functions such as `ZwLoadDriver()` and `ZwSetValueKey()`), by creating the required service Registry values (i.e. [Modify Registry](https://attack.mitre.org/techniques/T1112)), or by using command-line utilities such as `PnPUtil.exe`.(Citation: Symantec W.32 Stuxnet Dossier)(Citation: Crowdstrike DriveSlayer February 2022)(Citation: Unit42 AcidBox June 2020) Adversaries may leverage these drivers as [Rootkit](https://attack.mitre.org/techniques/T1014)s to hide the presence of malicious activity on a system. Adversaries may also load a signed yet vulnerable driver onto a compromised machine (known as \"Bring Your Own Vulnerable Driver\" (BYOVD)) as part of [Exploitation for Privilege Escalation](https://attack.mitre.org/techniques/T1068).(Citation: ESET InvisiMole June 2020)(Citation: Unit42 AcidBox June 2020)\n\nServices may be created with administrator privileges but are executed under SYSTEM privileges, so an adversary may also use a service to escalate privileges. Adversaries may also directly start services through [Service Execution](https://attack.mitre.org/techniques/T1569/002).\n\nTo make detection analysis more challenging, malicious services may also incorporate [Masquerade Task or Service](https://attack.mitre.org/techniques/T1036/004) (ex: using a service and/or payload name related to a legitimate OS or benign software component). Adversaries may also create ‘hidden’ services (i.e., [Hide Artifacts](https://attack.mitre.org/techniques/T1564)), for example by using the `sc sdset` command to set service permissions via the Service Descriptor Definition Language (SDDL). This may hide a Windows service from the view of standard service enumeration methods such as `Get-Service`, `sc query`, and `services.exe`.(Citation: SANS 1)(Citation: SANS 2)",
                    "description_jp": "攻撃者は、永続化の一環として悪意のあるペイロードを繰り返し実行するために、Windowsサービスを作成または変更する可能性がある。Windowsが起動すると、バックグラウンドのシステム機能を実行するサービスと呼ばれるプログラムやアプリケーションが起動する（引用：TechNet Services）。サービスの実行ファイルや回復プログラム/コマンドへのファイルパスを含むWindowsサービス構成情報は、Windowsレジストリに保存される。\n\n攻撃者は、システム上で持続するために、新しいサービスをインストールしたり、既存のサービスを変更して起動時に実行したりする可能性がある。サービスコンフィギュレーションは、システムユーティリティ（sc.exeなど）を使用するか、レジストリを直接変更するか、Windows APIと直接やりとりすることで設定または変更できる。\n\n攻撃者はまた、サービスを使って悪意のあるドライバーをインストールし、実行することもある。例えば、ドライバファイル(ex: `.sys`)をディスクにドロップした後、`CreateServiceW()`のような[Native API](https://attack.mitre.org/techniques/T1106)関数(または `ZwLoadDriver()`や`ZwSetValueKey()`のような関数を介して手動で)、必要なサービスレジストリ値を作成することによって、ペイロードをロードして登録することができる。レジストリの変更](https://attack.mitre.org/techniques/T1112) などの関数を使用するか、`PnPUtil.exe` などのコマンドラインユーティリティを使用します。Stuxnet Dossier)(Citation: Crowdstrike DriveSlayer February 2022)(Citation: Unit42 AcidBox June 2020) 敵対者は、これらのドライバを[Rootkit](https://attack.mitre.org/techniques/T1014)として活用し、システム上の悪意のある活動の存在を隠す可能性があります。攻撃者はまた、[Exploitation for Privilege Escalation](https://attack.mitre.org/techniques/T1068)の一環として、署名済みでありながら脆弱なドライバを侵害されたマシンにロードする可能性があります(「Bring Your Own Vulnerable Driver」(BYOVD)として知られています)(引用: ESET InvisiMole 2020年6月)(引用: Unit42 AcidBox 2020年6月)\n\nサービスは管理者権限で作成されますが、SYSTEM権限で実行されるため、敵は特権をエスカレートさせるためにサービスを使用する可能性もあります。また、敵は[Service Execution](https://attack.mitre.org/techniques/T1569/002)を通じてサービスを直接起動することもできます。\n\n検出分析をより困難にするために、悪意のあるサービスは[マスカレードタスクまたはサービス](https://attack.mitre.org/techniques/T1036/004)(例: 正規のOSまたは良性のソフトウェアコンポーネントに関連するサービス名および/またはペイロード名を使用)を組み込むこともあります。例えば、`sc sdset` コマンドを使用して、Service Descriptor Definition Language (SDDL) 経由でサービスのパーミッションを設定します。これは、`Get-Service`、`sc query`、`services.exe`などの標準的なサービス列挙メソッドの視界からWindowsサービスを隠す可能性がある（引用：SANS 1）（引用：SANS 2）。"
                }
            ]
        },
        {
            "id": "T1133",
            "name_eng": "External Remote Services",
            "name_jp": "外部リモートサービス",
            "description_eng": "Adversaries may leverage external-facing remote services to initially access and/or persist within a network. Remote services such as VPNs, Citrix, and other access mechanisms allow users to connect to internal enterprise network resources from external locations. There are often remote service gateways that manage connections and credential authentication for these services. Services such as [Windows Remote Management](https://attack.mitre.org/techniques/T1021/006) and [VNC](https://attack.mitre.org/techniques/T1021/005) can also be used externally.(Citation: MacOS VNC software for Remote Desktop)\n\nAccess to [Valid Accounts](https://attack.mitre.org/techniques/T1078) to use the service is often a requirement, which could be obtained through credential pharming or by obtaining the credentials from users after compromising the enterprise network.(Citation: Volexity Virtual Private Keylogging) Access to remote services may be used as a redundant or persistent access mechanism during an operation.\n\nAccess may also be gained through an exposed service that doesn’t require authentication. In containerized environments, this may include an exposed Docker API, Kubernetes API server, kubelet, or web application such as the Kubernetes dashboard.(Citation: Trend Micro Exposed Docker Server)(Citation: Unit 42 Hildegard Malware)",
            "description_jp": "攻撃者は、外部向けのリモートサービスを利用して、最初にネットワークにアクセスしたり、ネットワーク内に留まったりすることがあります。VPN、Citrix、およびその他のアクセス・メカニズムなどのリモート・サービスは、ユーザが外部ロケーションから内部エンタープライズ・ネットワーク・リソースに接続することを可能にする。多くの場合、これらのサービスの接続とクレデンシャル認証を管理するリモートサービスゲートウェイがある。Windowsリモート管理](https://attack.mitre.org/techniques/T1021/006)や[VNC](https://attack.mitre.org/techniques/T1021/005)などのサービスも外部から利用できる。(引用：リモートデスクトップ用MacOS VNCソフトウェア)\n\nサービスを使用するための[有効なアカウント](https://attack.mitre.org/techniques/T1078)へのアクセスは、多くの場合必要条件である。これは、クレデンシャル・ファーミングによって取得されるか、企業ネットワークを侵害した後にユーザーからクレデンシャルを取得することによって取得される可能性がある。(引用：Volexity Virtual Private Keylogging) リモートサービスへのアクセスは、運用中の冗長的または永続的なアクセスメカニズムとして使用されることがある。\n\nまた、認証を必要としない公開サービスを通じてアクセスすることもある。コンテナ化された環境では、公開されたDocker API、Kubernetes APIサーバ、kubelet、またはKubernetesダッシュボードのようなWebアプリケーションなどがこれに該当します(引用: Trend Micro Exposed Docker Server)(引用: Unit 42 Hildegard Malware)",
            "subtechniques": []
        },
        {
            "id": "T1547",
            "name_eng": "Boot or Logon Autostart Execution",
            "name_jp": "ブートまたはログオンの自動開始実行",
            "description_eng": "Adversaries may configure system settings to automatically execute a program during system boot or logon to maintain persistence or gain higher-level privileges on compromised systems. Operating systems may have mechanisms for automatically running a program on system boot or account logon.(Citation: Microsoft Run Key)(Citation: MSDN Authentication Packages)(Citation: Microsoft TimeProvider)(Citation: Cylance Reg Persistence Sept 2013)(Citation: Linux Kernel Programming) These mechanisms may include automatically executing programs that are placed in specially designated directories or are referenced by repositories that store configuration information, such as the Windows Registry. An adversary may achieve the same goal by modifying or extending features of the kernel.\n\nSince some boot or logon autostart programs run with higher privileges, an adversary may leverage these to elevate privileges.",
            "description_jp": "攻撃者は、侵害されたシステム上で永続性を維持したり、より高いレベルの特権を獲得したりするために、システムの起動時やログオン時にプログラムを自動的に実行するようにシステム設定を構成することがあります。オペレーティングシステムは、システムブート時またはアカウントログオン時にプログラムを自動的に実行するメカニズムを備えている場合があります（引用：Microsoft Run Key）（引用：MSDN Authentication Packages）（引用：Microsoft TimeProvider）（引用：Cylance Reg Persistence Sept 2013）（引用：Linux Kernel Programming）これらのメカニズムには、特別に指定されたディレクトリに配置されたプログラムを自動的に実行したり、Windowsレジストリなどの構成情報を格納するリポジトリから参照されたりする場合があります。敵対者は、カーネルの機能を変更または拡張することで、同じ目標を達成することができる。\n\nブートやログオンの自動起動プログラムの中には、より高い特権で実行されるものがあるため、敵対者はこれらを利用して特権を昇格させる可能性がある。",
            "subtechniques": [
                {
                    "id": "T1547.009",
                    "name_eng": "Shortcut Modification",
                    "name_jp": "ショートカットの変更",
                    "description_eng": "Adversaries may create or modify shortcuts that can execute a program during system boot or user login. Shortcuts or symbolic links are used to reference other files or programs that will be opened or executed when the shortcut is clicked or executed by a system startup process.\n\nAdversaries may abuse shortcuts in the startup folder to execute their tools and achieve persistence.(Citation: Shortcut for Persistence ) Although often used as payloads in an infection chain (e.g. [Spearphishing Attachment](https://attack.mitre.org/techniques/T1566/001)), adversaries may also create a new shortcut as a means of indirection, while also abusing [Masquerading](https://attack.mitre.org/techniques/T1036) to make the malicious shortcut appear as a legitimate program. Adversaries can also edit the target path or entirely replace an existing shortcut so their malware will be executed instead of the intended legitimate program.\n\nShortcuts can also be abused to establish persistence by implementing other methods. For example, LNK browser extensions may be modified (e.g. [Browser Extensions](https://attack.mitre.org/techniques/T1176/001)) to persistently launch malware.",
                    "description_jp": "攻撃者は、システム起動中やユーザーログイン中にプログラムを実行できるショートカットを作成または変更する可能性があります。ショートカットやシンボリックリンクは、そのショートカットがクリックされたり、システムの起動プロセスで実行されたりしたときに開かれたり実行されたりする他のファイルやプログラムを参照するために使用されます。\n\n攻撃者は、スタートアップフォルダ内のショートカットを悪用してツールを実行し、持続性を実現することがあります。(引用: 持続性を実現するショートカット) 感染チェーンのペイロードとして使用されることもよくありますが (例: [Spearphishing Attachment] (https://attack.mitre.org/techniques/T1566/001))、攻撃者は、間接的な手段として新しいショートカットを作成することもあります。また、[Masquerading](https://attack.mitre.org/techniques/T1036) を悪用して、悪意のあるショートカットを正規のプログラムのように見せることもあります。また、標的のパスを編集したり、既存のショートカットを完全に置き換えたりすることで、意図した正規プログラムの代わりにマルウェアを実行させることも可能です。\n\nまた、ショートカットを悪用して、他の方法を実装することで永続性を確立することも可能です。たとえば、LNKブラウザの拡張機能を変更して（[ブラウザ拡張機能](https://attack.mitre.org/techniques/T1176/001)など）、マルウェアを持続的に起動させることができます。"
                },
                {
                    "id": "T1547.006",
                    "name_eng": "Kernel Modules and Extensions",
                    "name_jp": "カーネルモジュールと拡張機能",
                    "description_eng": "Adversaries may modify the kernel to automatically execute programs on system boot. Loadable Kernel Modules (LKMs) are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system.(Citation: Linux Kernel Programming) \n\nWhen used maliciously, LKMs can be a type of kernel-mode [Rootkit](https://attack.mitre.org/techniques/T1014) that run with the highest operating system privilege (Ring 0).(Citation: Linux Kernel Module Programming Guide) Common features of LKM based rootkits include: hiding itself, selective hiding of files, processes and network activity, as well as log tampering, providing authenticated backdoors, and enabling root access to non-privileged users.(Citation: iDefense Rootkit Overview)\n\nKernel extensions, also called kext, are used in macOS to load functionality onto a system similar to LKMs for Linux. Since the kernel is responsible for enforcing security and the kernel extensions run as apart of the kernel, kexts are not governed by macOS security policies. Kexts are loaded and unloaded through <code>kextload</code> and <code>kextunload</code> commands. Kexts need to be signed with a developer ID that is granted privileges by Apple allowing it to sign Kernel extensions. Developers without these privileges may still sign kexts but they will not load unless SIP is disabled. If SIP is enabled, the kext signature is verified before being added to the AuxKC.(Citation: System and kernel extensions in macOS)\n\nSince macOS Catalina 10.15, kernel extensions have been deprecated in favor of System Extensions. However, kexts are still allowed as \"Legacy System Extensions\" since there is no System Extension for Kernel Programming Interfaces.(Citation: Apple Kernel Extension Deprecation)\n\nAdversaries can use LKMs and kexts to conduct [Persistence](https://attack.mitre.org/tactics/TA0003) and/or [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) on a system. Examples have been found in the wild, and there are some relevant open source projects as well.(Citation: Volatility Phalanx2)(Citation: CrowdStrike Linux Rootkit)(Citation: GitHub Reptile)(Citation: GitHub Diamorphine)(Citation: RSAC 2015 San Francisco Patrick Wardle)(Citation: Synack Secure Kernel Extension Broken)(Citation: Securelist Ventir)(Citation: Trend Micro Skidmap)",
                    "description_jp": "攻撃者は、システム起動時に自動的にプログラムを実行するようにカーネルを変更する可能性があります。ローダブルカーネルモジュール（LKM）は、要求に応じてカーネルにロードしたりアンロードしたりできるコードの断片です。システムを再起動することなく、カーネルの機能を拡張します。例えば、モジュールの一種にデバイス・ドライバがあり、カーネルがシステムに接続されたハードウェアにアクセスできるようにする。 引用：Linuxカーネル・プログラミング\n\n悪意を持って使用された場合、LKMはカーネルモード[ルートキット](https://attack.mitre.org/techniques/T1014)の一種となり、オペレーティングシステムの最高権限(Ring 0)で実行されます(引用: Linux Kernel Module Programming Guide)。LKMベースのルートキットの一般的な機能には、自身を隠すこと、ファイル、プロセス、ネットワーク活動の選択的な非表示、およびログの改ざん、認証済みのバックドアの提供、非特権ユーザーへのルートアクセスの有効化などがあります(引用: iDefense Rootkit Overview)。\n\nkextとも呼ばれるカーネル拡張機能は、LinuxのLKMと同様にシステムに機能をロードするためにmacOSで使用されます。カーネルはセキュリティを実施する責任があり、カーネル拡張機能はカーネルの一部として実行されるため、kextはmacOSのセキュリティポリシーに支配されません。Kextsは<code>kextload</code>と<code>kextunload</code>コマンドでロードとアンロードを行います。Kext は、Apple からカーネル拡張に署名できる権限を与えられた開発者 ID で署名する必要があります。これらの権限を持たない開発者でもkextに署名することはできますが、SIPが無効になっていない限りロードされません。SIPが有効になっている場合、kextの署名はAuxKCに追加される前に検証されます。(引用: macOSにおけるシステムとカーネル拡張)\n\nmacOS Catalina 10.15以降、カーネル拡張機能は廃止され、システム拡張機能が使用されるようになりました。しかし、カーネルプログラミングインタフェースのシステム拡張がないため、kextは「レガシーシステム拡張」として許可されています。\n\n攻撃者は LKM と kext を使って、システム上で [Persistence](https://attack.mitre.org/tactics/TA0003) や [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) を行うことができます。例としては、Volatility Phalanx2)(引用: CrowdStrike Linux Rootkit)(引用: GitHub Reptile)(引用: GitHub Diamorphine)(引用: RSAC 2015 San Francisco Patrick Wardle)(引用: Synack Secure Kernel Extension Broken)(引用: Securelist Ventir)(引用: Trend Micro Skidmap)"
                },
                {
                    "id": "T1547.007",
                    "name_eng": "Re-opened Applications",
                    "name_jp": "再募集",
                    "description_eng": "Adversaries may modify plist files to automatically run an application when a user logs in. When a user logs out or restarts via the macOS Graphical User Interface (GUI), a prompt is provided to the user with a checkbox to \"Reopen windows when logging back in\".(Citation: Re-Open windows on Mac) When selected, all applications currently open are added to a property list file named <code>com.apple.loginwindow.[UUID].plist</code> within the <code>~/Library/Preferences/ByHost</code> directory.(Citation: Methods of Mac Malware Persistence)(Citation: Wardle Persistence Chapter) Applications listed in this file are automatically reopened upon the user’s next logon.\n\nAdversaries can establish [Persistence](https://attack.mitre.org/tactics/TA0003) by adding a malicious application path to the <code>com.apple.loginwindow.[UUID].plist</code> file to execute payloads when a user logs in.",
                    "description_jp": "攻撃者は、ユーザーがログインしたときに自動的にアプリケーションを実行するようにplistファイルを変更する可能性がある。ユーザーがmacOSのグラフィカル・ユーザー・インターフェース（GUI）を使ってログアウトまたは再起動すると、「再ログイン時にウィンドウを開き直す」というチェックボックスが付いたプロンプトが表示される（引用：Re-Open windows on Mac）。apple.loginwindow.[UUID].plist<//code>という名前のプロパティ リスト ファイルに追加されます。(引用: Mac マルウェア永続化の方法)(引用: Wardle 永続化の章) このファイルにリストされているアプリケーションは、ユーザーの次のログオン時に自動的に再開されます。\n\n攻撃者は、<code>com.apple.loginwindow.[UUID].plist</code>ファイルに悪意のあるアプリケーションのパスを追加することで、[Persistence](https://attack.mitre.org/tactics/TA0003)を確立し、ユーザーがログインしたときにペイロードを実行することができます。"
                },
                {
                    "id": "T1547.004",
                    "name_eng": "Winlogon Helper DLL",
                    "name_jp": "ウィンログオンヘルパーDLL",
                    "description_eng": "Adversaries may abuse features of Winlogon to execute DLLs and/or executables when a user logs in. Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete. Registry entries in <code>HKLM\\Software[\\\\Wow6432Node\\\\]\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> and <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> are used to manage additional helper programs and functionalities that support Winlogon.(Citation: Cylance Reg Persistence Sept 2013) \n\nMalicious modifications to these Registry keys may cause Winlogon to load and execute malicious DLLs and/or executables. Specifically, the following subkeys have been known to be possibly vulnerable to abuse: (Citation: Cylance Reg Persistence Sept 2013)\n\n* Winlogon\\Notify - points to notification package DLLs that handle Winlogon events\n* Winlogon\\Userinit - points to userinit.exe, the user initialization program executed when a user logs on\n* Winlogon\\Shell - points to explorer.exe, the system shell executed when a user logs on\n\nAdversaries may take advantage of these features to repeatedly execute malicious code and establish persistence.",
                    "description_jp": "攻撃者はWinlogonの機能を悪用し、ユーザーがログインした際にDLLや実行ファイルを実行する可能性がある。Winlogon.exe は、ログオン/ログオフ時のアクションや、Ctrl-Alt-Delete によってトリガーされるセキュア アテンション シーケンス (SAS) を担当する Windows コンポーネントです。<code>HKLMSoftware[◆Wow6432Node]◆MicrosoftWindows NTCurrentVersion</code>と<code>HKCUSoftware</code>のレジストリエントリは、Winlogonをサポートする追加のヘルパープログラムと機能を管理するために使用される(Citation: Cylance Reg Persistence Sept 2013)\n\nこれらのレジストリキーに悪意のある変更を加えると、Winlogonが悪意のあるDLLや実行可能ファイルをロードして実行する可能性があります。具体的には、以下のサブキーが悪用される可能性があることが知られています: (引用: Cylance Reg Persistence Sept 2013)\n\n* WinlogonNotify - Winlogonイベントを処理する通知パッケージDLLを指す。\n* WinlogonUserinit - userinit.exe（ユーザがログオンしたときに実行されるユーザ初期化プログラム）を指す。\n* WinlogonShell - explorer.exe（ユーザがログオンしたときに実行されるシス テムシェル）を指す。\n\nWinlogonShell-ユーザがログオンしたときに実行されるシステム・シェルであるexplorer.exeを指す。"
                },
                {
                    "id": "T1547.005",
                    "name_eng": "Security Support Provider",
                    "name_jp": "セキュリティ・サポート・プロバイダー",
                    "description_eng": "Adversaries may abuse security support providers (SSPs) to execute DLLs when the system boots. Windows SSP DLLs are loaded into the Local Security Authority (LSA) process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user's Domain password or smart card PINs.\n\nThe SSP configuration is stored in two Registry keys: <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages</code> and <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig\\Security Packages</code>. An adversary may modify these Registry keys to add new SSPs, which will be loaded the next time the system boots, or when the AddSecurityPackage Windows API function is called.(Citation: Graeber 2014)",
                    "description_jp": "攻撃者は、セキュリティサポートプロバイダ（SSP）を悪用して、システム起動時に DLL を実行する可能性がある。WindowsのSSP DLLは、システム起動時にローカルセキュリティオーソリティ（LSA）プロセスにロードされる。LSA にロードされると、SSP DLL は、ログオンしているユーザーのドメイン・パスワードやスマート・カードの PIN など、Windows に保存されている暗号化されたパスワードや平文のパスワードにアクセスできるようになる。\n\nSSP 構成は、2つのレジストリ・キーに格納される：<Code>HKLMSYSTEM\\CurrentControlSetControlLsaSecurity Packages</code> と <Code>HKLMSYSTEM\\CurrentControlSetControlLsaOSConfig\\Security Packages</code> である。敵対者は、これらのレジストリ・キーを変更して新しいSSPを追加し、次回システム起動時、またはAddSecurityPackage Windows API関数が呼び出されたときにロードする可能性がある(Citation: Graeber 2014)。"
                },
                {
                    "id": "T1547.001",
                    "name_eng": "Registry Run Keys / Startup Folder",
                    "name_jp": "レジストリの実行キー / スタートアップフォルダ",
                    "description_eng": "Adversaries may achieve persistence by adding a program to a startup folder or referencing it with a Registry run key. Adding an entry to the \"run keys\" in the Registry or startup folder will cause the program referenced to be executed when a user logs in.(Citation: Microsoft Run Key) These programs will be executed under the context of the user and will have the account's associated permissions level.\n\nThe following run keys are created by default on Windows systems:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code>\n\nRun keys may exist under multiple hives.(Citation: Microsoft Wow6432Node 2018)(Citation: Malwarebytes Wow6432Node 2016) The <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx</code> is also available but is not created by default on Windows Vista and newer. Registry run key entries can reference programs directly or list them as a dependency.(Citation: Microsoft Run Key) For example, it is possible to load a DLL at logon using a \"Depend\" key with RunOnceEx: <code>reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\0001\\Depend /v 1 /d \"C:\\temp\\evil[.]dll\"</code> (Citation: Oddvar Moe RunOnceEx Mar 2018)\n\nPlacing a program within a startup folder will also cause that program to execute when a user logs in. There is a startup folder location for individual user accounts as well as a system-wide startup folder that will be checked regardless of which user account logs in. The startup folder path for the current user is <code>C:\\Users\\\\[Username]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup</code>. The startup folder path for all users is <code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp</code>.\n\nThe following Registry keys can be used to set startup folder items for persistence:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n\nThe following Registry keys can control automatic startup of services during boot:\n\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices</code>\n\nUsing policy settings to specify startup programs creates corresponding values in either of two Registry keys:\n\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run</code>\n\nPrograms listed in the load value of the registry key <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> run automatically for the currently logged-on user.\n\nBy default, the multistring <code>BootExecute</code> value of the registry key <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager</code> is set to <code>autocheck autochk *</code>. This value causes Windows, at startup, to check the file-system integrity of the hard disks if the system has been shut down abnormally. Adversaries can add other programs or processes to this registry value which will automatically launch at boot.\n\nAdversaries can use these configuration locations to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use [Masquerading](https://attack.mitre.org/techniques/T1036) to make the Registry entries look as if they are associated with legitimate programs.",
                    "description_jp": "攻撃者は、プログラムをスタートアップフォルダに追加したり、レジストリのランキーで参照したりすることで、永続性を実現することができる。レジストリまたはスタートアップフォルダの「実行キー」にエントリを追加すると、ユーザーがログインしたときに参照されたプログラムが実行されるようになる（引用：Microsoft Run Key）。\n\nWindowsシステムでは、以下のランキーがデフォルトで作成される：\n\n* <code>HKEY_CURRENT_USERSoftwareMicrosoftWindows\\CurrentVersion\\Run</code>\n* <code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersionRunOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\MicrosoftWindows\\CurrentVersion</code>Run</code>\n* <code>HKEY_LOCAL_MACHINE_Software\\MicrosoftWindows\\CurrentVersion\\RunOnce</code>\n\nランキーは複数のハイブの下に存在する可能性があります。(引用: Microsoft Wow6432Node 2018)(引用: Malwarebytes Wow6432Node 2016) <code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindows\\CurrentVersionRunOnceEx</code> も利用可能ですが、Windows Vista以降ではデフォルトでは作成されません。レジストリのランキーエントリは、プログラムを直接参照することも、依存関係としてリストすることもできます。 引用：Microsoft Run Key） 例えば、RunOnceExで「Depend」キーを使用してログオン時にDLLをロードすることが可能です：<code>reg add HKLMSOFTWARE\\MicrosoftWindowsCurrentVersionRunOnceEx0001Depend /v 1 /d \"C:゙temp\\evil[.]dll\"</code> （引用：Oddvar Moe RunOnceEx 2018年3月号\n\nスタートアップフォルダ内にプログラムを配置すると、ユーザーがログインしたときにそのプログラムが実行されるようにもなる。個々のユーザーアカウント用のスタートアップフォルダーの場所と、どのユーザーアカウントがログインしてもチェックされるシステム全体のスタートアップフォルダーがあります。現在のユーザーのスタートアップフォルダのパスは<code>C:¥Users¥Username¥AppData¥Roaming¥Microsoft¥Windows¥Start Menu¥ProgramsStartup</code>である。全ユーザのスタートアップフォルダのパスは<code>C:¥ProgramData¥Microsoft¥Windows¥Start Menu¥Programs¥StartUp</code>です。\n\n以下のレジストリ・キーを使用して、永続化するスタートアップ・フォルダ項目を設定できます：\n\n<code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n* <code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersionExplorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWAREMicrosoftWindows\\CurrentVersion ReplicaShell Folders</code>\n* <code>HKEY_LOCAL_MACHINE ProxySOFTWARE</code> * <code>HKEY_LOCAL_MACHINE ProxySOFTWARE</code> * <code>HKEY_LOCAL_MACHINE ProxySOFTWARE</code\n\n以下のレジストリキーは、ブート時のサービスの自動起動を制御できます：\n\n<code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_CURRENT_USERソフトウェアの章\n* <code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindows\\CurrentVersionRunServices</code>\n* <code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersion\\RunServices</code>\n\nポリシー設定を使用してスタートアップ プログラムを指定すると、2 つのレジストリ キーのいずれかに対応する値が作成されます：\n\n<code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindowsCurrentVersion\\Policies\\Explorer\\Run</code>\n<code>HKEY_CURRENT_USER Software\\MicrosoftWindows\\CurrentVersion\\Policies\\Explorer</Run</code>\n\nレジストリキー<code>HKEY_CURRENT_USER</code>のロード値にリストされているプログラムは、現在ログオンしているユーザーのために自動的に実行されます。\n\nデフォルトでは、レジストリ・キー<code>HKEY_LOCAL_MACHINE</code>の<code>BootExecute</code>値は<code>autocheck autochk *</code>に設定されています。この値は、システムが異常にシャットダウンされた場合、起動時にWindowsがハード ディスクのファイル システムの整合性をチェックするようにします。攻撃者は、起動時に自動的に起動する他のプログラムやプロセスを、このレジストリ値に追加することができる。\n\n攻撃者は、リモートアクセスツールなどのマルウェアを実行するために、これらの設定ロケーションを使用し、システムの再起動を通じて永続性を維持することができます。また、攻撃者は[Masquerading](https://attack.mitre.org/techniques/T1036)を使用して、レジストリエントリが正規のプログラムに関連付けられているかのように見せかけることもできます。"
                },
                {
                    "id": "T1547.008",
                    "name_eng": "LSASS Driver",
                    "name_jp": "LSASSドライバー",
                    "description_eng": "Adversaries may modify or add LSASS drivers to obtain persistence on compromised systems. The Windows security subsystem is a set of components that manage and enforce the security policy for a computer or domain. The Local Security Authority (LSA) is the main component responsible for local security policy and user authentication. The LSA includes multiple dynamic link libraries (DLLs) associated with various other security functions, all of which run in the context of the LSA Subsystem Service (LSASS) lsass.exe process.(Citation: Microsoft Security Subsystem)\n\nAdversaries may target LSASS drivers to obtain persistence. By either replacing or adding illegitimate drivers (e.g., [Hijack Execution Flow](https://attack.mitre.org/techniques/T1574)), an adversary can use LSA operations to continuously execute malicious payloads.",
                    "description_jp": "攻撃者はLSASSドライバを変更または追加して、侵害されたシステム上で永続性を得ることができる。Windowsセキュリティサブシステムは、コンピュータやドメインのセキュリティポリシーを管理・実施するコンポーネントの集合である。ローカルセキュリティオーソリティ（LSA）は、ローカルセキュリティポリシーとユーザー認証を担当する主要コンポーネントである。LSAには、他のさまざまなセキュリティ機能に関連する複数のダイナミックリンクライブラリ（DLL）が含まれており、これらはすべてLSAサブシステムサービス（LSASS）lsass.exeプロセスのコンテキストで実行される（引用：Microsoft Security Subsystem）。\n\n攻撃者は、LSASSドライバを標的として永続性を獲得する可能性があります。不正なドライバ(例えば、[Hijack Execution Flow](https://attack.mitre.org/techniques/T1574))を置き換えたり追加したりすることで、敵対者はLSAオペレーションを使用して悪意のあるペイロードを継続的に実行することができます。"
                },
                {
                    "id": "T1547.012",
                    "name_eng": "Print Processors",
                    "name_jp": "プリントプロセッサー",
                    "description_eng": "Adversaries may abuse print processors to run malicious DLLs during system boot for persistence and/or privilege escalation. Print processors are DLLs that are loaded by the print spooler service, `spoolsv.exe`, during boot.(Citation: Microsoft Intro Print Processors)\n\nAdversaries may abuse the print spooler service by adding print processors that load malicious DLLs at startup. A print processor can be installed through the <code>AddPrintProcessor</code> API call with an account that has <code>SeLoadDriverPrivilege</code> enabled. Alternatively, a print processor can be registered to the print spooler service by adding the <code>HKLM\\SYSTEM\\\\[CurrentControlSet or ControlSet001]\\Control\\Print\\Environments\\\\[Windows architecture: e.g., Windows x64]\\Print Processors\\\\[user defined]\\Driver</code> Registry key that points to the DLL.\n\nFor the malicious print processor to be correctly installed, the payload must be located in the dedicated system print-processor directory, that can be found with the <code>GetPrintProcessorDirectory</code> API call, or referenced via a relative path from this directory.(Citation: Microsoft AddPrintProcessor May 2018) After the print processors are installed, the print spooler service, which starts during boot, must be restarted in order for them to run.(Citation: ESET PipeMon May 2020)\n\nThe print spooler service runs under SYSTEM level permissions, therefore print processors installed by an adversary may run under elevated privileges.",
                    "description_jp": "攻撃者はプリントプロセッサを悪用して、システムブート中に悪意のある DLL を実行し、永続化や権限昇格を行う可能性がある。プリントプロセッサは、ブート中にプリントスプーラサービスである `spoolsv.exe` によってロードされる DLL である。(引用: Microsoft Intro Print Processors)\n\n攻撃者は、起動時に悪意のあるDLLをロードするプリントプロセッサを追加することで、プリントスプーラサービスを悪用する可能性があります。プリント プロセッサは、<code>SeLoadDriverPrivilege</code> を有効にしたアカウントで、<code>AddPrintProcessor</code> API 呼び出しによってインストールできます。または、DLLを指すレジストリキー<code>HKLMSYSTEM</code>[CurrentControlSet or ControlSet001]◆ControlPrint</code>[Windowsアーキテクチャ: 例: Windows x64]◆Print Processors</code>[ユーザー定義]◆Driver</code>を追加することで、プリントプロセッサをプリントスプーラサービスに登録できます。\n\n悪意のあるプリント プロセッサが正しくインストールされるには、ペイロードが専用のシステム プリント プロセッサ ディレクトリに配置されている必要があり、このディレクトリは <code>GetPrintProcessorDirectory</code> API 呼び出しで見つけることができるか、このディレクトリからの相対パスを介して参照されます (引用: Microsoft AddPrintProcessor 2018年5月)。プリント プロセッサがインストールされた後、それらを実行するには、ブート中に起動するプリント スプーラ サービスを再起動する必要があります (引用: ESET PipeMon 2020年5月)。\n\nプリントスプーラサービスはSYSTEMレベルの権限で実行されるため、敵がインストールしたプリントプロセッサは昇格した権限で実行される可能性があります。"
                },
                {
                    "id": "T1547.014",
                    "name_eng": "Active Setup",
                    "name_jp": "アクティブセットアップ",
                    "description_eng": "Adversaries may achieve persistence by adding a Registry key to the Active Setup of the local machine. Active Setup is a Windows mechanism that is used to execute programs when a user logs in. The value stored in the Registry key will be executed after a user logs into the computer.(Citation: Klein Active Setup 2010) These programs will be executed under the context of the user and will have the account's associated permissions level.\n\nAdversaries may abuse Active Setup by creating a key under <code> HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\</code> and setting a malicious value for <code>StubPath</code>. This value will serve as the program that will be executed when a user logs into the computer.(Citation: Mandiant Glyer APT 2010)(Citation: Citizenlab Packrat 2015)(Citation: FireEye CFR Watering Hole 2012)(Citation: SECURELIST Bright Star 2015)(Citation: paloalto Tropic Trooper 2016)\n\nAdversaries can abuse these components to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use [Masquerading](https://attack.mitre.org/techniques/T1036) to make the Registry entries look as if they are associated with legitimate programs.",
                    "description_jp": "攻撃者は、ローカル・マシンのアクティブ・セットアップにレジストリ・キーを追加することで、永続性を実現することができる。アクティブ・セットアップは、ユーザーがログインしたときにプログラムを実行するために使用されるWindowsのメカニズムである。レジストリ・キーに格納された値は、ユーザがコンピュータにログインした後に実行される(引用: Klein Active Setup 2010)。これらのプログラムは、ユーザのコンテキスト下で実行され、アカウントに関連付けられた権限レベルを持つ。\n\n攻撃者は、<code> HKLMSOFTWAREMicrosoftActive Setup\\Installed Components</code>の下にキーを作成し、<code>StubPath</code>に悪意のある値を設定することで、Active Setupを悪用する可能性があります。この値は、ユーザーがコンピュータにログインしたときに実行されるプログラムとして機能します。 引用：Mandiant Glyer APT 2010）（ 引用：Citizenlab Packrat 2015）（ 引用：FireEye CFR Watering Hole 2012）（ 引用：SECURELIST Bright Star 2015）（ 引用：paloalto Tropic Trooper 2016\n\n攻撃者はこれらのコンポーネントを悪用して、リモートアクセスツールなどのマルウェアを実行し、システムの再起動を通じて永続性を維持することができます。また、攻撃者は[Masquerading](https://attack.mitre.org/techniques/T1036)を使用して、レジストリエントリが正規のプログラムに関連付けられているかのように見せかけることもあります。"
                },
                {
                    "id": "T1547.015",
                    "name_eng": "Login Items",
                    "name_jp": "ログイン項目",
                    "description_eng": "Adversaries may add login items to execute upon user login to gain persistence or escalate privileges. Login items are applications, documents, folders, or server connections that are automatically launched when a user logs in.(Citation: Open Login Items Apple) Login items can be added via a shared file list or Service Management Framework.(Citation: Adding Login Items) Shared file list login items can be set using scripting languages such as [AppleScript](https://attack.mitre.org/techniques/T1059/002), whereas the Service Management Framework uses the API call <code>SMLoginItemSetEnabled</code>.\n\nLogin items installed using the Service Management Framework leverage <code>launchd</code>, are not visible in the System Preferences, and can only be removed by the application that created them.(Citation: Adding Login Items)(Citation: SMLoginItemSetEnabled Schroeder 2013) Login items created using a shared file list are visible in System Preferences, can hide the application when it launches, and are executed through LaunchServices, not launchd, to open applications, documents, or URLs without using Finder.(Citation: Launch Services Apple Developer) Users and applications use login items to configure their user environment to launch commonly used services or applications, such as email, chat, and music applications.\n\nAdversaries can utilize [AppleScript](https://attack.mitre.org/techniques/T1059/002) and [Native API](https://attack.mitre.org/techniques/T1106) calls to create a login item to spawn malicious executables.(Citation: ELC Running at startup) Prior to version 10.5 on macOS, adversaries can add login items by using [AppleScript](https://attack.mitre.org/techniques/T1059/002) to send an Apple events to the “System Events” process, which has an AppleScript dictionary for manipulating login items.(Citation: Login Items AE) Adversaries can use a command such as <code>tell application “System Events” to make login item at end with properties /path/to/executable</code>.(Citation: Startup Items Eclectic)(Citation: hexed osx.dok analysis 2019)(Citation: Add List Remove Login Items Apple Script) This command adds the path of the malicious executable to the login item file list located in <code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm</code>.(Citation: Startup Items Eclectic) Adversaries can also use login items to launch executables that can be used to control the victim system remotely or as a means to gain privilege escalation by prompting for user credentials.(Citation: objsee mac malware 2017)(Citation: CheckPoint Dok)(Citation: objsee netwire backdoor 2019)",
                    "description_jp": "攻撃者は、ユーザーのログイン時に実行するログイン項目を追加して、永続性を得たり、特権を昇格させたりする可能性がある。ログイン項目とは、ユーザーがログインしたときに自動的に起動されるアプリケーション、ドキュメント、フォルダ、またはサーバー接続のことです。(引用: Open Login Items Apple) ログイン項目は、共有ファイルリストまたはService Management Frameworkを介して追加できます。(引用: Adding Login Items) 共有ファイルリストのログイン項目は、[AppleScript](https://attack.mitre.org/techniques/T1059/002)などのスクリプト言語を使用して設定できますが、Service Management FrameworkはAPIコール<code>SMLoginItemSetEnabled</code>を使用します。\n\nService Management Framework を使用してインストールされたログイン項目は <code>launchd<//code> を活用し、システム環境設定には表示されず、作成したアプリケーションによってのみ削除できます。(引用: ログイン項目の追加)(引用: SMLoginItemSetEnabled Schroeder 2013) 共有ファイルリストを使用して作成されたログイン項目はシステム環境設定に表示され、起動時にアプリケーションを隠すことができ、launchd ではなく LaunchServices を介して実行され、Finder を使用せずにアプリケーション、ドキュメント、または URL を開くことができます。(引用：Launch Services Apple Developer） ユーザーやアプリケーションは、ログイン項目を使用してユーザー環境を構成し、電子メール、チャット、音楽アプリケーションなど、一般的に使用されるサービスやアプリケーションを起動します。\n\n攻撃者は、[AppleScript](https://attack.mitre.org/techniques/T1059/002) や [Native API](https://attack.mitre.org/techniques/T1106) の呼び出しを利用してログイン項目を作成し、悪意のある実行可能ファイルを起動することができます。(引用: ELC Running at startup) macOS のバージョン 10.5 より前のバージョンでは、攻撃者は [AppleScript](https://attack.mitre.org/techniques/T1059/002）を使用して、ログイン項目を操作するためのAppleScript辞書を持つ「System Events」プロセスにAppleイベントを送信することができます（引用：Login Items AE） 敵は、<code>tell application \"System Events\" to make login item at end with properties /path/to/executable</code>のようなコマンドを使用することができます。(引用: Startup Items Eclectic)(Citation: hexed osx.dok analysis 2019)(Citation: Add List Remove Login Items Apple Script) このコマンドは、悪意のある実行ファイルのパスを <code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm<//code> にあるログイン項目ファイル リストに追加します。(引用: Startup Items Eclectic) また、攻撃者はログインアイテムを使用して、被害者システムを遠隔操作するために使用できる実行可能ファイルを起動したり、ユーザー認証情報の入力を促して特権を昇格させる手段として使用したりすることもできます(引用: objsee mac malware 2017)(引用: CheckPoint Dok)(引用: objsee netwire backdoor 2019)"
                },
                {
                    "id": "T1547.013",
                    "name_eng": "XDG Autostart Entries",
                    "name_jp": "XDGオートスタートエントリー",
                    "description_eng": "Adversaries may add or modify XDG Autostart Entries to execute malicious programs or commands when a user’s desktop environment is loaded at login. XDG Autostart entries are available for any XDG-compliant Linux system. XDG Autostart entries use Desktop Entry files (`.desktop`) to configure the user’s desktop environment upon user login. These configuration files determine what applications launch upon user login, define associated applications to open specific file types, and define applications used to open removable media.(Citation: Free Desktop Application Autostart Feb 2006)(Citation: Free Desktop Entry Keys)\n\nAdversaries may abuse this feature to establish persistence by adding a path to a malicious binary or command to the `Exec` directive in the `.desktop` configuration file. When the user’s desktop environment is loaded at user login, the `.desktop` files located in the XDG Autostart directories are automatically executed. System-wide Autostart entries are located in the `/etc/xdg/autostart` directory while the user entries are located in the `~/.config/autostart` directory.\n\nAdversaries may combine this technique with [Masquerading](https://attack.mitre.org/techniques/T1036) to blend malicious Autostart entries with legitimate programs.(Citation: Red Canary Netwire Linux 2022)",
                    "description_jp": "侵入者は、XDG 自動起動エントリを追加または変更することで、ログイン時にユーザーのデスクトップ環境がロードされる際に、悪意のあるプログラムやコマンドを実行する可能性があります。XDG 自動起動エントリは、XDG 準拠の Linux システムで使用できます。XDG 自動起動エントリは、デスクトップ エントリ ファイル (`.desktop`) を使用して、ユーザーのログイン時にデスクトップ環境を設定します。これらの設定ファイルは、ユーザーログイン時に起動するアプリケーションを決定し、特定のファイルタイプを開くための関連アプリケーションを定義し、リムーバブルメディアを開くために使用するアプリケーションを定義します(引用: Free Desktop Application Autostart Feb 2006)(Citation: Free Desktop Entry Keys)\n\n攻撃者はこの機能を悪用し、`.desktop`設定ファイルの`Exec`ディレクティブに悪意のあるバイナリやコマンドへのパスを追加することで、永続性を確立する可能性がある。ユーザーのログイン時にデスクトップ環境がロードされると、XDG の自動起動ディレクトリにある `.desktop` ファイルが自動的に実行されます。システム全体の Autostart エントリは `/etc/xdg/autostart` ディレクトリにあり、ユーザーのエントリは `~/.config/autostart` ディレクトリにあります。\n\n攻撃者は、このテクニックを[Masquerading](https://attack.mitre.org/techniques/T1036)と組み合わせて、悪意のあるAutostartエントリーを正当なプログラムに紛れ込ませる可能性がある(引用: Red Canary Netwire Linux 2022)。"
                },
                {
                    "id": "T1547.003",
                    "name_eng": "Time Providers",
                    "name_jp": "時間プロバイダー",
                    "description_eng": "Adversaries may abuse time providers to execute DLLs when the system boots. The Windows Time service (W32Time) enables time synchronization across and within domains.(Citation: Microsoft W32Time Feb 2018) W32Time time providers are responsible for retrieving time stamps from hardware/network resources and outputting these values to other network clients.(Citation: Microsoft TimeProvider)\n\nTime providers are implemented as dynamic-link libraries (DLLs) that are registered in the subkeys of `HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\`.(Citation: Microsoft TimeProvider) The time provider manager, directed by the service control manager, loads and starts time providers listed and enabled under this key at system startup and/or whenever parameters are changed.(Citation: Microsoft TimeProvider)\n\nAdversaries may abuse this architecture to establish persistence, specifically by creating a new arbitrarily named subkey  pointing to a malicious DLL in the `DllName` value. Administrator privileges are required for time provider registration, though execution will run in context of the Local Service account.(Citation: Github W32Time Oct 2017)",
                    "description_jp": "攻撃者はタイムプロバイダーを悪用し、システム起動時にDLLを実行する可能性がある。Windows Timeサービス(W32Time)は、ドメイン間およびドメイン内での時刻同期を可能にする(引用: Microsoft W32Time Feb 2018) W32Timeタイムプロバイダは、ハードウェア/ネットワークリソースからタイムスタンプを取得し、これらの値を他のネットワーククライアントに出力する役割を担う(引用: Microsoft TimeProvider)\n\nタイムプロバイダーは、`HKEY_LOCAL_MACHINESystemCurrentControlSet\\Services\\W32TimeTimeProviders` のサブキーに登録されるダイナミックリンクライブラリー（DLL）として実装される(引用: Microsoft TimeProvider) タイムプロバイダーマネージャーは、サービスコントロールマネージャーによって指示され、システムの起動時やパラメーターが変更されるたびに、このキーの下にリストされ有効になっているタイムプロバイダーをロードして起動する(引用: Microsoft TimeProvider)\n\n特に、`DllName`の値に悪意のあるDLLを指す、任意に命名された新しいサブキーを作成することである。タイムプロバイダの登録には管理者権限が必要ですが、実行はローカルサービスアカウントのコンテキストで実行されます(引用: Github W32Time Oct 2017)"
                },
                {
                    "id": "T1547.002",
                    "name_eng": "Authentication Package",
                    "name_jp": "認証パッケージ",
                    "description_eng": "Adversaries may abuse authentication packages to execute DLLs when the system boots. Windows authentication package DLLs are loaded by the Local Security Authority (LSA) process at system start. They provide support for multiple logon processes and multiple security protocols to the operating system.(Citation: MSDN Authentication Packages)\n\nAdversaries can use the autostart mechanism provided by LSA authentication packages for persistence by placing a reference to a binary in the Windows Registry location <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\</code> with the key value of <code>\"Authentication Packages\"=&lt;target binary&gt;</code>. The binary will then be executed by the system when the authentication packages are loaded.",
                    "description_jp": "攻撃者は認証パッケージを悪用し、システム起動時に DLL を実行する可能性がある。Windowsの認証パッケージDLLは、システム起動時にLSA（Local Security Authority）プロセスによってロードされる。これらのDLLは、複数のログオンプロセスと複数のセキュリティプロトコルをオペレーティングシステムに提供する。(引用：MSDN Authentication Packages)\n\n攻撃者は、<code>\"Authentication Packages\"=&lt;target binary&gt;</code>のキー値を持つバイナリへの参照をWindowsレジストリの場所<code>HKLMSYSTEMCurntionControlLsa</code>に置くことで、LSA認証パッケージによって提供される自動開始メカニズムを永続化のために使用することができる。認証パッケージがロードされると、このバイナリがシステムによって実行される。"
                },
                {
                    "id": "T1547.010",
                    "name_eng": "Port Monitors",
                    "name_jp": "ポートモニター",
                    "description_eng": "Adversaries may use port monitors to run an adversary supplied DLL during system boot for persistence or privilege escalation. A port monitor can be set through the <code>AddMonitor</code> API call to set a DLL to be loaded at startup.(Citation: AddMonitor) This DLL can be located in <code>C:\\Windows\\System32</code> and will be loaded and run by the print spooler service, `spoolsv.exe`, under SYSTEM level permissions on boot.(Citation: Bloxham) \n\nAlternatively, an arbitrary DLL can be loaded if permissions allow writing a fully-qualified pathname for that DLL to the `Driver` value of an existing or new arbitrarily named subkey of <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors</code>. The Registry key contains entries for the following:\n\n* Local Port\n* Standard TCP/IP Port\n* USB Monitor\n* WSD Port",
                    "description_jp": "攻撃者は、ポートモニターを使用して、システムブート中に攻撃者が提供する DLL を実行し、永続化または特権昇格を行う可能性がある。ポートモニターは、<code>AddMonitor</code> API 呼び出しを通じて設定することができ、起動時にロードされる DLL を設定します。(引用: AddMonitor) この DLL は、<code>C:</code><code>Windows</code><code>System32</code><code> に配置することができ、印刷スプーラーサービスである `spoolsv.exe` によって、起動時に SYSTEM レベルの権限でロードされ実行されます。\n\nあるいは、<code>HKLMSYSTEMCurrentControllSetControlPrintMonitors</code>の既存または新規の任意の名前のサブキーの`Driver`値に、そのDLLの完全修飾パス名を書き込むことを許可するパーミッションがあれば、任意のDLLをロードすることができます。レジストリキーには、以下のエントリが含まれる：\n\n* ローカルポート\n* 標準TCP/IPポート\n* USBモニター\n* WSDポート"
                }
            ]
        },
        {
            "id": "T1137",
            "name_eng": "Office Application Startup",
            "name_jp": "オフィスアプリケーションの起動",
            "description_eng": "Adversaries may leverage Microsoft Office-based applications for persistence between startups. Microsoft Office is a fairly common application suite on Windows-based operating systems within an enterprise network. There are multiple mechanisms that can be used with Office for persistence when an Office-based application is started; this can include the use of Office Template Macros and add-ins.\n\nA variety of features have been discovered in Outlook that can be abused to obtain persistence, such as Outlook rules, forms, and Home Page.(Citation: SensePost Ruler GitHub) These persistence mechanisms can work within Outlook or be used through Office 365.(Citation: TechNet O365 Outlook Rules)",
            "description_jp": "攻撃者は、マイクロソフト・オフィス・ベースのアプリケーションを、スタートアップ間の永続性のために活用するかもしれない。Microsoft Officeは、企業ネットワーク内のWindowsベースのオペレーティング・システム上でかなり一般的なアプリケーション・スイートである。Officeベースのアプリケーションが起動されたときに、Officeで永続化のために使用できる複数のメカニズムがあります。これには、Officeテンプレートマクロやアドインの使用が含まれます。\n\nOutlookでは、Outlookルール、フォーム、ホームページなど、永続性を得るために悪用できるさまざまな機能が発見されている（引用：SensePost Ruler GitHub）。これらの永続性メカニズムは、Outlook内で機能することも、Office 365を通じて使用することもできる（引用：TechNet O365 Outlook Rules）。",
            "subtechniques": [
                {
                    "id": "T1137.002",
                    "name_eng": "Office Test",
                    "name_jp": "オフィステスト",
                    "description_eng": "Adversaries may abuse the Microsoft Office \"Office Test\" Registry key to obtain persistence on a compromised system. An Office Test Registry location exists that allows a user to specify an arbitrary DLL that will be executed every time an Office application is started. This Registry key is thought to be used by Microsoft to load DLLs for testing and debugging purposes while developing Office applications. This Registry key is not created by default during an Office installation.(Citation: Hexacorn Office Test)(Citation: Palo Alto Office Test Sofacy)\n\nThere exist user and global Registry keys for the Office Test feature, such as:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Office test\\Special\\Perf</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Office test\\Special\\Perf</code>\n\nAdversaries may add this Registry key and specify a malicious DLL that will be executed whenever an Office application, such as Word or Excel, is started.",
                    "description_jp": "攻撃者は、Microsoft Officeの「Office Test」レジストリキーを悪用し、侵害されたシステム上で永続性を取得する可能性がある。Office Testレジストリの場所は、Officeアプリケーションが起動するたびに実行される任意のDLLを指定できるようにするために存在する。このレジストリキーは、マイクロソフトがOfficeアプリケーションの開発中にテストやデバッグの目的でDLLをロードするために使用すると考えられています。このレジストリキーは、Officeのインストール時にはデフォルトでは作成されない。 引用：Hexacorn Office Test）（引用：Palo Alto Office Test Sofacy\n\nOffice Test機能には、以下のようなユーザーレジストリキーとグローバルレジストリキーが存在する：\n\n<code>HKEY_CURRENT_USERSoftwareMicrosoftOffice テスト</code></code></span\n<code>HKEY_LOCAL_MACHINE\n\n攻撃者はこのレジストリキーを追加し、WordやExcelなどのOfficeアプリケーションが起動するたびに実行される悪意のあるDLLを指定する可能性があります。"
                },
                {
                    "id": "T1137.001",
                    "name_eng": "Office Template Macros",
                    "name_jp": "Officeテンプレートマクロ",
                    "description_eng": "Adversaries may abuse Microsoft Office templates to obtain persistence on a compromised system. Microsoft Office contains templates that are part of common Office applications and are used to customize styles. The base templates within the application are used each time an application starts. (Citation: Microsoft Change Normal Template)\n\nOffice Visual Basic for Applications (VBA) macros (Citation: MSDN VBA in Office) can be inserted into the base template and used to execute code when the respective Office application starts in order to obtain persistence. Examples for both Word and Excel have been discovered and published. By default, Word has a Normal.dotm template created that can be modified to include a malicious macro. Excel does not have a template file created by default, but one can be added that will automatically be loaded.(Citation: enigma0x3 normal.dotm)(Citation: Hexacorn Office Template Macros) Shared templates may also be stored and pulled from remote locations.(Citation: GlobalDotName Jun 2019) \n\nWord Normal.dotm location:<br>\n<code>C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm</code>\n\nExcel Personal.xlsb location:<br>\n<code>C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\Excel\\XLSTART\\PERSONAL.XLSB</code>\n\nAdversaries may also change the location of the base template to point to their own by hijacking the application's search order, e.g. Word 2016 will first look for Normal.dotm under <code>C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\</code>, or by modifying the GlobalDotName registry key. By modifying the GlobalDotName registry key an adversary can specify an arbitrary location, file name, and file extension to use for the template that will be loaded on application startup. To abuse GlobalDotName, adversaries may first need to register the template as a trusted document or place it in a trusted location.(Citation: GlobalDotName Jun 2019) \n\nAn adversary may need to enable macros to execute unrestricted depending on the system or enterprise security policy on use of macros.",
                    "description_jp": "攻撃者は、侵害されたシステム上で永続性を得るためにMicrosoft Officeのテンプレートを悪用する可能性がある。Microsoft Officeには、一般的なOfficeアプリケーションの一部であり、スタイルをカスタマイズするために使用されるテンプレートが含まれています。アプリケーション内の基本テンプレートは、アプリケーションが起動するたびに使用されます。(引用：Microsoft Change Normal Template)\n\nOffice Visual Basic for Applications（VBA）マクロ（引用：MSDN VBA in Office）をベーステンプレートに挿入し、それぞれのOfficeアプリケーションの起動時にコードを実行して永続性を得るために使用することができます。WordとExcelの両方の例が発見され、公開されている。WordにはデフォルトでNormal.dotmテンプレートが作成され、悪意のあるマクロを含むように変更することができる。Excelはデフォルトではテンプレートファイルが作成されないが、自動的に読み込まれるテンプレートファイルを追加することができる(引用：enigma0x3 normal.dotm)(引用：Hexacorn Office Template Macros) 共有テンプレートも保存され、リモートロケーションから引き出される可能性がある(引用：GlobalDotName Jun 2019)\n\nWord Normal.dotm の場所:<br>。\n<code>C:◆Users&lt;ユーザー名&gt;◆AppData◆Roaming◆Microsoft◆Templates◆Normal.dotm<//code><br\n\nExcel Personal.xlsbの場所:<br>。\n<code>C:¥Users¥Username¥AppData¥Roaming¥Microsoft¥Excel¥XLSTART¥PERSONAL.XLSB</code\n\n例えば、Word 2016は最初に<code>C:³³Program Files (x86)³³Microsoft Office³³の下にあるNormal.dotmを探すか、GlobalDotNameレジストリキーを変更します。GlobalDotName レジストリキーを変更することで、アプリケーションの起動時にロードされるテンプレートに使用する任意の場所、ファイル名、ファイル拡張子を指定することができます。GlobalDotNameを悪用するために、敵対者はまず、テンプレートを信頼できるドキュメントとして登録するか、信頼できる場所に配置する必要があるかもしれない(引用：GlobalDotName Jun 2019)\n\n敵対者は、マクロの使用に関するシステムまたは企業のセキュリティポリシーに応じて、マクロを無制限に実行できるようにする必要があるかもしれません。"
                },
                {
                    "id": "T1137.004",
                    "name_eng": "Outlook Home Page",
                    "name_jp": "アウトルック ホームページ",
                    "description_eng": "Adversaries may abuse Microsoft Outlook's Home Page feature to obtain persistence on a compromised system. Outlook Home Page is a legacy feature used to customize the presentation of Outlook folders. This feature allows for an internal or external URL to be loaded and presented whenever a folder is opened. A malicious HTML page can be crafted that will execute code when loaded by Outlook Home Page.(Citation: SensePost Outlook Home Page)\n\nOnce malicious home pages have been added to the user’s mailbox, they will be loaded when Outlook is started. Malicious Home Pages will execute when the right Outlook folder is loaded/reloaded.(Citation: SensePost Outlook Home Page)",
                    "description_jp": "攻撃者は、Microsoft Outlookのホームページ機能を悪用し、侵害されたシステム上で永続性を得る可能性がある。Outlookのホームページは、Outlookフォルダの表示をカスタマイズするために使用されるレガシー機能である。この機能により、フォルダを開くたびに内部または外部のURLを読み込んで表示することができます。Outlook Home Pageによって読み込まれたときにコードを実行するような、悪意のあるHTMLページを作成することができます（引用：SensePost Outlook Home Page）。\n\n悪意のあるホームページがユーザーのメールボックスに追加されると、Outlookの起動時に読み込まれます。悪意のあるホームページは、適切なOutlookフォルダがロード/リロードされたときに実行される(引用：SensePost Outlook Home Page)"
                },
                {
                    "id": "T1137.003",
                    "name_eng": "Outlook Forms",
                    "name_jp": "アウトルックフォーム",
                    "description_eng": "Adversaries may abuse Microsoft Outlook forms to obtain persistence on a compromised system. Outlook forms are used as templates for presentation and functionality in Outlook messages. Custom Outlook forms can be created that will execute code when a specifically crafted email is sent by an adversary utilizing the same custom Outlook form.(Citation: SensePost Outlook Forms)\n\nOnce malicious forms have been added to the user’s mailbox, they will be loaded when Outlook is started. Malicious forms will execute when an adversary sends a specifically crafted email to the user.(Citation: SensePost Outlook Forms)",
                    "description_jp": "攻撃者は、Microsoft Outlookのフォームを悪用し、侵害されたシステム上で永続性を獲得する可能性がある。Outlookフォームは、Outlookメッセージのプレゼンテーションや機能のテンプレートとして使用される。カスタム Outlook フォームを作成し、同じカスタム Outlook フォームを使用して敵が特別に細工した電子メールを送信すると、コードが実行されるようにすることができる。 引用：SensePost Outlook Forms\n\n悪意のあるフォームがユーザーのメールボックスに追加されると、Outlookの起動時に読み込まれます。悪意のあるフォームが実行されるのは、敵が特別に細工した電子メールをユーザーに送信した場合です。(引用: SensePost Outlook Forms)"
                },
                {
                    "id": "T1137.006",
                    "name_eng": "Add-ins",
                    "name_jp": "アドイン",
                    "description_eng": "Adversaries may abuse Microsoft Office add-ins to obtain persistence on a compromised system. Office add-ins can be used to add functionality to Office programs. (Citation: Microsoft Office Add-ins) There are different types of add-ins that can be used by the various Office products; including Word/Excel add-in Libraries (WLL/XLL), VBA add-ins, Office Component Object Model (COM) add-ins, automation add-ins, VBA Editor (VBE), Visual Studio Tools for Office (VSTO) add-ins, and Outlook add-ins. (Citation: MRWLabs Office Persistence Add-ins)(Citation: FireEye Mail CDS 2018)\n\nAdd-ins can be used to obtain persistence because they can be set to execute code when an Office application starts.",
                    "description_jp": "攻撃者は、Microsoft Officeアドインを悪用して、侵害されたシステム上で永続性を獲得する可能性がある。Officeアドインは、Officeプログラムに機能を追加するために使用できる。(Word/Excelアドインライブラリ（WLL/XLL）、VBAアドイン、Officeコンポーネントオブジェクトモデル（COM）アドイン、オートメーションアドイン、VBAエディタ（VBE）、Visual Studio Tools for Office（VSTO）アドイン、Outlookアドインなどです。(引用：MRWLabs Office 永続アドイン）（引用：FireEye Mail CDS 2018）\n\nアドインは、Officeアプリケーションの起動時にコードを実行するように設定できるため、永続性を得るために使用できる。"
                },
                {
                    "id": "T1137.005",
                    "name_eng": "Outlook Rules",
                    "name_jp": "展望ルール",
                    "description_eng": "Adversaries may abuse Microsoft Outlook rules to obtain persistence on a compromised system. Outlook rules allow a user to define automated behavior to manage email messages. A benign rule might, for example, automatically move an email to a particular folder in Outlook if it contains specific words from a specific sender. Malicious Outlook rules can be created that can trigger code execution when an adversary sends a specifically crafted email to that user.(Citation: SilentBreak Outlook Rules)\n\nOnce malicious rules have been added to the user’s mailbox, they will be loaded when Outlook is started. Malicious rules will execute when an adversary sends a specifically crafted email to the user.(Citation: SilentBreak Outlook Rules)",
                    "description_jp": "攻撃者は、Microsoft Outlookのルールを悪用して、侵害されたシステム上で永続性を得る可能性がある。Outlookのルールにより、ユーザは電子メール・メッセージを管理するための自動化された動作を定義することができる。良性のルールは、例えば、特定の送信者からの特定の単語が含まれている場合、自動的にOutlookの特定のフォルダに電子メールを移動することができます。悪意のあるOutlookルールを作成することで、敵対者がそのユーザーに特別に細工した電子メールを送信したときに、コード実行をトリガーすることができます（引用：SilentBreak Outlook Rules）。\n\n悪意のあるルールがユーザーのメールボックスに追加されると、Outlookの起動時に読み込まれます。悪意のあるルールは、敵対者がそのユーザーに特別に細工した電子メールを送信したときに実行される(引用：SilentBreak Outlook Rules)"
                }
            ]
        },
        {
            "id": "T1053",
            "name_eng": "Scheduled Task/Job",
            "name_jp": "スケジュールされたタスク/ジョブ",
            "description_eng": "Adversaries may abuse task scheduling functionality to facilitate initial or recurring execution of malicious code. Utilities exist within all major operating systems to schedule programs or scripts to be executed at a specified date and time. A task can also be scheduled on a remote system, provided the proper authentication is met (ex: RPC and file and printer sharing in Windows environments). Scheduling a task on a remote system typically may require being a member of an admin or otherwise privileged group on the remote system.(Citation: TechNet Task Scheduler Security)\n\nAdversaries may use task scheduling to execute programs at system startup or on a scheduled basis for persistence. These mechanisms can also be abused to run a process under the context of a specified account (such as one with elevated permissions/privileges). Similar to [System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218), adversaries have also abused task scheduling to potentially mask one-time execution under a trusted system process.(Citation: ProofPoint Serpent)",
            "description_jp": "攻撃者は、タスク・スケジューリング機能を悪用し、悪意あるコードの初回実行や反復実行を容易にする可能性がある。すべての主要なオペレーティング・システムには、指定した日時に実行されるプログラムやスクリプトをスケジュールするユーティリティが存在する。タスクは、適切な認証（例：Windows環境におけるRPCとファイルとプリンタの共有）を満たせば、リモートシステム上でスケジュールすることもできる。リモートシステム上でタスクをスケジューリングするには、通常、リモートシステムの管理者またはその他の特権グループのメンバーである必要があります。\n\n攻撃者は、タスクスケジューリングを使って、システム起動時や、永続化のためにスケジュールされたベースでプログラムを実行することができる。これらのメカニズムは、指定されたアカウント(昇格した権限/特権を持つアカウントなど)のコンテキストでプロセスを実行するために悪用されることもあります。また、[System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218)と同様に、敵対者はタスクスケジューリングを悪用して、信頼されたシステムプロセスの下で1回限りの実行を隠蔽する可能性もある(引用：ProofPoint Serpent)。",
            "subtechniques": [
                {
                    "id": "T1053.003",
                    "name_eng": "Cron",
                    "name_jp": "クロン",
                    "description_eng": "Adversaries may abuse the <code>cron</code> utility to perform task scheduling for initial or recurring execution of malicious code.(Citation: 20 macOS Common Tools and Techniques) The <code>cron</code> utility is a time-based job scheduler for Unix-like operating systems.  The <code> crontab</code> file contains the schedule of cron entries to be run and the specified times for execution. Any <code>crontab</code> files are stored in operating system-specific file paths.\n\nAn adversary may use <code>cron</code> in Linux or Unix environments to execute programs at system startup or on a scheduled basis for [Persistence](https://attack.mitre.org/tactics/TA0003). In ESXi environments, cron jobs must be created directly via the crontab file (e.g., `/var/spool/cron/crontabs/root`).(Citation: CloudSEK ESXiArgs 2023)",
                    "description_jp": "攻撃者は<code>cron</code>ユーティリティを悪用して、悪意のあるコードを初回または繰り返し実行するためのタスクスケジューリングを行う可能性がある。(引用：20 macOS Common Tools and Techniques) <code>cron</code>ユーティリティは、Unix系OS向けの時間ベースのジョブスケジューラである。  <code> crontab</code> ファイルには、実行される cron エントリのスケジュールと、指定された実行時間が含まれています。<code>crontab</code> ファイルはオペレーティングシステム固有のファイルパスに格納される。\n\n敵対者は Linux または Unix 環境で <code>cron</code> を使用して、システム起動時または [Persistence](https://attack.mitre.org/tactics/TA0003) のスケジュールベースでプログラムを実行する可能性があります。ESXi環境では、cronジョブはcrontabファイル(例えば、`/var/spool/cron/crontabs/root`)を介して直接作成する必要があります(引用: CloudSEK ESXiArgs 2023)。"
                },
                {
                    "id": "T1053.005",
                    "name_eng": "Scheduled Task",
                    "name_jp": "予定タスク",
                    "description_eng": "Adversaries may abuse the Windows Task Scheduler to perform task scheduling for initial or recurring execution of malicious code. There are multiple ways to access the Task Scheduler in Windows. The [schtasks](https://attack.mitre.org/software/S0111) utility can be run directly on the command line, or the Task Scheduler can be opened through the GUI within the Administrator Tools section of the Control Panel.(Citation: Stack Overflow) In some cases, adversaries have used a .NET wrapper for the Windows Task Scheduler, and alternatively, adversaries have used the Windows netapi32 library and [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) (WMI) to create a scheduled task. Adversaries may also utilize the Powershell Cmdlet `Invoke-CimMethod`, which leverages WMI class `PS_ScheduledTask` to create a scheduled task via an XML path.(Citation: Red Canary - Atomic Red Team)\n\nAn adversary may use Windows Task Scheduler to execute programs at system startup or on a scheduled basis for persistence. The Windows Task Scheduler can also be abused to conduct remote Execution as part of Lateral Movement and/or to run a process under the context of a specified account (such as SYSTEM). Similar to [System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218), adversaries have also abused the Windows Task Scheduler to potentially mask one-time execution under signed/trusted system processes.(Citation: ProofPoint Serpent)\n\nAdversaries may also create \"hidden\" scheduled tasks (i.e. [Hide Artifacts](https://attack.mitre.org/techniques/T1564)) that may not be visible to defender tools and manual queries used to enumerate tasks. Specifically, an adversary may hide a task from `schtasks /query` and the Task Scheduler by deleting the associated Security Descriptor (SD) registry value (where deletion of this value must be completed using SYSTEM permissions).(Citation: SigmaHQ)(Citation: Tarrask scheduled task) Adversaries may also employ alternate methods to hide tasks, such as altering the metadata (e.g., `Index` value) within associated registry keys.(Citation: Defending Against Scheduled Task Attacks in Windows Environments)",
                    "description_jp": "攻撃者はWindowsタスクスケジューラを悪用し、悪意のあるコードを初回または繰り返し実行するためのタスクスケジューリングを実行する可能性がある。Windowsのタスクスケジューラーにアクセスする方法は複数ある。schtasks](https://attack.mitre.org/software/S0111)ユーティリティは、コマンドラインで直接実行することができ、タスクスケジューラは、コントロールパネルの管理者ツールセクション内のGUIを介して開くことができます(引用: Stack Overflow)いくつかのケースでは、敵対者は、Windowsタスクスケジューラのための.NETラッパーを使用しており、代わりに、敵対者は、スケジュールされたタスクを作成するためにWindows netapi32ライブラリと[Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047)(WMI)を使用しています。敵はまた、XMLパスを介してスケジュールされたタスクを作成するために、WMIクラス`PS_ScheduledTask`を活用するPowershell Cmdlet `Invoke-CimMethod`を利用するかもしれない(引用: Red Canary - Atomic Red Team)。\n\n敵対者は Windows タスク・スケジューラを使用して、システム起動時または永続化のためにスケジュールされたベース でプログラムを実行する可能性がある。Windows タスクスケジューラは、横移動の一部としてリモート実行を行ったり、指定されたアカウント(SYSTEM など)のコンテキスト下でプロセスを実行したりするために悪用される可能性もあります。System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218)と同様に、敵対者は Windows タスクスケジューラーを悪用して、署名された/信頼されたシステムプロセスの下で 1 回限りの実行をマスクする可能性もあります。\n\n敵対者はまた、防御ツールやタスクの列挙に使用される手動クエリには見えない「隠された」スケジュールタスク(すなわち[Hide Artifacts](https://attack.mitre.org/techniques/T1564))を作成する可能性があります。具体的には、敵は関連するセキュリティ記述子(SD)のレジストリ値を削除することで、`schtasks /query`とタスクスケジューラからタスクを隠すことができる(この値の削除はSYSTEM権限を使用して完了しなければならない)(引用：SigmaHQ)(引用：Tarraskスケジュールタスク) 敵はまた、関連するレジストリキー内のメタデータ(例えば、`Index`値)を変更するような、タスクを隠すための別の方法を採用することができる(引用：Defending Against Scheduled Task Attacks in Windows Environments)。"
                },
                {
                    "id": "T1053.006",
                    "name_eng": "Systemd Timers",
                    "name_jp": "Systemd タイマー",
                    "description_eng": "Adversaries may abuse systemd timers to perform task scheduling for initial or recurring execution of malicious code. Systemd timers are unit files with file extension <code>.timer</code> that control services. Timers can be set to run on a calendar event or after a time span relative to a starting point. They can be used as an alternative to [Cron](https://attack.mitre.org/techniques/T1053/003) in Linux environments.(Citation: archlinux Systemd Timers Aug 2020) Systemd timers may be activated remotely via the <code>systemctl</code> command line utility, which operates over [SSH](https://attack.mitre.org/techniques/T1021/004).(Citation: Systemd Remote Control)\n\nEach <code>.timer</code> file must have a corresponding <code>.service</code> file with the same name, e.g., <code>example.timer</code> and <code>example.service</code>. <code>.service</code> files are [Systemd Service](https://attack.mitre.org/techniques/T1543/002) unit files that are managed by the systemd system and service manager.(Citation: Linux man-pages: systemd January 2014) Privileged timers are written to <code>/etc/systemd/system/</code> and <code>/usr/lib/systemd/system</code> while user level are written to <code>~/.config/systemd/user/</code>.\n\nAn adversary may use systemd timers to execute malicious code at system startup or on a scheduled basis for persistence.(Citation: Arch Linux Package Systemd Compromise BleepingComputer 10JUL2018)(Citation: gist Arch package compromise 10JUL2018)(Citation: acroread package compromised Arch Linux Mail 8JUL2018) Timers installed using privileged paths may be used to maintain root level persistence. Adversaries may also install user level timers to achieve user level persistence.(Citation: Falcon Sandbox smp: 28553b3a9d)",
                    "description_jp": "攻撃者は systemd タイマーを悪用して、悪意のあるコードを初期または繰り返し実行するためのタスクスケジューリングを行う可能性があります。Systemd タイマーは <code>.timer</code> という拡張子を持つユニットファイルで、サービスを制御します。タイマーはカレンダーのイベントや、開始点からの相対的な時間経過後に実行されるように設定できます。Linux 環境では、[Cron](https://attack.mitre.org/techniques/T1053/003) の代替として使うことができます。(引用: archlinux Systemd Timers Aug 2020) Systemd タイマーは、[SSH](https://attack.mitre.org/techniques/T1021/004) 経由で動作する <code>systemctl</code> コマンドラインユーティリティを使ってリモートで起動することができます。(引用: Systemd Remote Control)\n\n各 <code>.timer</code> ファイルには、対応する同じ名前の <code>.service</code> ファイルが必要です。例えば、<code>example.timer</code> と <code>example.service</code> のようになります。<code>.service</code>ファイルは[Systemd Service](https://attack.mitre.org/techniques/T1543/002)ユニットファイルで、systemdシステムとサービスマネージャーによって管理されます。(引用: Linux man-pages: systemd January 2014) 特権タイマーは<code>/etc/systemd/system/</code>と<code>/usr/lib/systemd/system</code>に、ユーザーレベルは<code>~/.config/systemd/user/</code>に書き込まれます。\n\n敵対者は systemd タイマーを使ってシステム起動時やスケジュールベースで悪意のあるコードを実行し、永続化する可能性があります。(引用: Arch Linux Package Systemd Compromise BleepingComputer 10JUL2018)(Citation: gist Arch package compromise 10JUL2018)(Citation: acroread package compromised Arch Linux Mail 8JUL2018) 特権パスを使ってインストールされたタイマーはルートレベルの永続化を維持するために使われるかもしれません。攻撃者はまた、ユーザーレベルの持続性を達成するためにユーザーレベルのタイマーをインストールする可能性があります。(引用: Falcon Sandbox smp: 28553b3a9d)"
                },
                {
                    "id": "T1053.007",
                    "name_eng": "Container Orchestration Job",
                    "name_jp": "コンテナ・オーケストレーションジョブ",
                    "description_eng": "Adversaries may abuse task scheduling functionality provided by container orchestration tools such as Kubernetes to schedule deployment of containers configured to execute malicious code. Container orchestration jobs run these automated tasks at a specific date and time, similar to cron jobs on a Linux system. Deployments of this type can also be configured to maintain a quantity of containers over time, automating the process of maintaining persistence within a cluster.\n\nIn Kubernetes, a CronJob may be used to schedule a Job that runs one or more containers to perform specific tasks.(Citation: Kubernetes Jobs)(Citation: Kubernetes CronJob) An adversary therefore may utilize a CronJob to schedule deployment of a Job that executes malicious code in various nodes within a cluster.(Citation: Threat Matrix for Kubernetes)",
                    "description_jp": "攻撃者は、Kubernetesなどのコンテナオーケストレーションツールが提供するタスクスケジューリング機能を悪用して、悪意のあるコードを実行するように設定されたコンテナのデプロイをスケジュールする可能性があります。コンテナオーケストレーションジョブは、Linuxシステムのcronジョブと同様に、特定の日時にこれらの自動タスクを実行します。この種のデプロイは、長期にわたってコンテナの量を維持するように構成することもでき、クラスタ内の永続性を維持するプロセスを自動化することができます。\n\nKubernetesでは、CronJobは、特定のタスクを実行するために1つまたは複数のコンテナを実行するJobをスケジュールするために使用されることがあります（引用：Kubernetes Jobs）（引用：Kubernetes CronJob）したがって、敵対者は、クラスタ内のさまざまなノードで悪意のあるコードを実行するJobのデプロイをスケジュールするためにCronJobを利用する可能性があります（引用：Threat Matrix for Kubernetes）。"
                },
                {
                    "id": "T1053.002",
                    "name_eng": "At",
                    "name_jp": "At",
                    "description_eng": "Adversaries may abuse the [at](https://attack.mitre.org/software/S0110) utility to perform task scheduling for initial or recurring execution of malicious code. The [at](https://attack.mitre.org/software/S0110) utility exists as an executable within Windows, Linux, and macOS for scheduling tasks at a specified time and date. Although deprecated in favor of [Scheduled Task](https://attack.mitre.org/techniques/T1053/005)'s [schtasks](https://attack.mitre.org/software/S0111) in Windows environments, using [at](https://attack.mitre.org/software/S0110) requires that the Task Scheduler service be running, and the user to be logged on as a member of the local Administrators group. In addition to explicitly running the `at` command, adversaries may also schedule a task with [at](https://attack.mitre.org/software/S0110) by directly leveraging the [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) `Win32_ScheduledJob` WMI class.(Citation: Malicious Life by Cybereason)\n\nOn Linux and macOS, [at](https://attack.mitre.org/software/S0110) may be invoked by the superuser as well as any users added to the <code>at.allow</code> file. If the <code>at.allow</code> file does not exist, the <code>at.deny</code> file is checked. Every username not listed in <code>at.deny</code> is allowed to invoke [at](https://attack.mitre.org/software/S0110). If the <code>at.deny</code> exists and is empty, global use of [at](https://attack.mitre.org/software/S0110) is permitted. If neither file exists (which is often the baseline) only the superuser is allowed to use [at](https://attack.mitre.org/software/S0110).(Citation: Linux at)\n\nAdversaries may use [at](https://attack.mitre.org/software/S0110) to execute programs at system startup or on a scheduled basis for [Persistence](https://attack.mitre.org/tactics/TA0003). [at](https://attack.mitre.org/software/S0110) can also be abused to conduct remote [Execution](https://attack.mitre.org/tactics/TA0002) as part of [Lateral Movement](https://attack.mitre.org/tactics/TA0008) and/or to run a process under the context of a specified account (such as SYSTEM).\n\nIn Linux environments, adversaries may also abuse [at](https://attack.mitre.org/software/S0110) to break out of restricted environments by using a task to spawn an interactive system shell or to run system commands. Similarly, [at](https://attack.mitre.org/software/S0110) may also be used for [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) if the binary is allowed to run as superuser via <code>sudo</code>.(Citation: GTFObins at)",
                    "description_jp": "攻撃者は[at](https://attack.mitre.org/software/S0110)ユーティリティを悪用して、悪意のあるコードを初回または繰り返し実行するためのタスクスケジューリングを実行する可能性があります。at](https://attack.mitre.org/software/S0110)ユーティリティは、Windows、Linux、および macOS 内に実行可能ファイルとして存在し、指定した日時にタスクをスケジューリングします。Windows環境では[Scheduled Task](https://attack.mitre.org/techniques/T1053/005)の[schtasks](https://attack.mitre.org/software/S0111)に取って代わられ、非推奨となっていますが、[at](https://attack.mitre.org/software/S0110)を使用するには、タスクスケジューラサービスが起動しており、ユーザがローカルのAdministratorsグループのメンバーとしてログオンしている必要があります。明示的に `at` コマンドを実行するだけでなく、[Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) の `Win32_ScheduledJob` WMI クラスを直接利用して、[at](https://attack.mitre.org/software/S0110) でタスクをスケジュールすることもできる。(引用：Malicious Life by Cybereason)\n\nLinuxとmacOSでは、[at](https://attack.mitre.org/software/S0110)は<code>at.allow</code>ファイルに追加されたユーザーだけでなく、スーパーユーザーからも呼び出される可能性があります。<code>at.allow</code>ファイルが存在しない場合、<code>at.deny</code>ファイルがチェックされる。<code>at.deny</code>にリストされていないすべてのユーザー名は、[at](https://attack.mitre.org/software/S0110)の起動を許可される。<code>at.deny<//code>が存在し、空であれば、[at](https://attack.mitre.org/software/S0110)のグローバルな使用が許可される。どちらのファイルも存在しない場合(これがベースラインであることが多い)、スーパーユーザーだけが[at](https://attack.mitre.org/software/S0110)の使用を許可される。(引用: Linux at)\n\n攻撃者は[at](https://attack.mitre.org/software/S0110)を使用して、システム起動時または[Persistence](https://attack.mitre.org/tactics/TA0003)のスケジュールベースでプログラムを実行することができる。[at](https://attack.mitre.org/software/S0110)はまた、[Lateral Movement](https://attack.mitre.org/tactics/TA0008)の一部としてリモートで[Execution](https://attack.mitre.org/tactics/TA0002)を実行したり、指定されたアカウント(SYSTEMなど)のコンテキストでプロセスを実行するために悪用される可能性があります。\n\nLinux 環境では、タスクを使って対話的なシステムシェルを起動したり、システムコマンドを実行したりすることで、制限された環境から抜け出すために [at](https://attack.mitre.org/software/S0110) を悪用することもできる。同様に、[at](https://attack.mitre.org/software/S0110) は、バイナリが <code>sudo</code> 経由でスーパーユーザーとして実行されることが許可されている場合、[特権の昇格](https://attack.mitre.org/tactics/TA0004) にも使用される可能性がある。(引用: GTFObins at)"
                }
            ]
        },
        {
            "id": "T1176",
            "name_eng": "Software Extensions",
            "name_jp": "ソフトウェア拡張",
            "description_eng": "Adversaries may abuse software extensions to establish persistent access to victim systems. Software extensions are modular components that enhance or customize the functionality of software applications, including web browsers, Integrated Development Environments (IDEs), and other platforms.(Citation: Chrome Extension C2 Malware)(Citation: Abramovsky VSCode Security) Extensions are typically installed via official marketplaces, app stores, or manually loaded by users, and they often inherit the permissions and access levels of the host application. \n\n  \nMalicious extensions can be introduced through various methods, including social engineering, compromised marketplaces, or direct installation by users or by adversaries who have already gained access to a system. Malicious extensions can be named similarly or identically to benign extensions in marketplaces. Security mechanisms in extension marketplaces may be insufficient to detect malicious components, allowing adversaries to bypass automated scanners or exploit trust established during the installation process. Adversaries may also abuse benign extensions to achieve their objectives, such as using legitimate functionality to tunnel data or bypass security controls. \n\nThe modular nature of extensions and their integration with host applications make them an attractive target for adversaries seeking to exploit trusted software ecosystems. Detection can be challenging due to the inherent trust placed in extensions during installation and their ability to blend into normal application workflows.",
            "description_jp": "攻撃者は、ソフトウェア拡張機能を悪用して、被害者のシステムへの永続的なアクセスを確立する可能性があります。ソフトウェア拡張機能とは、ウェブブラウザ、統合開発環境（IDE）、その他のプラットフォームを含むソフトウェアアプリケーションの機能を拡張またはカスタマイズするモジュールコンポーネントです（引用：Chrome Extension C2 Malware）（引用：Abramovsky VSCode Security）拡張機能は通常、公式マーケットプレイスやアプリストア経由でインストールされるか、ユーザーによって手動でロードされます。\n\n  \n悪意のある拡張機能は、ソーシャルエンジニアリング、侵害されたマーケットプレイス、ユーザーによる直接のインストール、すでにシステムにアクセスした敵によるインストールなど、さまざまな方法で導入される可能性があります。悪意のある拡張は、マーケットプレイスにおける良性の拡張と類似した、あるいは同じような名前が付けられる。拡張機能マーケットプレイスのセキュリティメカニズムは、悪意のあるコンポーネントを検出するには不十分である可能性があり、敵対者は自動化されたスキャナを迂回したり、インストールプロセス中に確立された信頼を悪用したりすることができる。敵対者はまた、合法的な機能を使用してデータをトンネリングしたり、セキュリティ制御をバイパスしたりするなど、目的を達成するために良性の拡張機能を悪用する可能性もある。\n\n拡張機能のモジュール的な性質とホストアプリケーションとの統合は、信頼されたソフトウェアエコシステムを悪用しようとする敵対者にとって魅力的なターゲットとなる。インストール時にエクステンションに寄せられる固有の信頼と、通常のアプリケーションのワークフローに溶け込むエクステンションの能力により、検出は困難となる可能性がある。",
            "subtechniques": [
                {
                    "id": "T1176.002",
                    "name_eng": "IDE Extensions",
                    "name_jp": "IDE拡張機能",
                    "description_eng": "Adversaries may abuse an integrated development environment (IDE) extension to establish persistent access to victim systems.(Citation: Mnemonic misuse visual studio) IDEs such as Visual Studio Code, IntelliJ IDEA, and Eclipse support extensions - software components that add features like code linting, auto-completion, task automation, or integration with tools like Git and Docker. A malicious extension can be installed through an extension marketplace (i.e., [Compromise Software Dependencies and Development Tools](https://attack.mitre.org/techniques/T1195/001)) or side-loaded directly into the IDE.(Citation: Abramovsky VSCode Security)(Citation: Lakshmanan Visual Studio Marketplace)   \n\nIn addition to installing malicious extensions, adversaries may also leverage benign ones. For example, adversaries may establish persistent SSH tunnels via the use of the VSCode Remote SSH extension (i.e., [IDE Tunneling](https://attack.mitre.org/techniques/T1219/001)).  \n\nTrust is typically established through the installation process; once installed, the malicious extension is run every time that the IDE is launched. The extension can then be used to execute arbitrary code, establish a backdoor, mine cryptocurrency, or exfiltrate data.(Citation: ExtensionTotal VSCode Extensions  2025)",
                    "description_jp": "攻撃者は、統合開発環境（IDE）の拡張機能を悪用して、被害者のシステムへの永続的なアクセスを確立する可能性があります（引用：Mnemonic misuse visual studio）Visual Studio Code、IntelliJ IDEA、EclipseなどのIDEは、拡張機能（コードリンティング、自動補完、タスク自動化、GitやDockerなどのツールとの統合などの機能を追加するソフトウェアコンポーネント）をサポートしています。悪意のある拡張機能は、拡張機能マーケットプレイス（[Compromise Software Dependencies and Development Tools](https://attack.mitre.org/techniques/T1195/001)など）を通じてインストールしたり、IDEに直接サイドロードしたりすることができます（引用：Abramovsky VSCode Security）（引用：Lakshmanan Visual Studio Marketplace）。\n\n敵対者は、悪意のある拡張機能をインストールするだけでなく、良性の拡張機能を利用することもあります。例えば、敵対者は VSCode Remote SSH 拡張機能(すなわち、[IDE Tunneling](https://attack.mitre.org/techniques/T1219/001))を使用することで、持続的な SSH トンネルを確立することができます。  \n\n一度インストールされると、IDE を起動するたびに悪意のある拡張機能が実行されます。この拡張機能を使用して、任意のコードを実行したり、バックドアを設置したり、暗号通貨を採掘したり、データを流出させたりすることができます（引用：ExtensionTotal VSCode Extensions 2025）。"
                },
                {
                    "id": "T1176.001",
                    "name_eng": "Browser Extensions",
                    "name_jp": "ブラウザ拡張機能",
                    "description_eng": "Adversaries may abuse internet browser extensions to establish persistent access to victim systems. Browser extensions or plugins are small programs that can add functionality to and customize aspects of internet browsers. They can be installed directly via a local file or custom URL or through a browser's app store - an official online platform where users can browse, install, and manage extensions for a specific web browser. Extensions generally inherit the web browser's permissions previously granted.(Citation: Wikipedia Browser Extension)(Citation: Chrome Extensions Definition) \n \nMalicious extensions can be installed into a browser through malicious app store downloads masquerading as legitimate extensions, through social engineering, or by an adversary that has already compromised a system. Security can be limited on browser app stores, so it may not be difficult for malicious extensions to defeat automated scanners.(Citation: Malicious Chrome Extension Numbers) Depending on the browser, adversaries may also manipulate an extension's update url to install updates from an adversary-controlled server or manipulate the mobile configuration file to silently install additional extensions. \n  \nPrevious to macOS 11, adversaries could silently install browser extensions via the command line using the <code>profiles</code> tool to install malicious <code>.mobileconfig</code> files. In macOS 11+, the use of the <code>profiles</code> tool can no longer install configuration profiles; however, <code>.mobileconfig</code> files can be planted and installed with user interaction.(Citation: xorrior chrome extensions macOS) \n \nOnce the extension is installed, it can browse to websites in the background, steal all information that a user enters into a browser (including credentials), and be used as an installer for a RAT for persistence.(Citation: Chrome Extension Crypto Miner)(Citation: ICEBRG Chrome Extensions)(Citation: Banker Google Chrome Extension Steals Creds)(Citation: Catch All Chrome Extension) \n\nThere have also been instances of botnets using a persistent backdoor through malicious Chrome extensions for [Command and Control](https://attack.mitre.org/tactics/TA0011).(Citation: Stantinko Botnet)(Citation: Chrome Extension C2 Malware) Adversaries may also use browser extensions to modify browser permissions and components, privacy settings, and other security controls for [Defense Evasion](https://attack.mitre.org/tactics/TA0005).(Citation: Browers FriarFox)(Citation: Browser Adrozek)",
                    "description_jp": "攻撃者は、インターネットブラウザの拡張機能を悪用して、被害者のシステムへの永続的なアクセスを確立する可能性があります。ブラウザの拡張機能またはプラグインは、インターネットブラウザの機能を追加したりカスタマイズしたりするための小さなプログラムです。ローカルファイルやカスタムURLを介して直接インストールすることも、ブラウザのアプリストア（ユーザーが特定のウェブブラウザの拡張機能を閲覧、インストール、管理できる公式オンラインプラットフォーム）を介してインストールすることもできます。拡張機能は一般的に、以前に付与されたウェブブラウザの権限を継承する。 引用：Wikipedia ブラウザ拡張機能）（引用：Chrome 拡張機能の定義\n \n悪意のある拡張機能は、正規の拡張機能を装った悪意のあるアプリストアのダウンロード、ソーシャルエンジニアリング、またはすでにシステムに侵入している敵によって、ブラウザにインストールされる可能性があります。ブラウザのアプリストアのセキュリティは制限されている可能性があるため、悪意のある拡張機能が自動スキャナーを打ち負かすことは難しいことではありません。 (引用: 悪意のあるChrome拡張機能の数) ブラウザによっては、敵対者は拡張機能の更新URLを操作して、敵対者が管理するサーバーから更新をインストールしたり、モバイル設定ファイルを操作して、追加の拡張機能をサイレントインストールしたりする可能性もあります。\n  \nmacOS 11 より前のバージョンでは、悪意のある <code>.mobileconfig</code> ファイルをインストールする <code>profiles</code> ツールを使用して、コマンドライン経由でブラウザ拡張機能をサイレント インストールすることができました。macOS 11+ では、<code>profiles</code> ツールを使用してコンフィギュレーション・プロファイルをインストールすることはできなくなった。しかし、<code>.mobileconfig</code> ファイルは、ユーザーの操作によって植え付けられ、インストールされる。(引用：xorrior chrome extensions macOS)\n \n拡張機能がインストールされると、バックグラウンドでウェブサイトを閲覧し、ユーザーがブラウザに入力したすべての情報（認証情報を含む）を盗み出し、RATのインストーラーとして永続的に使用することができる(引用：Chrome Extension Crypto Miner)(引用：ICEBRG Chrome Extensions)(引用：Banker Google Chrome Extension Steals Creds)(引用：Catch All Chrome Extension)\n\nまた、ボットネットが[Command and Control](https://attack.mitre.org/tactics/TA0011)のために悪意のあるChrome拡張機能を介して永続的なバックドアを使用する例もあります。(引用: Stantinko Botnet)(Citation: Chrome Extension C2 Malware) 敵対者はまた、[Defense Evasion](https://attack.mitre.org/tactics/TA0005)のためにブラウザの権限やコンポーネント、プライバシー設定、その他のセキュリティ制御を変更するためにブラウザ拡張機能を使用することもあります。(引用: Browers FriarFox)(Citation: Browser Adrozek)"
                }
            ]
        },
        {
            "id": "T1205",
            "name_eng": "Traffic Signaling",
            "name_jp": "交通信号",
            "description_eng": "Adversaries may use traffic signaling to hide open ports or other malicious functionality used for persistence or command and control. Traffic signaling involves the use of a magic value or sequence that must be sent to a system to trigger a special response, such as opening a closed port or executing a malicious task. This may take the form of sending a series of packets with certain characteristics before a port will be opened that the adversary can use for command and control. Usually this series of packets consists of attempted connections to a predefined sequence of closed ports (i.e. [Port Knocking](https://attack.mitre.org/techniques/T1205/001)), but can involve unusual flags, specific strings, or other unique characteristics. After the sequence is completed, opening a port may be accomplished by the host-based firewall, but could also be implemented by custom software.\n\nAdversaries may also communicate with an already open port, but the service listening on that port will only respond to commands or trigger other malicious functionality if passed the appropriate magic value(s).\n\nThe observation of the signal packets to trigger the communication can be conducted through different methods. One means, originally implemented by Cd00r (Citation: Hartrell cd00r 2002), is to use the libpcap libraries to sniff for the packets in question. Another method leverages raw sockets, which enables the malware to use ports that are already open for use by other programs.\n\nOn network devices, adversaries may use crafted packets to enable [Network Device Authentication](https://attack.mitre.org/techniques/T1556/004) for standard services offered by the device such as telnet.  Such signaling may also be used to open a closed service port such as telnet, or to trigger module modification of malware implants on the device, adding, removing, or changing malicious capabilities.  Adversaries may use crafted packets to attempt to connect to one or more (open or closed) ports, but may also attempt to connect to a router interface, broadcast, and network address IP on the same port in order to achieve their goals and objectives.(Citation: Cisco Synful Knock Evolution)(Citation: Mandiant - Synful Knock)(Citation: Cisco Blog Legacy Device Attacks)  To enable this traffic signaling on embedded devices, adversaries must first achieve and leverage [Patch System Image](https://attack.mitre.org/techniques/T1601/001) due to the monolithic nature of the architecture.\n\nAdversaries may also use the Wake-on-LAN feature to turn on powered off systems. Wake-on-LAN is a hardware feature that allows a powered down system to be powered on, or woken up, by sending a magic packet to it. Once the system is powered on, it may become a target for lateral movement.(Citation: Bleeping Computer - Ryuk WoL)(Citation: AMD Magic Packet)",
            "description_jp": "攻撃者はトラフィック・シグナリングを使用して、オープン・ポートや、永続化やコマンド・アンド・コントロールに使用されるその他の悪意のある機能を隠すことができる。トラフィック・シグナリングには、閉じたポートを開いたり、悪意のあるタスクを実行したりするような特別な応答をトリガーするために、システムに送信しなければならないマジック値やシーケンスを使用することが含まれます。これは、敵がコマンド・アンド・コントロールに使用できるポートを開く前に、特定の特性を持つ一連のパケットを送信するという形を取ることがあります。通常、この一連のパケットは、事前に定義された一連のクローズドポートへの接続の試み（すなわち[ポートノッキング](https://attack.mitre.org/techniques/T1205/001)）から構成されるが、通常とは異なるフラグ、特定の文字列、または他のユニークな特徴を含むことができる。シーケンスが完了した後、ポートの開放はホストベースのファイアウォールによって達成されるかもしれないが、カスタムソフトウェアによって実装される可能性もある。\n\n攻撃者は既に開いているポートと通信することもできるが、そのポートをリッスンしているサービスは、適切なマジック値を渡された場合にのみ、コマンドに応答したり、他の悪意のある機能を起動したりする。\n\n通信のトリガーとなるシグナルパケットの観測は、様々な方法で行うことができる。一つは、Cd00r（引用：Hartrell cd00r 2002）によって実装されたもので、libpcapライブラリを使用して問題のパケットをスニッフする方法である。もう1つの方法は生ソケットを利用するもので、これによりマルウェアは、他のプログラムが使用するためにすでに開いているポートを使用することができる。\n\nネットワーク・デバイスの場合、敵は細工したパケットを使って、telnetなどデバイスが提供する標準的なサービスの[Network Device Authentication](https://attack.mitre.org/techniques/T1556/004)を有効にすることがあります。  このようなシグナリングは、telnet などの閉じたサービス・ポートを開くため、またはデバイス上のマルウェアのインプラントのモジュール修正をトリガーし、悪意のある機能を追加、削除、または変更するためにも使用される可能性があります。  攻撃者は、細工したパケットを使用して、1つ以上の（オープンまたはクローズされた）ポートへの接続を試みますが、目的や目標を達成するために、同じポート上のルータインターフェース、ブロードキャスト、ネットワークアドレス IP への接続を試みることもあります。(引用：Cisco Synful Knock Evolution)(引用：Mandiant - Synful Knock)(引用：Cisco Blog Legacy Device Attacks) 組み込みデバイス上でこのトラフィックシグナリングを有効にするには、アーキテクチャがモノリシックであるため、敵対者はまず[Patch System Image](https://attack.mitre.org/techniques/T1601/001)を達成し、活用する必要があります。\n\n敵はまた、電源の切れたシステムをオンにするために Wake-on-LAN 機能を使うかもしれません。Wake-on-LAN はハードウェアの機能で、電源が落ちているシステムにマジックパケットを送ることで、電源を入れたり、起動させたりすることができます。一度電源が入ったシステムは、横移動の標的になる可能性がある。 (引用：Bleeping Computer - Ryuk WoL)(Citation: AMD Magic Packet)",
            "subtechniques": [
                {
                    "id": "T1205.001",
                    "name_eng": "Port Knocking",
                    "name_jp": "ポートノッキング",
                    "description_eng": "Adversaries may use port knocking to hide open ports used for persistence or command and control. To enable a port, an adversary sends a series of attempted connections to a predefined sequence of closed ports. After the sequence is completed, opening a port is often accomplished by the host based firewall, but could also be implemented by custom software.\n\nThis technique has been observed both for the dynamic opening of a listening port as well as the initiating of a connection to a listening server on a different system.\n\nThe observation of the signal packets to trigger the communication can be conducted through different methods. One means, originally implemented by Cd00r (Citation: Hartrell cd00r 2002), is to use the libpcap libraries to sniff for the packets in question. Another method leverages raw sockets, which enables the malware to use ports that are already open for use by other programs.",
                    "description_jp": "攻撃者は、ポート・ノッキングを使用して、永続化またはコマンド・アンド・コントロールに使用されるオープン・ポートを隠すことができる。ポートを有効にするために、敵はあらかじめ定義された一連のクローズド・ポートに一連の接続試行を送信します。このシーケンスが完了した後、ポートの開放は多くの場合ホストベースのファイアウォールによって達成されますが、カスタムソフトウェアによって実装されることもあります。\n\nこのテクニックは、リッスンしているポートの動的な開放と、別のシステム上のリッスンしているサーバへの接続の開始の両方で観察されている。\n\n通信のトリガーとなるシグナルパケットの観測は、さまざまな方法で行うことができる。一つは、Cd00r（引用：Hartrell cd00r 2002）によって実装されたもので、libpcapライブラリを使用して問題のパケットをスニッフする方法である。もう1つの方法は生ソケットを利用するもので、これによりマルウェアは、他のプログラムが使用するためにすでに開いているポートを使用することができる。"
                },
                {
                    "id": "T1205.002",
                    "name_eng": "Socket Filters",
                    "name_jp": "ソケットフィルター",
                    "description_eng": "Adversaries may attach filters to a network socket to monitor then activate backdoors used for persistence or command and control. With elevated permissions, adversaries can use features such as the `libpcap` library to open sockets and install filters to allow or disallow certain types of data to come through the socket. The filter may apply to all traffic passing through the specified network interface (or every interface if not specified). When the network interface receives a packet matching the filter criteria, additional actions can be triggered on the host, such as activation of a reverse shell.\n\nTo establish a connection, an adversary sends a crafted packet to the targeted host that matches the installed filter criteria.(Citation: haking9 libpcap network sniffing) Adversaries have used these socket filters to trigger the installation of implants, conduct ping backs, and to invoke command shells. Communication with these socket filters may also be used in conjunction with [Protocol Tunneling](https://attack.mitre.org/techniques/T1572).(Citation: exatrack bpf filters passive backdoors)(Citation: Leonardo Turla Penquin May 2020)\n\nFilters can be installed on any Unix-like platform with `libpcap` installed or on Windows hosts using `Winpcap`.  Adversaries may use either `libpcap` with `pcap_setfilter` or the standard library function `setsockopt` with `SO_ATTACH_FILTER` options. Since the socket connection is not active until the packet is received, this behavior may be difficult to detect due to the lack of activity on a host, low CPU overhead, and limited visibility into raw socket usage.",
                    "description_jp": "敵はネットワークソケットにフィルタを取り付けて監視し、永続化やコマンド＆コントロールに使われるバックドアを起動することができる。高いパーミッションがあれば、敵は `libpcap` ライブラリのような機能を使ってソケットを開き、特定のタイプのデータがソケットを通過するのを許可したり、許可しなかったりするフィルタをインストールすることができる。フィルタは、指定されたネットワークインターフェース（指定されていない場合はすべてのインターフェース）を通過するすべてのトラフィックに適用される。ネットワークインターフェイスがフィルター条件にマッチするパケットを受信すると、ホスト上でリバースシェルの起動などの追加アクションをトリガーすることができる。\n\n接続を確立するために、敵はインストールされたフィルタ条件に一致する細工されたパケットをターゲットホストに送信する(引用: haking9 libpcap network sniffing)。これらのソケットフィルタによる通信は、[Protocol Tunneling](https://attack.mitre.org/techniques/T1572)と組み合わせて使用されることもあります。(引用：exatrack bpf filters passive backdoors)(Citation: Leonardo Turla Penquin May 2020)\n\nフィルタは `libpcap` がインストールされている Unix 系プラットフォーム、または `Winpcap` を使用している Windows ホストにインストールすることができる。  攻撃者は `pcap_setfilter` オプションを持つ `libpcap` か、`SO_ATTACH_FILTER` オプションを持つ標準ライブラリ関数 `setsockopt` を使用する。ソケット接続はパケットを受信するまでアクティブにならないので、ホスト上のアクティビティが少ないこと、CPU オーバーヘッドが少ないこと、生のソケットの使用状況が限定的であることから、この振る舞いを検出するのは難しいかもしれない。"
                }
            ]
        },
        {
            "id": "T1525",
            "name_eng": "Implant Internal Image",
            "name_jp": "インプラント内部画像",
            "description_eng": "Adversaries may implant cloud or container images with malicious code to establish persistence after gaining access to an environment. Amazon Web Services (AWS) Amazon Machine Images (AMIs), Google Cloud Platform (GCP) Images, and Azure Images as well as popular container runtimes such as Docker can be implanted or backdoored. Unlike [Upload Malware](https://attack.mitre.org/techniques/T1608/001), this technique focuses on adversaries implanting an image in a registry within a victim’s environment. Depending on how the infrastructure is provisioned, this could provide persistent access if the infrastructure provisioning tool is instructed to always use the latest image.(Citation: Rhino Labs Cloud Image Backdoor Technique Sept 2019)\n\nA tool has been developed to facilitate planting backdoors in cloud container images.(Citation: Rhino Labs Cloud Backdoor September 2019) If an adversary has access to a compromised AWS instance, and permissions to list the available container images, they may implant a backdoor such as a [Web Shell](https://attack.mitre.org/techniques/T1505/003).(Citation: Rhino Labs Cloud Image Backdoor Technique Sept 2019)",
            "description_jp": "攻撃者は、クラウドやコンテナのイメージに悪意のあるコードを埋め込み、環境にアクセスした後に永続性を確立する可能性があります。Amazon Web Services (AWS)のAmazon Machine Images (AMI)、Google Cloud Platform (GCP)のImage、AzureのImage、そしてDockerのような一般的なコンテナランタイムが移植またはバックドアされる可能性があります。Upload Malware](https://attack.mitre.org/techniques/T1608/001)とは異なり、このテクニックは、敵対者が被害者の環境内のレジストリにイメージを埋め込むことに焦点を当てています。インフラストラクチャのプロビジョニング方法によっては、インフラストラクチャのプロビジョニングツールが常に最新のイメージを使用するように指示されている場合、持続的なアクセスを提供する可能性があります(引用: Rhino Labs Cloud Image Backdoor Technique Sept 2019)\n\nクラウドコンテナイメージにバックドアを仕込むことを容易にするツールが開発されている。(引用：Rhino Labs Cloud Backdoor September 2019) 敵が侵害されたAWSインスタンスにアクセスし、利用可能なコンテナイメージをリストアップする権限を持っていれば、[Web Shell](https://attack.mitre.org/techniques/T1505/003)のようなバックドアを埋め込むことができる。(引用：Rhino Labs Cloud Image Backdoor Technique Sept 2019)",
            "subtechniques": []
        },
        {
            "id": "T1112",
            "name_eng": "Modify Registry",
            "name_jp": "レジストリの変更",
            "description_eng": "Adversaries may interact with the Windows Registry as part of a variety of other techniques to aid in defense evasion, persistence, and execution.\n\nAccess to specific areas of the Registry depends on account permissions, with some keys requiring administrator-level access. The built-in Windows command-line utility [Reg](https://attack.mitre.org/software/S0075) may be used for local or remote Registry modification.(Citation: Microsoft Reg) Other tools, such as remote access tools, may also contain functionality to interact with the Registry through the Windows API.\n\nThe Registry may be modified in order to hide configuration information or malicious payloads via [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027).(Citation: Unit42 BabyShark Feb 2019)(Citation: Avaddon Ransomware 2021)(Citation: Microsoft BlackCat Jun 2022)(Citation: CISA Russian Gov Critical Infra 2018) The Registry may also be modified to [Impair Defenses](https://attack.mitre.org/techniques/T1562), such as by enabling macros for all Microsoft Office products, allowing privilege escalation without alerting the user, increasing the maximum number of allowed outbound requests, and/or modifying systems to store plaintext credentials in memory.(Citation: CISA LockBit 2023)(Citation: Unit42 BabyShark Feb 2019)\n\nThe Registry of a remote system may be modified to aid in execution of files as part of lateral movement. It requires the remote Registry service to be running on the target system.(Citation: Microsoft Remote) Often [Valid Accounts](https://attack.mitre.org/techniques/T1078) are required, along with access to the remote system's [SMB/Windows Admin Shares](https://attack.mitre.org/techniques/T1021/002) for RPC communication.\n\nFinally, Registry modifications may also include actions to hide keys, such as prepending key names with a null character, which will cause an error and/or be ignored when read via [Reg](https://attack.mitre.org/software/S0075) or other utilities using the Win32 API.(Citation: Microsoft Reghide NOV 2006) Adversaries may abuse these pseudo-hidden keys to conceal payloads/commands used to maintain persistence.(Citation: TrendMicro POWELIKS AUG 2014)(Citation: SpectorOps Hiding Reg Jul 2017)",
            "description_jp": "攻撃者は、防御の回避、永続性、実行を支援する他の様々なテクニックの一部として、Windowsレジストリと相互作用する可能性がある。\n\nレジストリの特定の領域へのアクセスはアカウント権限に依存し、いくつかのキーは管理者レベルのアクセスを必要とする。Windows内蔵のコマンドラインユーティリティ[Reg](https://attack.mitre.org/software/S0075)は、ローカルまたはリモートのレジストリ変更に使用することができる。(引用: Microsoft Reg) リモートアクセスツールのような他のツールも、Windows APIを通じてレジストリと対話する機能を含んでいるかもしれない。\n\nレジストリは、[難読化されたファイルまたは情報](https://attack.mitre.org/techniques/T1027) を介して設定情報や悪意のあるペイロードを隠すために変更される可能性があります。(引用: Unit42 BabyShark Feb 2019)(引用: Avaddon Ransomware 2021)(引用: Microsoft BlackCat Jun 2022)(引用: CISA Russian Gov Critical Infra 2018) レジストリはまた、[防御を損なう](https://attack.mitre.org/techniques/T1562)、例えば、すべての Microsoft Office 製品でマクロを有効にする、ユーザーに警告することなく特権の昇格を許可する、許可される送信リクエストの最大数を増やす、および/または平文の資格情報をメモリに保存するようにシステムを変更する、などである(引用: CISA LockBit 2023年)(引用: Unit42 BabyShark Feb 2019年)\n\nリモートシステムのレジストリは、横移動の一環としてファイルの実行を支援するために変更される可能性があります。(引用: Microsoft Remote) 多くの場合、[有効なアカウント](https://attack.mitre.org/techniques/T1078) が、RPC 通信のためのリモートシステムの [SMB/Windows 管理者共有](https://attack.mitre.org/techniques/T1021/002) へのアクセスとともに必要とされます。\n\n最後に、レジストリの修正には、キー名をヌル文字で前置するなどのキーを隠す動作も含まれる場合があります。このようなキーは、[Reg](https://attack.mitre.org/software/S0075)またはWin32 APIを使用する他のユーティリティを介して読み取られたときにエラーを引き起こし、無視されます。(引用: Microsoft Reghide NOV 2006) 敵対者は、永続性を維持するために使用されるペイロード/コマンドを隠すために、このような疑似隠しキーを悪用する可能性があります。(引用: TrendMicro POWELIKS AUG 2014)(Citation: SpectorOps Hiding Reg Jul 2017)",
            "subtechniques": []
        },
        {
            "id": "T1542",
            "name_eng": "Pre-OS Boot",
            "name_jp": "OSブート前",
            "description_eng": "Adversaries may abuse Pre-OS Boot mechanisms as a way to establish persistence on a system. During the booting process of a computer, firmware and various startup services are loaded before the operating system. These programs control flow of execution before the operating system takes control.(Citation: Wikipedia Booting)\n\nAdversaries may overwrite data in boot drivers or firmware such as BIOS (Basic Input/Output System) and The Unified Extensible Firmware Interface (UEFI) to persist on systems at a layer below the operating system. This can be particularly difficult to detect as malware at this level will not be detected by host software-based defenses.",
            "description_jp": "攻撃者は、システムの永続性を確立する方法として、プレOSブートメカニズムを悪用する可能性がある。コンピュータの起動プロセスでは、ファームウェアと様々なスタートアップサービスがオペレーティング・システムの前にロードされる。これらのプログラムは、オペレーティングシステムが制御を開始する前に実行の流れを制御する。 引用：Wikipedia ブート)\n\n攻撃者は、BIOS (Basic Input/Output System)やUEFI (The Unified Extensible Firmware Interface)のようなブートドライバやファームウェアのデータを上書きし、オペレーティングシステムより下のレイヤーのシステム上で持続させる可能性がある。このレベルのマルウェアは、ホスト・ソフトウェア・ベースの防御では検出されないため、検出が特に困難になる可能性があります。",
            "subtechniques": [
                {
                    "id": "T1542.003",
                    "name_eng": "Bootkit",
                    "name_jp": "ブートキット",
                    "description_eng": "Adversaries may use bootkits to persist on systems. A bootkit is a malware variant that modifies the boot sectors of a hard drive, allowing malicious code to execute before a computer's operating system has loaded. Bootkits reside at a layer below the operating system and may make it difficult to perform full remediation unless an organization suspects one was used and can act accordingly.\n\nIn BIOS systems, a bootkit may modify the Master Boot Record (MBR) and/or Volume Boot Record (VBR).(Citation: Mandiant M Trends 2016) The MBR is the section of disk that is first loaded after completing hardware initialization by the BIOS. It is the location of the boot loader. An adversary who has raw access to the boot drive may overwrite this area, diverting execution during startup from the normal boot loader to adversary code.(Citation: Lau 2011)\n\nThe MBR passes control of the boot process to the VBR. Similar to the case of MBR, an adversary who has raw access to the boot drive may overwrite the VBR to divert execution during startup to adversary code.\n\nIn UEFI (Unified Extensible Firmware Interface) systems, a bootkit may instead create or modify files in the EFI system partition (ESP). The ESP is a partition on data storage used by devices containing UEFI that allows the system to boot the OS and other utilities used by the system. An adversary can use the newly created or patched files in the ESP to run malicious kernel code.(Citation: Microsoft Security)(Citation: welivesecurity)",
                    "description_jp": "攻撃者は、ブートキットを使用してシステムに潜伏する可能性があります。ブートキットは、ハードドライブのブートセクタを変更し、コンピュータのオペレーティングシステムがロードされる前に悪意のあるコードを実行できるようにするマルウェアの亜種です。ブートキットはオペレーティング・システムの下のレイヤーに存在するため、組織がブートキットの使用を疑って適切な対処を行わない限り、完全な修復を行うことは困難です。\n\nBIOSシステムでは、ブートキットはマスターブートレコード（MBR）やボリュームブートレコード（VBR）を変更する可能性があります（引用：Mandiant M Trends 2016）。ブートローダーの場所です。ブートドライブへの未加工アクセス権を持つ敵対者は、この領域を上書きし、起動中の実行を通常のブートローダーから敵対コードに転換することができる(引用: Lau 2011)。\n\nMBR はブート・プロセスの制御を VBR に渡します。MBRの場合と同様に、ブート・ドライブに生アクセスできる敵は、起動中の実行を敵のコードに迂回させるために、VBRを上書きする可能性があります。\n\nUEFI (Unified Extensible Firmware Interface)システムでは、ブートキットは代わりにEFIシステムパーティション(ESP)にファイルを作成したり変更したりするかもしれません。ESP は UEFI を含むデバイスで使われるデータストレージ上のパーティションで、システムが OS やシステムで使われる他のユーティリティをブートすることを可能にします。敵対者は、ESP内に新たに作成されたファイルやパッチを適用したファイルを使用して、悪意のあるカーネルコードを実行することができる。 引用：Microsoft Security）（ 引用：welivesecurity"
                },
                {
                    "id": "T1542.005",
                    "name_eng": "TFTP Boot",
                    "name_jp": "TFTPブート",
                    "description_eng": "Adversaries may abuse netbooting to load an unauthorized network device operating system from a Trivial File Transfer Protocol (TFTP) server. TFTP boot (netbooting) is commonly used by network administrators to load configuration-controlled network device images from a centralized management server. Netbooting is one option in the boot sequence and can be used to centralize, manage, and control device images.\n\nAdversaries may manipulate the configuration on the network device specifying use of a malicious TFTP server, which may be used in conjunction with [Modify System Image](https://attack.mitre.org/techniques/T1601) to load a modified image on device startup or reset. The unauthorized image allows adversaries to modify device configuration, add malicious capabilities to the device, and introduce backdoors to maintain control of the network device while minimizing detection through use of a standard functionality. This technique is similar to [ROMMONkit](https://attack.mitre.org/techniques/T1542/004) and may result in the network device running a modified image. (Citation: Cisco Blog Legacy Device Attacks)",
                    "description_jp": "攻撃者はネットブートを悪用して、TFTP（Trivial File Transfer Protocol）サーバーから不正なネットワークデバイスのオペレーティングシステムをロードする可能性があります。TFTP ブート（ネットブート）は、ネットワーク管理者が集中管理サーバーから設定管理されたネットワークデバイスイメージをロードするために一般的に使用されます。ネットブートは、ブートシーケンスの1つのオプションであり、デバイスイメージを集中管理、管理、制御するために使用できます。\n\n悪意のある TFTP サーバーは、[Modify System Image](https://attack.mitre.org/techniques/T1601)と併用することで、デバイスの起動時やリセット時に変更されたイメージをロードすることができます。この不正なイメージによって、敵はデバイスの設定を変更したり、デバイスに悪意のある機能を追加したり、バックドアを導入したりすることができます。この手法は、[ROMMONkit](https://attack.mitre.org/techniques/T1542/004) に類似しており、ネットワークデバイスが変更されたイメージを実行する可能性があります。(引用: Cisco Blog Legacy Device Attacks)"
                },
                {
                    "id": "T1542.002",
                    "name_eng": "Component Firmware",
                    "name_jp": "コンポーネント・ファームウェア",
                    "description_eng": "Adversaries may modify component firmware to persist on systems. Some adversaries may employ sophisticated means to compromise computer components and install malicious firmware that will execute adversary code outside of the operating system and main system firmware or BIOS. This technique may be similar to [System Firmware](https://attack.mitre.org/techniques/T1542/001) but conducted upon other system components/devices that may not have the same capability or level of integrity checking.\n\nMalicious component firmware could provide both a persistent level of access to systems despite potential typical failures to maintain access and hard disk re-images, as well as a way to evade host software-based defenses and integrity checks.",
                    "description_jp": "敵対者は、システム上で存続するために、コンポーネントのファームウェアを修正するかもしれない。一部の敵対者は、コンピュータ・コンポーネントを侵害し、オペレーティング・システムやメ イン・システムのファームウェアや BIOS の外側で敵対者のコードを実行する、悪意のあるファームウェアをインス トールするために、洗練された手段を採用するかもしれない。このテクニックは、[システム・ファームウェア](https://attack.mitre.org/techniques/T1542/001)に類似しているかもしれないが、同じ能力や完全性チェックのレベルを持たないかもしれない、他のシステム・コンポーネント／デバイスに対して実施される。\n\n悪意のあるコンポーネント・ファームウェアは、アクセスを維持するための典型的な失敗やハードディスク の再イメージの可能性があるにもかかわらず、システムへの永続的なアクセス・レベルを提供し、また、ホス ト・ソフトウェア・ベースの防御や完全性チェックを回避する方法を提供する可能性がある。"
                },
                {
                    "id": "T1542.004",
                    "name_eng": "ROMMONkit",
                    "name_jp": "ロモンキット",
                    "description_eng": "Adversaries may abuse the ROM Monitor (ROMMON) by loading an unauthorized firmware with adversary code to provide persistent access and manipulate device behavior that is difficult to detect. (Citation: Cisco Synful Knock Evolution)(Citation: Cisco Blog Legacy Device Attacks)\n\n\nROMMON is a Cisco network device firmware that functions as a boot loader, boot image, or boot helper to initialize hardware and software when the platform is powered on or reset. Similar to [TFTP Boot](https://attack.mitre.org/techniques/T1542/005), an adversary may upgrade the ROMMON image locally or remotely (for example, through TFTP) with adversary code and restart the device in order to overwrite the existing ROMMON image. This provides adversaries with the means to update the ROMMON to gain persistence on a system in a way that may be difficult to detect.",
                    "description_jp": "敵対者は、検出が困難な永続的なアクセスを提供し、デバイスの動作を操作するために、敵対者のコードで不正なファームウェアをロードすることにより、ROM Monitor (ROMMON)を悪用する可能性がある。(引用：Cisco Synful Knock Evolution） （引用：Cisco Blog Legacy Device Attacks）\n\n\nROMMON は、ブートローダー、ブートイメージ、またはブートヘルパーとして機能する Cisco ネットワークデバイスのファームウェアであり、プラットフォームの電源投入時やリセット時に、ハードウェアとソフトウェアを初期化する。TFTP Boot](https://attack.mitre.org/techniques/T1542/005)と同様に、敵対者は、既存の ROMMON イメージを上書きするために、ローカルまたはリモート（例えば TFTP 経由）で ROMMON イメージを敵対コードでアップグレードし、デバイスを再起動することができる。これにより、敵対者は、検出が困難な方法で ROMMON を更新し、システム上で永続性を得ることができます。"
                },
                {
                    "id": "T1542.001",
                    "name_eng": "System Firmware",
                    "name_jp": "システムファームウェア",
                    "description_eng": "Adversaries may modify system firmware to persist on systems.The BIOS (Basic Input/Output System) and The Unified Extensible Firmware Interface (UEFI) or Extensible Firmware Interface (EFI) are examples of system firmware that operate as the software interface between the operating system and hardware of a computer.(Citation: Wikipedia BIOS)(Citation: Wikipedia UEFI)(Citation: About UEFI)\n\nSystem firmware like BIOS and (U)EFI underly the functionality of a computer and may be modified by an adversary to perform or assist in malicious activity. Capabilities exist to overwrite the system firmware, which may give sophisticated adversaries a means to install malicious firmware updates as a means of persistence on a system that may be difficult to detect.",
                    "description_jp": "BIOS（基本入出力システム）やUEFI（Unified Extensible Firmware Interface）またはEFI（Extensible Firmware Interface）は、オペレーティングシステムとコンピュータのハードウェアの間のソフトウェアインターフェイスとして動作するシステムファームウェアの例である（引用：Wikipedia BIOS）（引用：Wikipedia UEFI）（引用：UEFIについて）\n\nBIOSや(U)EFIのようなシステムファームウェアはコンピュータの機能の根底にあり、敵対者によって悪意のある活動を実行または支援するために変更される可能性がある。システム・ファームウェアを上書きする機能が存在するため、巧妙な敵対者は、検出が困難なシステム上に永続的な手段として、悪意のあるファームウェア・アップデートをインストールする手段を与える可能性がある。"
                }
            ]
        },
        {
            "id": "T1554",
            "name_eng": "Compromise Host Software Binary",
            "name_jp": "ホストソフトウェアのバイナリ侵害",
            "description_eng": "Adversaries may modify host software binaries to establish persistent access to systems. Software binaries/executables provide a wide range of system commands or services, programs, and libraries. Common software binaries are SSH clients, FTP clients, email clients, web browsers, and many other user or server applications.\n\nAdversaries may establish persistence though modifications to host software binaries. For example, an adversary may replace or otherwise infect a legitimate application binary (or support files) with a backdoor. Since these binaries may be routinely executed by applications or the user, the adversary can leverage this for persistent access to the host. An adversary may also modify a software binary such as an SSH client in order to persistently collect credentials during logins (i.e., [Modify Authentication Process](https://attack.mitre.org/techniques/T1556)).(Citation: Google Cloud Mandiant UNC3886 2024)\n\nAn adversary may also modify an existing binary by patching in malicious functionality (e.g., IAT Hooking/Entry point patching)(Citation: Unit42 Banking Trojans Hooking 2022) prior to the binary’s legitimate execution. For example, an adversary may modify the entry point of a binary to point to malicious code patched in by the adversary before resuming normal execution flow.(Citation: ESET FontOnLake Analysis 2021)\n\nAfter modifying a binary, an adversary may attempt to [Impair Defenses](https://attack.mitre.org/techniques/T1562) by preventing it from updating (e.g., via the `yum-versionlock` command or `versionlock.list` file in Linux systems that use the yum package manager).(Citation: Google Cloud Mandiant UNC3886 2024)",
            "description_jp": "攻撃者は、ホストソフトウェアバイナリを変更して、システムへの永続的なアクセスを確立する可能性がある。ソフトウェアバイナリ/実行可能ファイルは、幅広いシステムコマンドやサービス、プログラム、ライブラリを提供します。一般的なソフトウェアバイナリは、SSHクライアント、FTPクライアント、電子メールクライアント、ウェブブラウザ、その他多くのユーザまたはサーバアプリケーションです。\n\n攻撃者は、ホストソフトウェアバイナリを変更することで永続性を確立することができる。例えば、攻撃者は、正規のアプリケーションバイナリ（またはサポートファイル）をバックドアに置き換えたり、感染させたりします。これらのバイナリはアプリケーションやユーザによって日常的に実行される可能性があるため、敵対者はこれを利用してホストに永続的にアクセスすることができます。敵対者はまた、ログイン中に認証情報を持続的に収集するために、SSH クライアントのようなソフトウェアバイナリを変更する可能性があります（すなわち、[Modify Authentication Process](https://attack.mitre.org/techniques/T1556)）。(引用：Google Cloud Mandiant UNC3886 2024)\n\n敵対者はまた、バイナリの正当な実行の前に、悪意のある機能（例えば、IAT Hooking/Entry point patching）（引用：Unit42 Banking Trojans Hooking 2022）をパッチすることによって、既存のバイナリを変更する可能性がある。例えば、敵対者は、バイナリのエントリーポイントを変更し、通常の実行フローを再開する前に、敵対者がパッチを適用した悪意のあるコードを指すようにすることができる(引用：ESET FontOnLake Analysis 2021)。\n\nバイナリを修正した後、敵対者はバイナリの更新を（yum パッケージマネージャを使用する Linux システムでは、`yum-versionlock` コマンドまたは `versionlock.list` ファイルを介して）阻止することで、[防御の障害](https://attack.mitre.org/techniques/T1562) を試みる可能性があります(引用: Google Cloud Mandiant UNC3886 2024)。",
            "subtechniques": []
        },
        {
            "id": "T1098",
            "name_eng": "Account Manipulation",
            "name_jp": "口座操作",
            "description_eng": "Adversaries may manipulate accounts to maintain and/or elevate access to victim systems. Account manipulation may consist of any action that preserves or modifies adversary access to a compromised account, such as modifying credentials or permission groups.(Citation: FireEye SMOKEDHAM June 2021) These actions could also include account activity designed to subvert security policies, such as performing iterative password updates to bypass password duration policies and preserve the life of compromised credentials. \n\nIn order to create or manipulate accounts, the adversary must already have sufficient permissions on systems or the domain. However, account manipulation may also lead to privilege escalation where modifications grant access to additional roles, permissions, or higher-privileged [Valid Accounts](https://attack.mitre.org/techniques/T1078).",
            "description_jp": "攻撃者は、被害者システムへのアクセスを維持及び/又は昇格させるために、アカウントを操作する可能性がある。アカウント操作は、認証情報や権限グループの変更など、侵害されたアカウントへの敵対者のアクセスを維持または変更するあらゆる行為で構成される可能性がある（引用：FireEye SMOKEDHAM June 2021）。これらの行為には、パスワードの有効期間ポリシーを回避し、侵害された認証情報の有効期間を維持するための反復的なパスワード更新の実行など、セキュリティポリシーを破壊するように設計されたアカウント活動も含まれる可能性がある。\n\nアカウントを作成または操作するためには、敵対者はシステムまたはドメインに対して既に十分な権限を持ってい なければならない。しかし、アカウント操作は、変更が追加の役割、権限、またはより高い特権[Valid Accounts](https://attack.mitre.org/techniques/T1078)へのアクセスを許可する特権の昇格につながる可能性もある。",
            "subtechniques": [
                {
                    "id": "T1098.001",
                    "name_eng": "Additional Cloud Credentials",
                    "name_jp": "追加のクラウド・クレデンシャル",
                    "description_eng": "Adversaries may add adversary-controlled credentials to a cloud account to maintain persistent access to victim accounts and instances within the environment.\n\nFor example, adversaries may add credentials for Service Principals and Applications in addition to existing legitimate credentials in Azure / Entra ID.(Citation: Microsoft SolarWinds Customer Guidance)(Citation: Blue Cloud of Death)(Citation: Blue Cloud of Death Video) These credentials include both x509 keys and passwords.(Citation: Microsoft SolarWinds Customer Guidance) With sufficient permissions, there are a variety of ways to add credentials including the Azure Portal, Azure command line interface, and Azure or Az PowerShell modules.(Citation: Demystifying Azure AD Service Principals)\n\nIn infrastructure-as-a-service (IaaS) environments, after gaining access through [Cloud Accounts](https://attack.mitre.org/techniques/T1078/004), adversaries may generate or import their own SSH keys using either the <code>CreateKeyPair</code> or <code>ImportKeyPair</code> API in AWS or the <code>gcloud compute os-login ssh-keys add</code> command in GCP.(Citation: GCP SSH Key Add) This allows persistent access to instances within the cloud environment without further usage of the compromised cloud accounts.(Citation: Expel IO Evil in AWS)(Citation: Expel Behind the Scenes)\n\nAdversaries may also use the <code>CreateAccessKey</code> API in AWS or the <code>gcloud iam service-accounts keys create</code> command in GCP to add access keys to an account. Alternatively, they may use the <code>CreateLoginProfile</code> API in AWS to add a password that can be used to log into the AWS Management Console for [Cloud Service Dashboard](https://attack.mitre.org/techniques/T1538).(Citation: Permiso Scattered Spider 2023)(Citation: Lacework AI Resource Hijacking 2024) If the target account has different permissions from the requesting account, the adversary may also be able to escalate their privileges in the environment (i.e. [Cloud Accounts](https://attack.mitre.org/techniques/T1078/004)).(Citation: Rhino Security Labs AWS Privilege Escalation)(Citation: Sysdig ScarletEel 2.0) For example, in Entra ID environments, an adversary with the Application Administrator role can add a new set of credentials to their application's service principal. In doing so the adversary would be able to access the service principal’s roles and permissions, which may be different from those of the Application Administrator.(Citation: SpecterOps Azure Privilege Escalation) \n\nIn AWS environments, adversaries with the appropriate permissions may also use the `sts:GetFederationToken` API call to create a temporary set of credentials to [Forge Web Credentials](https://attack.mitre.org/techniques/T1606) tied to the permissions of the original user account. These temporary credentials may remain valid for the duration of their lifetime even if the original account’s API credentials are deactivated.\n(Citation: Crowdstrike AWS User Federation Persistence)\n\nIn Entra ID environments with the app password feature enabled, adversaries may be able to add an app password to a user account.(Citation: Mandiant APT42 Operations 2024) As app passwords are intended to be used with legacy devices that do not support multi-factor authentication (MFA), adding an app password can allow an adversary to bypass MFA requirements. Additionally, app passwords may remain valid even if the user’s primary password is reset.(Citation: Microsoft Entra ID App Passwords)",
                    "description_jp": "敵は、敵が管理する認証情報をクラウドアカウントに追加して、環境内の被害者アカウントとインスタンスへの持続的なアクセスを維持する可能性がある。\n\n例えば、敵対者は、Azure / Entra ID の既存の正当な認証情報に加えて、サービスプリンシパルやアプリケーションの認証情報を追加する可能性があります（引用：Microsoft SolarWinds Customer Guidance）（引用：Blue Cloud of Death）（引用：Blue Cloud of Death Video）これらの認証情報には、x509 キーとパスワードの両方が含まれます。(引用：Microsoft SolarWinds Customer Guidance) 十分な権限があれば、Azureポータル、Azureコマンドラインインターフェイス、AzureまたはAzure PowerShellモジュールなど、さまざまな方法で認証情報を追加できます。 (引用：Demystifying Azure AD Service Principals)\n\nインフラストラクチャ・アズ・ア・サービス（IaaS）環境では、[Cloud Accounts](https://attack.mitre.org/techniques/T1078/004)を通じてアクセス権を得た後、敵対者はAWSの<code>CreateKeyPair</code>または<code>ImportKeyPair</code> API、またはGCPの<code>gcloud compute os-login ssh-keys add</code>コマンドのいずれかを使用して、独自のSSHキーを生成またはインポートする可能性があります。(引用: GCP SSH Key Add) これにより、侵害されたクラウドアカウントをさらに使用することなく、クラウド環境内のインスタンスへの永続的なアクセスが可能になります。 (引用: Expel IO Evil in AWS)(Citation: Expel Behind the Scenes)\n\n攻撃者は、AWS の <code>CreateAccessKey</code> API または GCP の <code>gcloud iam service-accounts keys create</code> コマンドを使用して、アカウントにアクセス キーを追加することもできます。あるいは、AWSの<code>CreateLoginProfile</code> APIを使用して、[Cloud Service Dashboard](https://attack.mitre.org/techniques/T1538)のAWS Management Consoleにログインするために使用できるパスワードを追加することもできる。(引用: Permiso Scattered Spider 2023)(引用: Lacework AI Resource Hijacking 2024)ターゲットアカウントがリクエストアカウントと異なる権限を持っている場合、敵対者は環境内の権限をエスカレートさせることもできる可能性がある(すなわち、[Cloud Accounts](https://attack.mitre.org/techniques/T1538)。引用：Rhino Security Labs AWS Privilege Escalation）（引用：Sysdig ScarletEel 2.0）例えば、Entra ID 環境では、アプリケーション管理者ロールを持つ敵対者は、アプリケーションのサービスプリンシパルに新しい認証情報のセットを追加することができます。そうすることで、アプリケーション管理者とは異なる可能性のあるサービスプリンシパルのロールと権限にアクセスできるようになります。(引用：SpecterOps Azure Privilege Escalation)\n\nAWS 環境では、適切な権限を持つ敵対者は、`sts:GetFederationToken` API 呼び出しを使用して、元のユーザーアカウントの権限に結びついた [Forge Web Credentials](https://attack.mitre.org/techniques/T1606) の一時的な認証情報のセットを作成することもできます。これらの一時的な認証情報は、元のアカウントの API 認証情報が無効化されても、その有効期間中は有効なままである可能性があります。\n(引用：Crowdstrike AWS User Federation Persistence)\n\nアプリパスワード機能が有効になっている Entra ID 環境では、敵対者はユーザアカウントにアプリパスワードを追加できる可能性があります（引用：Mandiant APT42 Operations 2024）。アプリパスワードは、多要素認証（MFA）をサポートしていないレガシーデバイスで使用されることを意図しているため、アプリパスワードを追加すると、敵対者は MFA 要件をバイパスできるようになります。さらに、アプリのパスワードは、ユーザーのプライマリパスワードがリセットされた場合でも有効なままである可能性があります（引用：Microsoft Entra ID App Passwords）。"
                },
                {
                    "id": "T1098.002",
                    "name_eng": "Additional Email Delegate Permissions",
                    "name_jp": "追加の電子メール委任権限",
                    "description_eng": "Adversaries may grant additional permission levels to maintain persistent access to an adversary-controlled email account. \n\nFor example, the <code>Add-MailboxPermission</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001) cmdlet, available in on-premises Exchange and in the cloud-based service Office 365, adds permissions to a mailbox.(Citation: Microsoft - Add-MailboxPermission)(Citation: FireEye APT35 2018)(Citation: Crowdstrike Hiding in Plain Sight 2018) In Google Workspace, delegation can be enabled via the Google Admin console and users can delegate accounts via their Gmail settings.(Citation: Gmail Delegation)(Citation: Google Ensuring Your Information is Safe) \n\nAdversaries may also assign mailbox folder permissions through individual folder permissions or roles. In Office 365 environments, adversaries may assign the Default or Anonymous user permissions or roles to the Top of Information Store (root), Inbox, or other mailbox folders. By assigning one or both user permissions to a folder, the adversary can utilize any other account in the tenant to maintain persistence to the target user’s mail folders.(Citation: Mandiant Defend UNC2452 White Paper)\n\nThis may be used in persistent threat incidents as well as BEC (Business Email Compromise) incidents where an adversary can add [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003) to the accounts they wish to compromise. This may further enable use of additional techniques for gaining access to systems. For example, compromised business accounts are often used to send messages to other accounts in the network of the target business while creating inbox rules (ex: [Internal Spearphishing](https://attack.mitre.org/techniques/T1534)), so the messages evade spam/phishing detection mechanisms.(Citation: Bienstock, D. - Defending O365 - 2019)",
                    "description_jp": "敵対者は、敵対者が管理する電子メールアカウントへの永続的なアクセスを維持するために、追加の許可レベルを与える可能性があります。\n\n例えば、<code>Add-MailboxPermission</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001) コマンドレットは、オンプレミスのExchangeやクラウドベースのサービスOffice 365で利用可能で、メールボックスにアクセス許可を追加します。(引用: Microsoft - Add-MailboxPermission)(引用: FireEye APT35 2018)(引用: Crowdstrike Hiding in Plain Sight 2018) Google Workspaceでは、Google Adminコンソールから委任を有効にすることができ、ユーザーはGmailの設定からアカウントを委任することができる。(引用: Gmail Delegation)(引用: Google Ensuring Your Information is Safe)\n\n敵はまた、個々のフォルダーの権限や役割を通じて、メールボックスのフォルダー権限を割り当てる可能性もある。Office 365環境では、敵は情報ストアのトップ（ルート）、受信トレイ、またはその他のメールボックスフォルダに、デフォルトまたは匿名ユーザーの権限またはロールを割り当てる可能性があります。フォルダに1つまたは両方のユーザー権限を割り当てることで、敵対者はテナント内の他のアカウントを利用して、ターゲットユーザーのメールフォルダへの永続性を維持することができます(引用：Mandiant Defend UNC2452 White Paper)\n\nこれは、持続的脅威インシデントやBEC（ビジネスメール侵害）インシデントで使用される可能性があります。敵対者は、侵害したいアカウントに[Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003)を追加することができます。これにより、システムにアクセスするための新たなテクニックを使用することが可能になります。例えば、侵害されたビジネスアカウントは、受信トレイルール（例：[Internal Spearphishing](https://attack.mitre.org/techniques/T1534)）を作成しながら、ターゲットビジネスのネットワーク内の他のアカウントにメッセージを送信するために使用されることが多いため、メッセージはスパム/フィッシング検出メカニズムを回避します。(引用：Bienstock, D. - Defending O365 - 2019)"
                },
                {
                    "id": "T1098.003",
                    "name_eng": "Additional Cloud Roles",
                    "name_jp": "追加のクラウドの役割",
                    "description_eng": "An adversary may add additional roles or permissions to an adversary-controlled cloud account to maintain persistent access to a tenant. For example, adversaries may update IAM policies in cloud-based environments or add a new global administrator in Office 365 environments.(Citation: AWS IAM Policies and Permissions)(Citation: Google Cloud IAM Policies)(Citation: Microsoft Support O365 Add Another Admin, October 2019)(Citation: Microsoft O365 Admin Roles) With sufficient permissions, a compromised account can gain almost unlimited access to data and settings (including the ability to reset the passwords of other admins).(Citation: Expel AWS Attacker)\n(Citation: Microsoft O365 Admin Roles) \n\nThis account modification may immediately follow [Create Account](https://attack.mitre.org/techniques/T1136) or other malicious account activity. Adversaries may also modify existing [Valid Accounts](https://attack.mitre.org/techniques/T1078) that they have compromised. This could lead to privilege escalation, particularly if the roles added allow for lateral movement to additional accounts.\n\nFor example, in AWS environments, an adversary with appropriate permissions may be able to use the <code>CreatePolicyVersion</code> API to define a new version of an IAM policy or the <code>AttachUserPolicy</code> API to attach an IAM policy with additional or distinct permissions to a compromised user account.(Citation: Rhino Security Labs AWS Privilege Escalation)\n\nIn some cases, adversaries may add roles to adversary-controlled accounts outside the victim cloud tenant. This allows these external accounts to perform actions inside the victim tenant without requiring the adversary to [Create Account](https://attack.mitre.org/techniques/T1136) or modify a victim-owned account.(Citation: Invictus IR DangerDev 2024)",
                    "description_jp": "敵対者は、テナントへの永続的なアクセスを維持するために、敵対者が管理するクラウドアカウントに追加のロールや権限を追加する可能性がある。例えば、敵対者はクラウドベースの環境でIAMポリシーを更新したり、Office 365環境で新しいグローバル管理者を追加したりする可能性があります(引用: AWS IAM Policies and Permissions)(Citation: Google Cloud IAM Policies)(Citation: Microsoft Support O365 Add Another Admin, October 2019)(Citation: Microsoft O365 Admin Roles) 十分な権限があれば、侵害されたアカウントはデータや設定にほぼ無制限にアクセスできるようになります(他の管理者のパスワードをリセットする機能を含む)(引用: Expel AWS Attacker)\n(引用：Microsoft O365管理者の役割)\n\nこのアカウント変更は、[Create Account](https://attack.mitre.org/techniques/T1136)または他の悪意のあるアカウント活動の直後に行われる可能性があります。攻撃者は、侵害した既存の[有効なアカウント](https://attack.mitre.org/techniques/T1078)を変更することもあります。これは、特に追加されたロールが追加のアカウントへの横方向の移動を許可している場合、特権の昇格につながる可能性があります。\n\n例えば、AWS 環境では、適切な権限を持つ敵は、<code>CreatePolicyVersion</code> API を使用して IAM ポリシーの新しいバージョンを定義したり、<code>AttachUserPolicy</code> API を使用して、侵害されたユーザーアカウントに追加または別の権限を持つ IAM ポリシーをアタッチすることができます。(引用: Rhino Security Labs AWS Privilege Escalation)\n\n場合によっては、敵対者は被害者のクラウドテナントの外部で敵対者が管理するアカウントにロールを追加することがあります。これにより、これらの外部アカウントは、敵対者が[Create Account](https://attack.mitre.org/techniques/T1136)または被害者が所有するアカウントを変更することなく、被害者テナント内でアクションを実行できるようになります(引用: Invictus IR DangerDev 2024)。"
                },
                {
                    "id": "T1098.005",
                    "name_eng": "Device Registration",
                    "name_jp": "機器登録",
                    "description_eng": "Adversaries may register a device to an adversary-controlled account. Devices may be registered in a multifactor authentication (MFA) system, which handles authentication to the network, or in a device management system, which handles device access and compliance.\n\nMFA systems, such as Duo or Okta, allow users to associate devices with their accounts in order to complete MFA requirements. An adversary that compromises a user’s credentials may enroll a new device in order to bypass initial MFA requirements and gain persistent access to a network.(Citation: CISA MFA PrintNightmare)(Citation: DarkReading FireEye SolarWinds) In some cases, the MFA self-enrollment process may require only a username and password to enroll the account's first device or to enroll a device to an inactive account. (Citation: Mandiant APT29 Microsoft 365 2022)\n\nSimilarly, an adversary with existing access to a network may register a device to Entra ID and/or its device management system, Microsoft Intune, in order to access sensitive data or resources while bypassing conditional access policies.(Citation: AADInternals - Device Registration)(Citation: AADInternals - Conditional Access Bypass)(Citation: Microsoft DEV-0537) \n\nDevices registered in Entra ID may be able to conduct [Internal Spearphishing](https://attack.mitre.org/techniques/T1534) campaigns via intra-organizational emails, which are less likely to be treated as suspicious by the email client.(Citation: Microsoft - Device Registration) Additionally, an adversary may be able to perform a [Service Exhaustion Flood](https://attack.mitre.org/techniques/T1499/002) on an Entra ID tenant by registering a large number of devices.(Citation: AADInternals - BPRT)",
                    "description_jp": "敵は、敵が管理するアカウントにデバイスを登録することができる。デバイスは、ネットワークへの認証を処理する多要素認証（MFA）システム、またはデバイス・アクセスとコンプライアンスを処理するデバイス管理システムに登録されることがある。\n\nDuo や Okta などの MFA システムでは、MFA 要件を満たすために、ユーザが自分のアカウントにデバイスを関連付けることができる。ユーザの認証情報を侵害した敵対者は、最初の MFA 要件を回避してネットワークへの永続的なアクセスを獲得するために、新しいデバイスを登録する可能性があります（引用：CISA MFA PrintNightmare）。(引用：Mandiant APT29 Microsoft 365 2022)\n\n同様に、ネットワークへの既存のアクセス権を持つ敵対者は、条件付きアクセスポリシーをバイパスして機密データやリソースにアクセスするために、Entra ID および/またはそのデバイス管理システムである Microsoft Intune にデバイスを登録する可能性がある(引用: AADInternals - デバイス登録)(引用: AADInternals - 条件付きアクセスバイパス)(引用: Microsoft DEV-0537)\n\nEntra ID に登録されたデバイスは、メールクライアントによって不審なものとして扱われる可能性が低い、組織内の電子メールを介した [内部スピアフィッシング](https://attack.mitre.org/techniques/T1534) キャンペーンを実施できる可能性があります(引用: Microsoft - デバイス登録)。さらに、敵対者は、多数のデバイスを登録することによって、Entra ID テナントに対して [Service Exhaustion Flood](https://attack.mitre.org/techniques/T1499/002) を実行できる可能性があります(引用: AADInternals - BPRT)。"
                },
                {
                    "id": "T1098.006",
                    "name_eng": "Additional Container Cluster Roles",
                    "name_jp": "追加のコンテナ・クラスタの役割",
                    "description_eng": "An adversary may add additional roles or permissions to an adversary-controlled user or service account to maintain persistent access to a container orchestration system. For example, an adversary with sufficient permissions may create a RoleBinding or a ClusterRoleBinding to bind a Role or ClusterRole to a Kubernetes account.(Citation: Kubernetes RBAC)(Citation: Aquasec Kubernetes Attack 2023) Where attribute-based access control (ABAC) is in use, an adversary with sufficient permissions may modify a Kubernetes ABAC policy to give the target account additional permissions.(Citation: Kuberentes ABAC)\n \nThis account modification may immediately follow [Create Account](https://attack.mitre.org/techniques/T1136) or other malicious account activity. Adversaries may also modify existing [Valid Accounts](https://attack.mitre.org/techniques/T1078) that they have compromised.  \n\nNote that where container orchestration systems are deployed in cloud environments, as with Google Kubernetes Engine, Amazon Elastic Kubernetes Service, and Azure Kubernetes Service, cloud-based  role-based access control (RBAC) assignments or ABAC policies can often be used in place of or in addition to local permission assignments.(Citation: Google Cloud Kubernetes IAM)(Citation: AWS EKS IAM Roles for Service Accounts)(Citation: Microsoft Azure Kubernetes Service Service Accounts) In these cases, this technique may be used in conjunction with [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003).",
                    "description_jp": "敵対者は、コンテナオーケストレーションシステムへの永続的なアクセスを維持するために、敵対者が制御するユーザーまたはサービスアカウントに追加のロールまたはパーミッションを追加することができる。たとえば、十分なパーミッションを持つ敵対者は、RoleBindingまたはClusterRoleBindingを作成して、KubernetesアカウントにRoleまたはClusterRoleをバインドすることができる(引用: Kubernetes RBAC)(引用: Aquasec Kubernetes Attack 2023) 属性ベースのアクセス制御(ABAC)が使用されている場合、十分なパーミッションを持つ敵対者は、Kubernetes ABACポリシーを変更して、ターゲットアカウントに追加のパーミッションを与えることができる(引用: Kuberentes ABAC)\n \nこのアカウント修正は、[Create Account](https://attack.mitre.org/techniques/T1136)またはその他の悪意のあるアカウント活動の直後に行われる可能性があります。攻撃者は、侵害した既存の[Valid Accounts](https://attack.mitre.org/techniques/T1078)を修正することもあります。  \n\nGoogle Kubernetes Engine、Amazon Elastic Kubernetes Service、Azure Kubernetes Serviceのように、コンテナオーケストレーションシステムがクラウド環境にデプロイされている場合、クラウドベースのロールベースアクセス制御（RBAC）割り当てまたはABACポリシーが、ローカルの権限割り当ての代わりに、またはそれに加えて、しばしば使用できることに注意してください。(引用: Google Cloud Kubernetes IAM)(Citation: AWS EKS IAM Roles for Service Accounts)(Citation: Microsoft Azure Kubernetes Service Service Accounts) これらの場合、このテクニックは[Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003)と組み合わせて使用することができます。"
                },
                {
                    "id": "T1098.004",
                    "name_eng": "SSH Authorized Keys",
                    "name_jp": "SSH認証キー",
                    "description_eng": "Adversaries may modify the SSH <code>authorized_keys</code> file to maintain persistence on a victim host. Linux distributions, macOS, and ESXi hypervisors commonly use key-based authentication to secure the authentication process of SSH sessions for remote management. The <code>authorized_keys</code> file in SSH specifies the SSH keys that can be used for logging into the user account for which the file is configured. This file is usually found in the user's home directory under <code>&lt;user-home&gt;/.ssh/authorized_keys</code> (or, on ESXi, `/etc/ssh/keys-<username>/authorized_keys`).(Citation: SSH Authorized Keys) Users may edit the system’s SSH config file to modify the directives `PubkeyAuthentication` and `RSAAuthentication` to the value `yes` to ensure public key and RSA authentication are enabled, as well as modify the directive `PermitRootLogin` to the value `yes` to enable root authentication via SSH.(Citation: Broadcom ESXi SSH) The SSH config file is usually located under <code>/etc/ssh/sshd_config</code>.\n\nAdversaries may modify SSH <code>authorized_keys</code> files directly with scripts or shell commands to add their own adversary-supplied public keys. In cloud environments, adversaries may be able to modify the SSH authorized_keys file of a particular virtual machine via the command line interface or rest API. For example, by using the Google Cloud CLI’s “add-metadata” command an adversary may add SSH keys to a user account.(Citation: Google Cloud Add Metadata)(Citation: Google Cloud Privilege Escalation) Similarly, in Azure, an adversary may update the authorized_keys file of a virtual machine via a PATCH request to the API.(Citation: Azure Update Virtual Machines) This ensures that an adversary possessing the corresponding private key may log in as an existing user via SSH.(Citation: Venafi SSH Key Abuse)(Citation: Cybereason Linux Exim Worm) It may also lead to privilege escalation where the virtual machine or instance has distinct permissions from the requesting user.\n\nWhere authorized_keys files are modified via cloud APIs or command line interfaces, an adversary may achieve privilege escalation on the target virtual machine if they add a key to a higher-privileged user. \n\nSSH keys can also be added to accounts on network devices, such as with the `ip ssh pubkey-chain` [Network Device CLI](https://attack.mitre.org/techniques/T1059/008) command.(Citation: cisco_ip_ssh_pubkey_ch_cmd)",
                    "description_jp": "攻撃者は SSH <code>authorized_keys</code> ファイルを変更し、被害者ホスト上で永続性を維持する可能性があります。Linuxディストリビューション、macOS、およびESXiハイパーバイザーは、リモート管理のためのSSHセッションの認証プロセスを保護するために、一般的に鍵ベースの認証を使用します。SSHの<code>authorized_keys</code>ファイルは、そのファイルが設定されているユーザーアカウントへのログインに使用できるSSHキーを指定します。このファイルは通常、<code>&lt;user-home&gt;/.ssh/authorized_keys</code>（または、ESXi では `/etc/ssh/keys-<ユーザー名>/authorized_keys`）の下のユーザーのホームディレクトリにあります。(引用: SSH Authorized Keys) ユーザーはシステムの SSH 設定ファイルを編集して、ディレクティブ `PubkeyAuthentication` と `RSAAuthentication` を値 `yes` に変更し、公開鍵と RSA 認証が有効になっていることを確認します。また、ディレクティブ `PermitRootLogin` を値 `yes` に変更し、SSH による root 認証を有効にします。(Citation: Broadcom ESXi SSH) SSH 設定ファイルは通常 <code>/etc/ssh/sshd_config</code> の下にあります。\n\n敵はスクリプトやシェル・コマンドを使ってSSHの<code>authorized_keys</code>ファイルを直接修正し、敵が提供する公開鍵を追加することができる。クラウド環境では、敵はコマンドラインインターフェースやレストAPIを使って、特定の仮想マシンのSSH authorized_keysファイルを変更できるかもしれません。例えば、Google Cloud CLIの \"add-metadata \"コマンドを使用することで、敵対者はユーザーアカウントにSSH鍵を追加することができる（引用：Google Cloud Add Metadata）（引用：Google Cloud Privilege Escalation）同様に、Azureでは、敵対者はAPIへのPATCHリクエストによって仮想マシンのauthorized_keysファイルを更新することができる。(引用：Azure Update Virtual Machines) これにより、対応する秘密鍵を所有する敵対者は、SSH経由で既存のユーザーとしてログインすることができます。(引用：Venafi SSH Key Abuse) (引用：Cybereason Linux Exim Worm) また、仮想マシンまたはインスタンスが要求ユーザーとは異なる権限を持っている場合、権限の昇格につながる可能性があります。\n\nauthorized_keysファイルがクラウドAPIやコマンドラインインターフェースを介して変更される場合、敵対者は、より高い特権ユーザーにキーを追加すると、ターゲットの仮想マシン上で特権昇格を達成する可能性があります。\n\nSSH 鍵は、`ip ssh pubkey-chain` [Network Device CLI](https://attack.mitre.org/techniques/T1059/008)コマンドなどで、ネットワークデバイス上のアカウントに追加することもできる。(引用: cisco_ip_ssh_pubkey_ch_cmd)"
                },
                {
                    "id": "T1098.007",
                    "name_eng": "Additional Local or Domain Groups",
                    "name_jp": "ローカルまたはドメイングループの追加",
                    "description_eng": "An adversary may add additional local or domain groups to an adversary-controlled account to maintain persistent access to a system or domain.\n\nOn Windows, accounts may use the `net localgroup` and `net group` commands to add existing users to local and domain groups.(Citation: Microsoft Net Localgroup)(Citation: Microsoft Net Group) On Linux, adversaries may use the `usermod` command for the same purpose.(Citation: Linux Usermod)\n\nFor example, accounts may be added to the local administrators group on Windows devices to maintain elevated privileges. They may also be added to the Remote Desktop Users group, which allows them to leverage [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) to log into the endpoints in the future.(Citation: Microsoft RDP Logons) On Linux, accounts may be added to the sudoers group, allowing them to persistently leverage [Sudo and Sudo Caching](https://attack.mitre.org/techniques/T1548/003) for elevated privileges. \n\nIn Windows environments, machine accounts may also be added to domain groups. This allows the local SYSTEM account to gain privileges on the domain.(Citation: RootDSE AD Detection 2022)",
                    "description_jp": "敵対者は、システムやドメインへの永続的なアクセスを維持するために、敵対者が管理するアカウントにローカルグループやドメイングループを追加するかもしれない。\n\nWindowsでは、アカウントは`net localgroup`コマンドと`net group`コマンドを使って、既存のユーザーをローカルグループやドメイングループに追加することができる(引用: Microsoft Net Localgroup)(引用: Microsoft Net Group) Linuxでは、敵対者は同じ目的で`usermod`コマンドを使うことができる(引用: Linux Usermod)\n\n例えば、Windowsデバイスのローカル管理者グループにアカウントを追加して、昇格した特権を維持することができる。また、将来エンドポイントにログインするために[Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001)を利用できるように、Remote Desktop Usersグループに追加することもできる。(引用: Microsoft RDP Logons) Linuxでは、昇格した特権のために[Sudo and Sudo Caching](https://attack.mitre.org/techniques/T1548/003)を持続的に利用できるように、sudoersグループにアカウントを追加することができる。\n\nWindows環境では、マシンアカウントをドメイングループに追加することもできる。これにより、ローカルのSYSTEMアカウントがドメイン上で特権を得ることができる(引用：RootDSE AD Detection 2022)。"
                }
            ]
        },
        {
            "id": "T1574",
            "name_eng": "Hijack Execution Flow",
            "name_jp": "ハイジャック実行フロー",
            "description_eng": "Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution.\n\nThere are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.",
            "description_jp": "攻撃者は、オペレーティング・システムがプログラムを実行する方法をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性がある。実行フローの乗っ取りは、乗っ取られた実行が時間の経過とともに再発する可能性があるため、永続性を目的として行われることもあります。攻撃者はまた、アプリケーション制御やその他の実行制限などの特権の昇格や防御の回避のために、これらのメカニズムを使用する可能性があります。\n\n敵が実行の流れをハイジャックする方法には、オペレーティング・システムが実行するプログラムの場所を特定する方法を操作する方法など、さまざまなものがある。オペレーティング・システムがプログラムによって使われるライブラリを見つける方法も傍受される可能性があります。ファイル・ディレクトリや、Windowsの場合はレジストリなど、オペレーティング・システムがプログラム／リソースを探す場所も、悪意のあるペイロードを含むように不正に操作される可能性があります。",
            "subtechniques": [
                {
                    "id": "T1574.010",
                    "name_eng": "Services File Permissions Weakness",
                    "name_jp": "サービス・ファイル・パーミッションの脆弱性",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the binaries used by services. Adversaries may use flaws in the permissions of Windows services to replace the binary that is executed upon service start. These service processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.\n\nAdversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.",
                    "description_jp": "攻撃者は、サービスによって使用されるバイナリをハイジャックすることで、独自の悪意のあるペイロードを実行する可能性がある。攻撃者は、Windowsサービスのパーミッションの欠陥を利用して、サービス起動時に実行されるバイナリを置き換える可能性があります。これらのサービスプロセスは、その機能の一部として、または他のアクションを実行するために、特定のバイナリを自動的に実行する可能性があります。ターゲット・バイナリを含むファイルシステム・ディレクトリのパーミッション、またはバイナリ自体のパーミッションが不適切に設定されている場合、ターゲット・バイナリはユーザーレベルのパーミッションを使用する別のバイナリで上書きされ、元のプロセスによって実行される可能性があります。元のプロセスとスレッドがより高いパーミッション レベルの下で実行されている場合、置き換えられたバイナリも SYSTEM を含むより高いレベルのパーミッションの下で実行されます。\n\n攻撃者は、より高いパーミッションレベルでコードを実行する手段として、正当なバイナリを悪意のあるバイナリに置き換えるためにこのテクニックを使用する可能性があります。実行プロセスが特定の時間または特定のイベント(例えばシステムの起動)の間に実行されるように設定されている場合、このテクニックは永続化のためにも使用することができる。"
                },
                {
                    "id": "T1574.013",
                    "name_eng": "KernelCallbackTable",
                    "name_jp": "カーネルコールバックテーブル",
                    "description_eng": "Adversaries may abuse the <code>KernelCallbackTable</code> of a process to hijack its execution flow in order to run their own payloads.(Citation: Lazarus APT January 2022)(Citation: FinFisher exposed ) The <code>KernelCallbackTable</code> can be found in the Process Environment Block (PEB) and is initialized to an array of graphic functions available to a GUI process once <code>user32.dll</code> is loaded.(Citation: Windows Process Injection KernelCallbackTable)\n\nAn adversary may hijack the execution flow of a process using the <code>KernelCallbackTable</code> by replacing an original callback function with a malicious payload. Modifying callback functions can be achieved in various ways involving related behaviors such as [Reflective Code Loading](https://attack.mitre.org/techniques/T1620) or [Process Injection](https://attack.mitre.org/techniques/T1055) into another process.\n\nA pointer to the memory address of the <code>KernelCallbackTable</code> can be obtained by locating the PEB (ex: via a call to the <code>NtQueryInformationProcess()</code> [Native API](https://attack.mitre.org/techniques/T1106) function).(Citation: NtQueryInformationProcess) Once the pointer is located, the <code>KernelCallbackTable</code> can be duplicated, and a function in the table (e.g., <code>fnCOPYDATA</code>) set to the address of a malicious payload (ex: via <code>WriteProcessMemory()</code>). The PEB is then updated with the new address of the table. Once the tampered function is invoked, the malicious payload will be triggered.(Citation: Lazarus APT January 2022)\n\nThe tampered function is typically invoked using a Windows message. After the process is hijacked and malicious code is executed, the <code>KernelCallbackTable</code> may also be restored to its original state by the rest of the malicious payload.(Citation: Lazarus APT January 2022) Use of the <code>KernelCallbackTable</code> to hijack execution flow may evade detection from security products since the execution can be masked under a legitimate process.",
                    "description_jp": "攻撃者はプロセスの <code>KernelCallbackTable</code> を悪用して、独自のペイロードを実行するためにプロセスの実行フローをハイジャックする可能性があります。(引用: Lazarus APT January 2022)(引用: FinFisher exposed ) <code>KernelCallbackTable</code> はプロセス環境ブロック (PEB) にあり、<code>user32.dll</code> がロードされると、GUI プロセスで利用可能なグラフィック関数の配列に初期化されます。(引用: Windows プロセス インジェクション KernelCallbackTable)\n\n敵対者は、元のコールバック関数を悪意のあるペイロードで置き換えることで、<code>KernelCallbackTable</code>を使用したプロセスの実行フローを乗っ取る可能性があります。コールバック関数の変更は、別のプロセスへの [Reflective Code Loading](https://attack.mitre.org/techniques/T1620) や [Process Injection](https://attack.mitre.org/techniques/T1055) など、関連する動作を含むさまざまな方法で行うことができます。\n\n<code>KernelCallbackTable</code>のメモリ アドレスへのポインタは、PEB の場所を特定することで取得できます (例: <code>NtQueryInformationProcess()</code> [Native API](https://attack.mitre.org/techniques/T1106) 関数の呼び出しを介して)。(引用: NtQueryInformationProcess) ポインタが見つかったら、<code>KernelCallbackTable</code> を複製し、テーブル内の関数 (例:、<code>fnCOPYDATA</code>）を悪意のあるペイロードのアドレスに設定します（例：<code>WriteProcessMemory()</code>経由）。その後、PEBはテーブルの新しいアドレスで更新されます。改ざんされた関数が起動されると、悪意のあるペイロードがトリガーされます。(引用：Lazarus APT January 2022)\n\n改ざんされた関数は通常、Windowsメッセージを使って起動される。プロセスがハイジャックされ、悪意のあるコードが実行された後、<code>KernelCallbackTable</code> は悪意のあるペイロードの残りの部分によって元の状態に復元される可能性があります。 (引用: Lazarus APT January 2022) <code>KernelCallbackTable</code>を使用して実行フローをハイジャックすると、正当なプロセスの下で実行を隠蔽できるため、セキュリティ製品からの検出を回避できる可能性があります。"
                },
                {
                    "id": "T1574.007",
                    "name_eng": "Path Interception by PATH Environment Variable",
                    "name_jp": "PATH環境変数によるパスの遮断",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking environment variables used to load libraries. The PATH environment variable contains a list of directories (User and System) that the OS searches sequentially through in search of the binary that was called from a script or the command line. \n\nAdversaries can place a malicious program in an earlier entry in the list of directories stored in the PATH environment variable, resulting in the operating system executing the malicious binary rather than the legitimate binary when it searches sequentially through that PATH listing.\n\nFor example, on Windows if an adversary places a malicious program named \"net.exe\" in `C:\\example path`, which by default precedes `C:\\Windows\\system32\\net.exe` in the PATH environment variable, when \"net\" is executed from the command-line the `C:\\example path` will be called instead of the system's legitimate executable at `C:\\Windows\\system32\\net.exe`. Some methods of executing a program rely on the PATH environment variable to determine the locations that are searched when the path for the program is not given, such as executing programs from a [Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059).(Citation: ExpressVPN PATH env Windows 2021)\n\nAdversaries may also directly modify the $PATH variable specifying the directories to be searched.  An adversary can modify the `$PATH` variable to point to a directory they have write access. When a program using the $PATH variable is called, the OS searches the specified directory and executes the malicious binary. On macOS, this can also be performed through modifying the $HOME variable. These variables can be modified using the command-line, launchctl, [Unix Shell Configuration Modification](https://attack.mitre.org/techniques/T1546/004), or modifying the `/etc/paths.d` folder contents.(Citation: uptycs Fake POC linux malware 2023)(Citation: nixCraft macOS PATH variables)(Citation: Elastic Rules macOS launchctl 2022)",
                    "description_jp": "攻撃者は、ライブラリのロードに使用される環境変数をハイジャックすることで、独自の悪意あるペイロードを実行する可能性がある。PATH環境変数には、スクリプトやコマンドラインから呼び出されたバイナリを探すためにOSが順次検索するディレクトリ（UserとSystem）のリストが含まれている。\n\n攻撃者は、PATH環境変数に格納されたディレクトリのリストの前のエントリに悪意のあるプログラムを置くことができ、その結果、OSは、PATHリストを順次検索する際に、正当なバイナリではなく、悪意のあるバイナリを実行する。\n\n例えば、Windowsの場合、敵が「net.exe」という悪意のあるプログラムを「C:⊖example path」に置くと、デフォルトではPATH環境変数で「C:⊖Windowssystem32net.exe` 」の前に置かれるため、コマンドラインから「net」を実行すると、「C:⊖Windowssystem32net.exe` 」にあるシステムの正当な実行ファイルの代わりに「C:⊖example path` 」が呼び出されることになる。プログラムの実行方法の中には、[Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059)からプログラムを実行するなど、プログラムのパスが与えられていない場合に検索される場所を決定するためにPATH環境変数に依存するものがある(引用: ExpressVPN PATH env Windows 2021)。\n\n敵対者は、検索対象のディレクトリを指定する $PATH 変数を直接変更することもできます。  敵対者は `$PATH` 変数を変更し、自分が書き込み権限を持つディレクトリを指すようにすることができる。PATH変数を使ったプログラムが呼び出されると、OSは指定されたディレクトリを検索し、悪意のあるバイナリを実行する。macOSでは、$HOME変数を変更することによっても実行できる。これらの変数は、コマンドライン、launchctl、[Unix Shell Configuration Modification](https://attack.mitre.org/techniques/T1546/004)、または`/etc/paths.d`フォルダの内容を変更することで変更できる。(引用：uptycs Fake POC linux malware 2023)(引用：nixCraft macOS PATH変数)(引用：Elastic Rules macOS launchctl 2022)"
                },
                {
                    "id": "T1574.005",
                    "name_eng": "Executable Installer File Permissions Weakness",
                    "name_jp": "実行可能インストーラファイルのパーミッションの脆弱性",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the binaries used by an installer. These processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself, are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.\n\nAnother variation of this technique can be performed by taking advantage of a weakness that is common in executable, self-extracting installers. During the installation process, it is common for installers to use a subdirectory within the <code>%TEMP%</code> directory to unpack binaries such as DLLs, EXEs, or other payloads. When installers create subdirectories and files they often do not set appropriate permissions to restrict write access, which allows for execution of untrusted code placed in the subdirectories or overwriting of binaries used in the installation process. This behavior is related to and may take advantage of [DLL](https://attack.mitre.org/techniques/T1574/001) search order hijacking.\n\nAdversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. Some installers may also require elevated privileges that will result in privilege escalation when executing adversary controlled code. This behavior is related to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002). Several examples of this weakness in existing common installers have been reported to software vendors.(Citation: mozilla_sec_adv_2012)  (Citation: Executable Installers are Vulnerable) If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.",
                    "description_jp": "攻撃者は、インストーラが使用するバイナリをハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。これらのプロセスは、その機能の一部として、あるいは他のアクションを実行するために、特定のバイナリを自動的に実行する可能性があります。ターゲットバイナリを含むファイルシステムディレクトリのパーミッションやバイナリ自体のパーミッションが不適切に設定されている場合、ターゲットバイナリはユーザレベルのパーミッションを使用する別のバイナリで上書きされ、元のプロセスによって実行される可能性があります。元のプロセスとスレッドがより高いパーミッション レベルの下で実行されている場合、置き換えられたバイナリも SYSTEM を含むより高いレベルのパーミッションの下で実行されます。\n\nこのテクニックの別のバリエーションは、実行可能な自己解凍インストーラによくある弱点を利用することで実行可能です。インストールプロセス中、インストーラは、<code>%TEMP%</code> ディレクトリ内のサブディレクトリを使用して、DLL や EXE、その他のペイロードなどのバイナリを展開するのが一般的です。インストーラがサブディレクトリやファイルを作成する際、書き込みアクセスを制限する適切なパーミッションを設定しないことが多く、サブディレクトリに置かれた信頼できないコードの実行や、インストールプロセスで使用されたバイナリの上書きを許してしまいます。この挙動は、[DLL](https://attack.mitre.org/techniques/T1574/001) の検索順ハイジャックに関連しており、これを利用している可能性があります。\n\n攻撃者はこのテクニックを使って、より高いパーミッションレベルでコードを実行する手段として、正当なバイナリを悪意のあるバイナリに置き換える可能性があります。インストーラの中には、敵が制御するコードを実行する際に、特権の昇格を要求するものもあるかもしれません。この振る舞いは [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002) に関連しています。(引用: mozilla_sec_adv_2012) (引用: Executable Installers are Vulnerable) 実行プロセスが特定の時間や特定のイベント(例えばシステムの起動)の間に実行されるように設定されている場合、このテクニックは永続化にも使用できます。"
                },
                {
                    "id": "T1574.009",
                    "name_eng": "Path Interception by Unquoted Path",
                    "name_jp": "引用されていないパスによるパスの妨害",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking vulnerable file path references. Adversaries can take advantage of paths that lack surrounding quotations by placing an executable in a higher level directory within the path, so that Windows will choose the adversary's executable to launch.\n\nService paths (Citation: Microsoft CurrentControlSet Services) and shortcut paths may also be vulnerable to path interception if the path has one or more spaces and is not surrounded by quotation marks (e.g., <code>C:\\unsafe path with space\\program.exe</code> vs. <code>\"C:\\safe path with space\\program.exe\"</code>). (Citation: Help eliminate unquoted path) (stored in Windows Registry keys) An adversary can place an executable in a higher level directory of the path, and Windows will resolve that executable instead of the intended executable. For example, if the path in a shortcut is <code>C:\\program files\\myapp.exe</code>, an adversary may create a program at <code>C:\\program.exe</code> that will be run instead of the intended program. (Citation: Windows Unquoted Services) (Citation: Windows Privilege Escalation Guide)\n\nThis technique can be used for persistence if executables are called on a regular basis, as well as privilege escalation if intercepted executables are started by a higher privileged process.",
                    "description_jp": "攻撃者は、脆弱なファイルパス参照をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性がある。敵は、パス内の上位ディレクトリに実行ファイルを配置することで、周囲の引用符がないパスを利用し、Windowsが敵の実行ファイルを選択して起動するようにすることができます。\n\nサービス パス (引用: Microsoft CurrentControlSet Services) およびショートカット パスも、パスに 1 つ以上のスペースがあり、引用符で囲まれていない場合 (たとえば、<code>C:unsafe path with spaceprogram.exe</code> vs. <code>\"C:unsafeパス with spaceprogram.exe\"</code>) 、パスを傍受される可能性があります。(引用：Help eliminate unquoted path）（Windows レジストリキーに格納）敵対者はパスの上位ディレクトリに実行可能ファイルを置くことができ、Windowsは意図した実行可能ファイルの代わりにその実行可能ファイルを解決する。たとえば、ショートカットのパスが<code>C:³³³.exe</code>の場合、敵は<code>C:³³³.exe</code>にプログラムを作成し、意図したプログラムの代わりに実行することができます。(引用: Windows Unquoted Services) (引用: Windows Privilege Escalation Guide)\n\nこのテクニックは、実行可能ファイルが定期的に呼び出される場合の永続化や、傍受された実行可能ファイルがより高い特権を持つプロセスによって起動される場合の特権昇格に使用できます。"
                },
                {
                    "id": "T1574.004",
                    "name_eng": "Dylib Hijacking",
                    "name_jp": "ディリブ・ハイジャック",
                    "description_eng": "Adversaries may execute their own payloads by placing a malicious dynamic library (dylib) with an expected name in a path a victim application searches at runtime. The dynamic loader will try to find the dylibs based on the sequential order of the search paths. Paths to dylibs may be prefixed with <code>@rpath</code>, which allows developers to use relative paths to specify an array of search paths used at runtime based on the location of the executable.  Additionally, if weak linking is used, such as the <code>LC_LOAD_WEAK_DYLIB</code> function, an application will still execute even if an expected dylib is not present. Weak linking enables developers to run an application on multiple macOS versions as new APIs are added.\n\nAdversaries may gain execution by inserting malicious dylibs with the name of the missing dylib in the identified path.(Citation: Wardle Dylib Hijack Vulnerable Apps)(Citation: Wardle Dylib Hijacking OSX 2015)(Citation: Github EmpireProject HijackScanner)(Citation: Github EmpireProject CreateHijacker Dylib) Dylibs are loaded into an application's address space allowing the malicious dylib to inherit the application's privilege level and resources. Based on the application, this could result in privilege escalation and uninhibited network access. This method may also evade detection from security products since the execution is masked under a legitimate process.(Citation: Writing Bad Malware for OSX)(Citation: wardle artofmalware volume1)(Citation: MalwareUnicorn macOS Dylib Injection MachO)",
                    "description_jp": "攻撃者は、被害者のアプリケーションが実行時に検索するパスに、予想される名前の悪意のあるダイナミック・ライブラリ（dylib）を配置することで、独自のペイロードを実行する可能性があります。ダイナミック・ローダーは、検索パスの順序に基づいて、dylib を見つけようとします。ディリブへのパスの先頭には <code>@rpath</code> を付けることができ、開発者は相対パスを使用して実行可能ファイルの場所に基づいて実行時に使用される検索パスの配列を指定することができます。  さらに、<code>LC_LOAD_WEAK_DYLIB</code> 関数のような弱いリンクが使用されている場合、期待される dylib が存在しなくてもアプリケーションは実行されます。弱いリンクによって、開発者は新しいAPIが追加されたときに、複数のmacOSバージョンでアプリケーションを実行することができます。\n\n攻撃者は、特定されたパスに欠落している dylib の名前を持つ悪意のある dylib を挿入することで、実行を獲得する可能性があります（引用：Wardle Dylib Hijack Vulnerable Apps）（引用：Wardle Dylib Hijacking OSX 2015）（引用：Github EmpireProject HijackScanner）（引用：Github EmpireProject CreateHijacker Dylib） dylib はアプリケーションのアドレス空間にロードされ、悪意のある dylib がアプリケーションの特権レベルとリソースを継承できるようになります。アプリケーションによっては、特権の昇格や無制限のネットワークアクセスを引き起こす可能性があります。この方法は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品からの検出を回避することもできます。 (引用：Writing Bad Malware for OSX)(Citation: wardle artofmalware volume1)(Citation: MalwareUnicorn macOS Dylib Injection MachO)"
                },
                {
                    "id": "T1574.006",
                    "name_eng": "Dynamic Linker Hijacking",
                    "name_jp": "ダイナミック・リンカー・ハイジャッキング",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from various environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS.(Citation: TheEvilBit DYLD_INSERT_LIBRARIES)(Citation: Timac DYLD_INSERT_LIBRARIES)(Citation: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) Each platform's linker uses an extensive list of environment variables at different points in execution. These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions in the original library.(Citation: Baeldung LD_PRELOAD)\n\nHijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. On Linux, adversaries may set <code>LD_PRELOAD</code> to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. For example, adversaries have used `LD_PRELOAD` to inject a malicious library into every descendant process of the `sshd` daemon, resulting in execution under a legitimate process. When the executing sub-process calls the `execve` function, for example, the malicious library’s `execve` function is executed rather than the system function `execve` contained in the system library on disk. This allows adversaries to [Hide Artifacts](https://attack.mitre.org/techniques/T1564) from detection, as hooking system functions such as `execve` and `readdir` enables malware to scrub its own artifacts from the results of commands such as `ls`, `ldd`, `iptables`, and `dmesg`.(Citation: ESET Ebury Oct 2017)(Citation: Intezer Symbiote 2022)(Citation: Elastic Security Labs Pumakit 2024)\n\nHijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges.",
                    "description_jp": "攻撃者は、ダイナミックリンカーが共有ライブラリをロードするために使用する環境変数をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。プログラムの実行準備段階で、ダイナミックリンカーは、Linux の <code>LD_PRELOAD</code> や macOS の <code>DYLD_INSERT_LIBRARIES</code> など、さまざまな環境変数やファイルから共有ライブラリの指定された絶対パスをロードします。(引用: TheEvilBit DYLD_INSERT_LIBRARIES)(引用: Timac DYLD_INSERT_LIBRARIES)(引用: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) 環境変数で指定されたライブラリは、同じ関数名のシステムライブラリよりも優先して最初にロードされます。(引用: Man LD.SO)(引用: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) 各プラットフォームのリンカーは、実行のさまざまな時点で環境変数の広範なリストを使用します。これらの変数は、開発者が再コンパイルすることなくバイナリをデバッグしたり、マップされたシンボルの競合を解除したり、元のライブラリにカスタム関数を実装したりするために、しばしば使用される(引用: Baeldung LD_PRELOAD)\n\nダイナミック・リンカー変数をハイジャックすると、被害者プロセスのメモリ、システム/ネットワーク・リソースへのアクセスが許可され、特権が昇格する可能性があります。Linux では、敵対者は <code>LD_PRELOAD<//code> を設定して、被害者プログラムによって要求された正当なライブラリの名前と一致する悪意のあるライブラリを指すようにし、被害者プログラムの実行時にオペレーティングシステムに敵対者の悪意のあるコードをロードさせる可能性があります。例えば、敵は `LD_PRELOAD` を使って `sshd` デーモンのすべての子孫プロセスに悪意のあるライブラリを注入し、結果として正規のプロセスで実行させる。実行中のサブプロセスが `execve` 関数を呼び出すと、ディスク上のシステムライブラリに含まれるシステム関数 `execve` ではなく、悪意のあるライブラリの `execve` 関数が実行される。execve`や`readdir`などのシステム関数をフックすることで、マルウェアが`ls`、`ldd`、`iptables`、`dmesg`などのコマンドの結果から自身のアーティファクトをスクラブすることが可能になるため、敵対者は検出から[アーティファクトを隠す](https://attack.mitre.org/techniques/T1564)ことができる(引用：ESET Ebury Oct 2017)(引用：Intezer Symbiote 2022)(引用：Elastic Security Labs Pumakit 2024)\n\n動的リンカー変数をハイジャックすることで、被害者プロセスのメモリ、システム/ネットワークリソースへのアクセスが許可され、特権が昇格する可能性があります。"
                },
                {
                    "id": "T1574.014",
                    "name_eng": "AppDomainManager",
                    "name_jp": "AppDomainManager",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking how the .NET `AppDomainManager` loads assemblies. The .NET framework uses the `AppDomainManager` class to create and manage one or more isolated runtime environments (called application domains) inside a process to host the execution of .NET applications. Assemblies (`.exe` or `.dll` binaries compiled to run as .NET code) may be loaded into an application domain as executable code.(Citation: Microsoft App Domains) \n\nKnown as \"AppDomainManager injection,\" adversaries may execute arbitrary code by hijacking how .NET applications load assemblies. For example, malware may create a custom application domain inside a target process to load and execute an arbitrary assembly. Alternatively, configuration files (`.config`) or process environment variables that define .NET runtime settings may be tampered with to instruct otherwise benign .NET applications to load a malicious assembly (identified by name) into the target process.(Citation: PenTestLabs AppDomainManagerInject)(Citation: PwC Yellow Liderc)(Citation: Rapid7 AppDomain Manager Injection)",
                    "description_jp": "攻撃者は、.NET の `AppDomainManager` がアセンブリをロードする方法をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。.NETフレームワークは、`AppDomainManager`クラスを使用して、.NETアプリケーションの実行をホストするプロセス内に1つ以上の隔離された実行環境（アプリケーションドメインと呼ばれる）を作成し、管理します。アセンブリ（.NETコードとして実行するためにコンパイルされた`.exe`または`.dll`バイナリ）は、実行可能コードとしてアプリケーションドメインにロードすることができる（引用：Microsoft App Domains）。\n\nAppDomainManagerインジェクション」として知られるこの攻撃は、.NETアプリケーションがアセンブリをロードする方法をハイジャックすることで、任意のコードを実行する可能性があります。例えば、マルウェアはターゲットプロセス内にカスタムアプリケーションドメインを作成し、任意のアセンブリをロードして実行します。あるいは、.NET ランタイム設定を定義する設定ファイル (`.config`) やプロセス環境変数が改ざんされ、悪意のあるアセンブリ (名前で識別される) をターゲットプロセスにロードするよう、良性の .NET アプリケーションに指示することもあります。 (引用: PenTestLabs AppDomainManagerInject) (引用: PwC Yellow Liderc) (引用: Rapid7 AppDomain Manager Injection)"
                },
                {
                    "id": "T1574.001",
                    "name_eng": "DLL",
                    "name_jp": "DLL",
                    "description_eng": "Adversaries may abuse dynamic-link library files (DLLs) in order to achieve persistence, escalate privileges, and evade defenses. DLLs are libraries that contain code and data that can be simultaneously utilized by multiple programs. While DLLs are not malicious by nature, they can be abused through mechanisms such as side-loading, hijacking search order, and phantom DLL hijacking.(Citation: unit 42)\n\nSpecific ways DLLs are abused by adversaries include:\n\n### DLL Sideloading\nAdversaries may execute their own malicious payloads by side-loading DLLs. Side-loading involves hijacking which DLL a program loads by planting and then invoking a legitimate application that executes their payload(s).\n\nSide-loading positions both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.\n\nAdversaries may also side-load other packages, such as BPLs (Borland Package Library).(Citation: kroll bpl)\n\n### DLL Search Order Hijacking\nAdversaries may execute their own malicious payloads by hijacking the search order that Windows uses to load DLLs. This search order is a sequence of special and standard search locations that a program checks when loading a DLL. An adversary can plant a trojan DLL in a directory that will be prioritized by the DLL search order over the location of a legitimate library. This will cause Windows to load the malicious DLL when it is called for by the victim program.(Citation: unit 42)\n\n### DLL Redirection\nAdversaries may directly modify the search order via DLL redirection, which after being enabled (in the Registry or via the creation of a redirection file) may cause a program to load a DLL from a different location.(Citation: Microsoft redirection)(Citation: Microsoft - manifests/assembly)\n\n### Phantom DLL Hijacking\nAdversaries may leverage phantom DLL hijacking by targeting references to non-existent DLL files. They may be able to load their own malicious DLL by planting it with the correct name in the location of the missing module.(Citation: Hexacorn DLL Hijacking)(Citation: Hijack DLLs CrowdStrike)\n\n### DLL Substitution\nAdversaries may target existing, valid DLL files and substitute them with their own malicious DLLs, planting them with the same name and in the same location as the valid DLL file.(Citation: Wietze Beukema DLL Hijacking)\n\nPrograms that fall victim to DLL hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace, evading defenses.\n\nRemote DLL hijacking can occur when a program sets its current directory to a remote location, such as a Web share, before loading a DLL.(Citation: dll pre load owasp)(Citation: microsoft remote preloading)\n\nIf a valid DLL is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation.",
                    "description_jp": "攻撃者は、永続性を実現し、特権を昇格させ、防御を回避するために、ダイナミック・リンク・ライブラリ・ファイル（DLL）を悪用する可能性がある。DLLは、複数のプログラムで同時に利用できるコードとデータを含むライブラリである。DLLは本来悪意のあるものではないが、サイドローディング、検索順序の乗っ取り、ファントムDLLハイジャックなどのメカニズムによって悪用される可能性がある(引用：ユニット42)。\n\nDLLが敵対者によって悪用される具体的な方法には、次のようなものがある：\n\n### DLL サイドローディング\nDLLのサイドローディング 敵は、DLLをサイドローディングすることで、独自の悪意のあるペイロードを実行する可能性があります。サイドローディングは、プログラムがロードする DLL を植え付け、ペイロードを実行する正規のアプリケーションを起動することで、DLL を乗っ取ることを意味します。\n\nサイドローディングは、被害者アプリケーションと悪意のあるペイロードの両方を、互いに隣り合わせに配置します。攻撃者はサイドローディングを、正規の、信頼された、潜在的に昇格されたシステムまたはソフトウェアプロセスの下で実行するアクションを隠す手段として使用している可能性が高いです。ペイロードのサイドローディングに使用される良性の実行ファイルは、配信中や実行中にフラグが立てられない可能性があります。敵対的なペイロードは、信頼されたプロセスのメモリにロードされるまで、暗号化/パックされるか、または他の方法で難読化される可能性もあります。\n\n攻撃者は、BPL (Borland Package Library) などの他のパッケージをサイドロードすることもあります(引用: kroll bpl)。\n\n### DLL 検索順序のハイジャック\n攻撃者は、Windows が DLL をロードする際に使用する検索順序をハイジャックすることで、独自の悪質なペイロードを実行する可能性があります。この検索順序は、DLL をロードする際にプログラムがチェックする、特別な検索場所と標準的な検索場所のシーケンスです。敵対者は、DLLの検索順序によって正当なライブラリの場所よりも優先されるディレクトリに、トロイの木馬のDLLを仕込むことができる。これにより、被害者プログラムによって悪意のあるDLLが呼び出されると、Windowsはそれをロードするようになる(引用：ユニット42)。\n\n### DLL リダイレクト\nDLLリダイレクトは、有効化された後（レジストリまたはリダイレクトファイルの作成により）、プログラムに別の場所からDLLをロードさせる可能性があります。 引用：Microsoft リダイレクト）（引用：Microsoft - manifests/assembly\n\n### ファントム DLL ハイジャック\n攻撃者は、存在しない DLL ファイルへの参照を標的とすることで、ファントム DLL ハイジャックを利用する可能性があります。彼らは、存在しないモジュールの場所に正しい名前で悪意のある DLL を仕込むことで、独自の悪意のある DLL をロードできる可能性があります(引用: Hexacorn DLL ハイジャック)(引用: Hijack DLLs CrowdStrike)\n\n### DLL の置換\n攻撃者は、既存の有効な DLL ファイルを標的にし、有効な DLL ファイルと同じ名前と同じ場所に、自分自身の悪意のある DLL を植え付けることで、DLL を置き換える可能性があります(引用: Wietze Beukema DLL ハイジャック)。\n\nDLLハイジャックの被害に遭ったプログラムは、悪意のあるDLLが正規のDLLも読み込むように設定されているため、防御を回避して正常に動作しているように見えることがある。\n\nリモートDLLハイジャックは、DLLをロードする前にプログラムがカレントディレクトリをWeb共有などのリモートの場所に設定することで発生する可能性がある(引用：DLL pre load owasp)(引用：Microsoft remote preloading)\n\n有効なDLLがより高い特権レベルで実行されるように設定されている場合、ロードされる敵に制御されたDLLもより高いレベルで実行される。この場合、このテクニックは特権の昇格に使われる可能性がある。"
                },
                {
                    "id": "T1574.008",
                    "name_eng": "Path Interception by Search Order Hijacking",
                    "name_jp": "サーチ・オーダー・ハイジャックによる進路妨害",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the search order used to load other programs. Because some programs do not call other programs using the full path, adversaries may place their own file in the directory where the calling program is located, causing the operating system to launch their malicious software at the request of the calling program.\n\nSearch order hijacking occurs when an adversary abuses the order in which Windows searches for programs that are not given a path. Unlike [DLL](https://attack.mitre.org/techniques/T1574/001) search order hijacking, the search order differs depending on the method that is used to execute the program. (Citation: Microsoft CreateProcess) (Citation: Windows NT Command Shell) (Citation: Microsoft WinExec) However, it is common for Windows to search in the directory of the initiating program before searching through the Windows system directory. An adversary who finds a program vulnerable to search order hijacking (i.e., a program that does not specify the path to an executable) may take advantage of this vulnerability by creating a program named after the improperly specified program and placing it within the initiating program's directory.\n\nFor example, \"example.exe\" runs \"cmd.exe\" with the command-line argument <code>net user</code>. An adversary may place a program called \"net.exe\" within the same directory as example.exe, \"net.exe\" will be run instead of the Windows system utility net. In addition, if an adversary places a program called \"net.com\" in the same directory as \"net.exe\", then <code>cmd.exe /C net user</code> will execute \"net.com\" instead of \"net.exe\" due to the order of executable extensions defined under PATHEXT. (Citation: Microsoft Environment Property)\n\nSearch order hijacking is also a common practice for hijacking DLL loads and is covered in [DLL](https://attack.mitre.org/techniques/T1574/001).",
                    "description_jp": "攻撃者は、他のプログラムのロードに使用される検索順序をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性がある。プログラムによってはフルパスで他のプログラムを呼び出さないものもあるため、敵は呼び出し元のプログラムがあるディレクトリに自分のファイルを置き、呼び出し元のプログラムの要求に応じてオペレーティングシステムが悪意のあるソフトウェアを起動するように仕向ける可能性がある。\n\n検索順序のハイジャックは、敵対者がWindowsがパスを与えられていないプログラムを検索する順序を悪用することで発生する。DLL](https://attack.mitre.org/techniques/T1574/001)の検索順ハイジャックとは異なり、検索順はプログラムの実行に使用されるメソッドによって異なります。(引用: Microsoft CreateProcess) (引用: Windows NT Command Shell) (引用: Microsoft WinExec) しかし、WindowsはWindowsシステムディレクトリを検索する前に、開始プログラムのディレクトリを検索するのが一般的である。検索順序のハイジャックに対して脆弱なプログラム（すなわち、実行可能ファイルへのパスを指定しないプログラム）を見つけた敵対者は、不適切に指定されたプログラムにちなんだ名前のプログラムを作成し、それを開始プログラムのディレクトリ内に配置することによって、この脆弱性を利用することができる。\n\n例えば、\"example.exe \"はコマンドライン引数<code>net user</code>で \"cmd.exe \"を実行する。敵対者がexample.exeと同じディレクトリに「net.exe」というプログラムを置くと、「net.exe」はWindowsのシステムユーティリティ「net」の代わりに実行される。さらに、敵が「net.com」と呼ばれるプログラムを「net.exe」と同じディレクトリに置いた場合、<code>cmd.exe /C net user</code>は、PATHEXTで定義された実行可能な拡張子の順序により、「net.exe」の代わりに「net.com」を実行する。(引用: Microsoft Environment Property)\n\n検索順のハイジャックもDLLのロードをハイジャックするための一般的な方法で、[DLL](https://attack.mitre.org/techniques/T1574/001)でカバーされています。"
                },
                {
                    "id": "T1574.011",
                    "name_eng": "Services Registry Permissions Weakness",
                    "name_jp": "サービス レジストリ パーミッションの脆弱性",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the Registry entries used by services. Adversaries may use flaws in the permissions for Registry keys related to services to redirect from the originally specified executable to one that they control, in order to launch their own code when a service starts. Windows stores local service configuration information in the Registry under <code>HKLM\\SYSTEM\\CurrentControlSet\\Services</code>. The information stored under a service's Registry keys can be manipulated to modify a service's execution parameters through tools such as the service controller, sc.exe,  [PowerShell](https://attack.mitre.org/techniques/T1059/001), or [Reg](https://attack.mitre.org/software/S0075). Access to Registry keys is controlled through access control lists and user permissions. (Citation: Registry Key Security)(Citation: malware_hides_service)\n\nIf the permissions for users and groups are not properly set and allow access to the Registry keys for a service, adversaries may change the service's binPath/ImagePath to point to a different executable under their control. When the service starts or is restarted, then the adversary-controlled program will execute, allowing the adversary to establish persistence and/or privilege escalation to the account context the service is set to execute under (local/domain account, SYSTEM, LocalService, or NetworkService).\n\nAdversaries may also alter other Registry keys in the service’s Registry tree. For example, the <code>FailureCommand</code> key may be changed so that the service is executed in an elevated context anytime the service fails or is intentionally corrupted.(Citation: Kansa Service related collectors)(Citation: Tweet Registry Perms Weakness)\n\nThe <code>Performance</code> key contains the name of a driver service's performance DLL and the names of several exported functions in the DLL.(Citation: microsoft_services_registry_tree) If the <code>Performance</code> key is not already present and if an adversary-controlled user has the <code>Create Subkey</code> permission, adversaries may create the <code>Performance</code> key in the service’s Registry tree to point to a malicious DLL.(Citation: insecure_reg_perms)\n\nAdversaries may also add the <code>Parameters</code> key, which stores driver-specific data, or other custom subkeys for their malicious services to establish persistence or enable other malicious activities.(Citation: microsoft_services_registry_tree)(Citation: troj_zegost) Additionally, If adversaries launch their malicious services using svchost.exe, the service’s file may be identified using <code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\servicename\\Parameters\\ServiceDll</code>.(Citation: malware_hides_service)",
                    "description_jp": "攻撃者は、サービスが使用するレジストリ・エントリをハイジャックすることで、独自の悪意のあるペイロードを実行する可能性がある。攻撃者は、サービスに関連するレジストリ キーのパーミッションの欠陥を利用して、サービスの起動時に独自のコードを起動するために、本来指定されている実行可能ファイルから自分たちが制御する実行可能ファイルへとリダイレクトする可能性がある。Windowsは、レジストリの<code>HKLMMAPCESTMACCurrentControllServices</code>の下にローカルサービスのコンフィギュレーション情報を格納します。サービスのレジストリキーの下に格納された情報は、サービスコントローラー、sc.exe、[PowerShell](https://attack.mitre.org/techniques/T1059/001)、または[Reg](https://attack.mitre.org/software/S0075)のようなツールを使って、サービスの実行パラメーターを変更するために操作することができる。レジストリ・キーへのアクセスは、アクセス制御リストとユーザー権限によって制御される。(引用：レジストリキーのセキュリティ）（引用：malware_hides_service）\n\nユーザーやグループのパーミッションが適切に設定されておらず、サービスのレジストリ・キーへのアクセスを許可している場合、敵対者はサービスのbinPath/ImagePathを変更し、自分のコントロール下にある別の実行ファイルを指すようにする可能性があります。サービスが開始または再起動されると、敵が制御するプログラムが実行され、サービスが実行されるように設定されたアカウントコンテキスト（ローカル/ドメインアカウント、SYSTEM、LocalService、またはNetworkService）への永続化および/または特権昇格が可能になります。\n\n逆境者はまた、サービスのレジストリツリー内の他のレジストリキーを変更する可能性があります。たとえば、<code>FailureCommand</code>キーが変更され、サービスに障害が発生したり、サービスが意図的に破損したりした場合に、いつでも昇格したコンテキストでサービスが実行されるようにすることができる。 引用：Kansa サービス関連コレクター）（引用：Tweet Registry Perms Weakness\n\n<code>Performance</code>キーには、ドライバ サービスのパフォーマンス DLL の名前と、DLL 内のいくつかのエクスポートされた関数の名前が含まれます。(引用: microsoft_services_registry_tree) <code>Performance</code> キーがまだ存在せず、敵に制御されたユーザーが <code>Create Subkey</code> 権限を持っている場合、敵はサービスのレジストリ ツリーに悪意のある DLL を指す <code>Performance</code> キーを作成する可能性があります。\n\nまた、ドライバ固有のデータを格納する <code>Parameters</code> キーや、その他のカスタム サブキーを悪意のあるサービスに追加して、永続性を確立したり、その他の悪意のある活動を可能にしたりすることもできます。(引用: microsoft_services_registry_tree)(引用: troj_zegost) さらに、敵対者が svchost.exe を使用して悪意のあるサービスを起動する場合、サービスのファイルは <code>HKEY_LOCAL_MACHINESYSTEM\\CurrentControlSet\\Servicesservicename\\Parameters\\ServiceDll</code> を使用して識別される可能性があります(引用: malware_hides_service)。"
                },
                {
                    "id": "T1574.012",
                    "name_eng": "COR_PROFILER",
                    "name_jp": "COR_PROFILER",
                    "description_eng": "Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)\n\nThe COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a [Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.(Citation: Microsoft COR_PROFILER Feb 2013)\n\nAdversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)) if the victim .NET process executes at a higher permission level, as well as to hook and [Impair Defenses](https://attack.mitre.org/techniques/T1562) provided by .NET processes.(Citation: RedCanary Mockingbird May 2020)(Citation: Red Canary COR_PROFILER May 2020)(Citation: Almond COR_PROFILER Apr 2019)(Citation: GitHub OmerYa Invisi-Shell)(Citation: subTee .NET Profilers May 2017)",
                    "description_jp": "攻撃者は COR_PROFILER 環境変数を利用して、.NET CLR をロードするプログラムの実行フローを乗っ取る可能性があります。COR_PROFILERは.NET Frameworkの機能で、開発者は共通言語ランタイム（CLR）をロードする各.NETプロセスにロードされるアンマネージド（または.NETの外部）プロファイリングDLLを指定できます。これらのプロファイラーは、.NET CLRで実行されるマネージドコードを監視、トラブルシューティング、デバッグするために設計されています。(引用: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)\n\nCOR_PROFILER 環境変数は、さまざまなスコープ（システム、ユーザー、またはプロセス）で設定でき、その結果、影響力のレベルが異なります。システムおよびユーザー全体の環境変数スコープは、[Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) オブジェクトをプロファイラ DLL として登録できるレジストリで指定されます。プロセススコープCOR_PROFILERは、レジストリを変更することなくメモリ内に作成することもできます。.NET Framework 4からは、COR_PROFILER_PATH環境変数にDLLの場所が指定されていれば、プロファイリングDLLを登録する必要はありません（引用：Microsoft COR_PROFILER 2013年2月）。\n\n攻撃者はCOR_PROFILERを悪用して、CLRが呼び出されるたびにすべての.NETプロセスのコンテキストで悪意のあるDLLを実行する永続性を確立する可能性があります。また、COR_PROFILERは、被害者である.NETプロセスがより高い権限レベルで実行されている場合、権限の昇格（例：[Bypass User Account Control]（https://attack.mitre.org/techniques/T1548/002））や、フックおよび[Impair Defenses]（https://attack。mitre.org/techniques/T1562).NETプロセスによって提供される。(引用: RedCanary Mockingbird 2020年5月)(引用: Red Canary COR_PROFILER 2020年5月)(引用: Almond COR_PROFILER 2019年4月)(引用: GitHub OmerYa Invisi-Shell)(引用: subTee .NET Profilers 2017年5月)"
                }
            ]
        },
        {
            "id": "T1078",
            "name_eng": "Valid Accounts",
            "name_jp": "有効なアカウント",
            "description_eng": "Adversaries may obtain and abuse credentials of existing accounts as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Compromised credentials may be used to bypass access controls placed on various resources on systems within the network and may even be used for persistent access to remote systems and externally available services, such as VPNs, Outlook Web Access, network devices, and remote desktop.(Citation: volexity_0day_sophos_FW) Compromised credentials may also grant an adversary increased privilege to specific systems or access to restricted areas of the network. Adversaries may choose not to use malware or tools in conjunction with the legitimate access those credentials provide to make it harder to detect their presence.\n\nIn some cases, adversaries may abuse inactive accounts: for example, those belonging to individuals who are no longer part of an organization. Using these accounts may allow the adversary to evade detection, as the original account user will not be present to identify any anomalous activity taking place on their account.(Citation: CISA MFA PrintNightmare)\n\nThe overlap of permissions for local, domain, and cloud accounts across a network of systems is of concern because the adversary may be able to pivot across accounts and systems to reach a high level of access (i.e., domain or enterprise administrator) to bypass access controls set within the enterprise.(Citation: TechNet Credential Theft)",
            "description_jp": "攻撃者は、初期アクセス、永続性、特権のエスカレーション、または防御回避を獲得する手段として、 既存のアカウントのクレデンシャルを入手して悪用する可能性がある。また、VPN、Outlook Web Access、ネットワーク・デバイス、リモート・デスクトップなど、リモート・システムや外部で利用可能なサービスへの永続的なアクセスに使用される可能性もあります（引用：volexity_0day_sophos_FW）。敵対者は、その存在を検出しにくくするために、これらの認証情報が提供する正当なアクセスとともにマルウェアやツールを使用しないことを選択する可能性があります。\n\n場合によっては、敵対者は非アクティブなアカウントを悪用することがある。このようなアカウントを使用することで、敵対者は検知を逃れることができるかもしれない。\n\n敵対者は、企業内で設定されたアクセス制御を迂回するために、アカウントやシステムを跨いで高レ ベルのアクセス（ドメイン管理者または企業管理者）に到達することができる可能性があるため、シス テムのネットワーク全体でローカル、ドメイン、クラウドの各アカウントの権限が重複していることが懸念さ れる（引用：TechNet Credential Theft）。",
            "subtechniques": [
                {
                    "id": "T1078.004",
                    "name_eng": "Cloud Accounts",
                    "name_jp": "クラウド口座",
                    "description_eng": "Valid accounts in cloud environments may allow adversaries to perform actions to achieve Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Cloud accounts are those created and configured by an organization for use by users, remote support, services, or for administration of resources within a cloud service provider or SaaS application. Cloud Accounts can exist solely in the cloud; alternatively, they may be hybrid-joined between on-premises systems and the cloud through syncing or federation with other identity sources such as Windows Active Directory.(Citation: AWS Identity Federation)(Citation: Google Federating GC)(Citation: Microsoft Deploying AD Federation)\n\nService or user accounts may be targeted by adversaries through [Brute Force](https://attack.mitre.org/techniques/T1110), [Phishing](https://attack.mitre.org/techniques/T1566), or various other means to gain access to the environment. Federated or synced accounts may be a pathway for the adversary to affect both on-premises systems and cloud environments - for example, by leveraging shared credentials to log onto [Remote Services](https://attack.mitre.org/techniques/T1021). High privileged cloud accounts, whether federated, synced, or cloud-only, may also allow pivoting to on-premises environments by leveraging SaaS-based [Software Deployment Tools](https://attack.mitre.org/techniques/T1072) to run commands on hybrid-joined devices.\n\nAn adversary may create long lasting [Additional Cloud Credentials](https://attack.mitre.org/techniques/T1098/001) on a compromised cloud account to maintain persistence in the environment. Such credentials may also be used to bypass security controls such as multi-factor authentication. \n\nCloud accounts may also be able to assume [Temporary Elevated Cloud Access](https://attack.mitre.org/techniques/T1548/005) or other privileges through various means within the environment. Misconfigurations in role assignments or role assumption policies may allow an adversary to use these mechanisms to leverage permissions outside the intended scope of the account. Such over privileged accounts may be used to harvest sensitive data from online storage accounts and databases through [Cloud API](https://attack.mitre.org/techniques/T1059/009) or other methods. For example, in Azure environments, adversaries may target Azure Managed Identities, which allow associated Azure resources to request access tokens. By compromising a resource with an attached Managed Identity, such as an Azure VM, adversaries may be able to [Steal Application Access Token](https://attack.mitre.org/techniques/T1528)s to move laterally across the cloud environment.(Citation: SpecterOps Managed Identity 2022)",
                    "description_jp": "クラウド環境における有効なアカウントは、敵対者が初期アクセス、永続性、特権の昇格、または防御回避を達成するためのアクションを実行することを可能にする可能性がある。クラウドアカウントは、ユーザ、リモートサポート、サービス、またはクラウドサービスプロバイダや SaaS アプリケーション内のリソースの管理のために、組織によって作成され設定される。クラウド・アカウントは、クラウドのみに存在することもできるが、Windows Active Directory などの他の ID ソースとの同期またはフェデレーションによって、オンプレミス・システムとクラウドの間でハイブリッドに結合されることもある（引用：AWS Identity Federation）。\n\nブルートフォース](https://attack.mitre.org/techniques/T1110)、[フィッシング](https://attack.mitre.org/techniques/T1566)、または環境にアクセスするための他のさまざまな手段によって、サービスまたはユーザーアカウントが敵に狙われる可能性がある。フェデレートされたアカウントや同期されたアカウントは、敵がオンプレミスシステムとクラウド環境の両方に影響を与える経路となる可能性があります。例えば、共有された認証情報を活用して[リモートサービス](https://attack.mitre.org/techniques/T1021)にログオンすることが挙げられます。高権限のクラウド・アカウントは、連携、同期、クラウド専用のいずれであっても、SaaSベースの[Software Deployment Tools](https://attack.mitre.org/techniques/T1072)を活用してハイブリッド接続されたデバイス上でコマンドを実行することで、オンプレミス環境へのピボットを可能にする可能性もある。\n\n敵対者は、侵害されたクラウドアカウントで長期間の[追加クラウド・クレデンシャル](https://attack.mitre.org/techniques/T1098/001)を作成し、環境での永続性を維持する可能性があります。このようなクレデンシャルは、多要素認証のようなセキュリティ制御をバイパスするためにも使用されるかもしれません。\n\nクラウドアカウントはまた、環境内の様々な手段を通じて[Temporary Elevated Cloud Access](https://attack.mitre.org/techniques/T1548/005)やその他の特権を引き受けることができるかもしれません。役割の割り当てや役割の引き受けポリシーの設定を誤ると、敵対者はこれらのメカニズムを使用して、アカウントの意図された範囲外の権限を活用することができます。そのような過剰な権限を持つアカウントは、[Cloud API](https://attack.mitre.org/techniques/T1059/009)または他の方法を通じて、オンラインストレージアカウントやデータベースから機密データを採取するために使用される可能性がある。例えば、Azure環境では、敵対者は、関連するAzureリソースがアクセストークンを要求できるようにするAzure Managed Identityを標的にする可能性があります。敵対者は、Azure VM などのマネージド ID がアタッチされたリソースを侵害することで、[Steal Application Access Token](https://attack.mitre.org/techniques/T1528) を使用してクラウド環境を横方向に移動できるようになる可能性があります。（引用：SpecterOps Managed Identity 2022）"
                },
                {
                    "id": "T1078.002",
                    "name_eng": "Domain Accounts",
                    "name_jp": "ドメインアカウント",
                    "description_eng": "Adversaries may obtain and abuse credentials of a domain account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion.(Citation: TechNet Credential Theft) Domain accounts are those managed by Active Directory Domain Services where access and permissions are configured across systems and services that are part of that domain. Domain accounts can cover users, administrators, and services.(Citation: Microsoft AD Accounts)\n\nAdversaries may compromise domain accounts, some with a high level of privileges, through various means such as [OS Credential Dumping](https://attack.mitre.org/techniques/T1003) or password reuse, allowing access to privileged resources of the domain.",
                    "description_jp": "ドメインアカウントは、Active Directory ドメインサービスによって管理され、そのドメインの一部であるシス テムやサービス全体にわたってアクセスや権限が設定される(引用：Microsoft AD Accounts)。ドメインアカウントには、ユーザー、管理者、サービスが含まれる。\n\n攻撃者は、[OS Credential Dumping](https://attack.mitre.org/techniques/T1003)やパスワードの再利用など、さまざまな手段でドメインアカウント(一部は高水準の特権を持つ)を侵害し、ドメインの特権リソースへのアクセスを許可する可能性がある。"
                },
                {
                    "id": "T1078.003",
                    "name_eng": "Local Accounts",
                    "name_jp": "ローカルアカウント",
                    "description_eng": "Adversaries may obtain and abuse credentials of a local account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Local accounts are those configured by an organization for use by users, remote support, services, or for administration on a single system or service.\n\nLocal Accounts may also be abused to elevate privileges and harvest credentials through [OS Credential Dumping](https://attack.mitre.org/techniques/T1003). Password reuse may allow the abuse of local accounts across a set of machines on a network for the purposes of Privilege Escalation and Lateral Movement.",
                    "description_jp": "攻撃者は、初期アクセス、永続性、特権のエスカレーション、または防御の回避を得る手段として、ロー カルアカウントの認証情報を入手し、悪用する可能性がある。ローカル・アカウントは、ユーザ、リモート・サポート、サービス、または単一のシステムまたはサービス上の管 理用に組織によって構成されたものである。\n\nローカルアカウントは、[OS Credential Dumping](https://attack.mitre.org/techniques/T1003)によって特権を昇格させ、資格情報を採取するために悪用される可能性もあります。パスワードの再利用は、特権の昇格と横移動の目的で、ネットワーク上の一連のマシンにまたがるローカルアカウントの悪用を許すかもしれない。"
                },
                {
                    "id": "T1078.001",
                    "name_eng": "Default Accounts",
                    "name_jp": "デフォルト口座",
                    "description_eng": "Adversaries may obtain and abuse credentials of a default account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Default accounts are those that are built-into an OS, such as the Guest or Administrator accounts on Windows systems. Default accounts also include default factory/provider set accounts on other types of systems, software, or devices, including the root user account in AWS, the root user account in ESXi, and the default service account in Kubernetes.(Citation: Microsoft Local Accounts Feb 2019)(Citation: AWS Root User)(Citation: Threat Matrix for Kubernetes)\n\nDefault accounts are not limited to client machines; rather, they also include accounts that are preset for equipment such as network devices and computer applications, whether they are internal, open source, or commercial. Appliances that come preset with a username and password combination pose a serious threat to organizations that do not change it post installation, as they are easy targets for an adversary. Similarly, adversaries may also utilize publicly disclosed or stolen [Private Keys](https://attack.mitre.org/techniques/T1552/004) or credential materials to legitimately connect to remote environments via [Remote Services](https://attack.mitre.org/techniques/T1021).(Citation: Metasploit SSH Module)\n\nDefault accounts may be created on a system after initial setup by connecting or integrating it with another application. For example, when an ESXi server is connected to a vCenter server, a default privileged account called `vpxuser` is created on the ESXi server. If a threat actor is able to compromise this account’s credentials (for example, via [Exploitation for Credential Access](https://attack.mitre.org/techniques/T1212) on the vCenter host), they will then have access to the ESXi server.(Citation: Google Cloud Threat Intelligence VMWare ESXi Zero-Day 2023)(Citation: Pentera vCenter Information Disclosure)",
                    "description_jp": "攻撃者は、初期アクセス、永続性、特権の昇格、または防御回避を獲得する手段として、デフォルト・ アカウントの認証情報を入手し、悪用する可能性がある。デフォルトアカウントとは、Windows システムの Guest や Administrator アカウントなど、OS に組み込まれたアカウントのことである。デフォルトアカウントには、AWSのルートユーザーアカウント、ESXiのルートユーザーアカウント、Kubernetesのデフォルトのサービスアカウントなど、他の種類のシステム、ソフトウェア、デバイスのデフォルトのファクトリー/プロバイダセットアカウントも含まれる。 引用：Microsoft Local Accounts Feb 2019）（引用：AWS Root User）（引用：Threat Matrix for Kubernetes\n\nデフォルトアカウントはクライアントマシンに限らず、社内、オープンソース、商用を問わず、ネットワーク機器やコンピュータアプリケーションなどの機器にプリセットされているアカウントも含まれる。ユーザー名とパスワードの組み合わせがあらかじめ設定されているアプライアンスは、インストール後に変更しない組織にとって、敵対者にとって格好の標的となるため、深刻な脅威となる。同様に、敵は一般に公開された、あるいは盗まれた[秘密鍵](https://attack.mitre.org/techniques/T1552/004)やクレデンシャルを利用して、[リモートサービス](https://attack.mitre.org/techniques/T1021)を介してリモート環境に合法的に接続することもできます。(引用：Metasploit SSH Module)\n\nデフォルトアカウントは、初期セットアップ後に他のアプリケーションと接続したり統合したりすることで、システム上に 作成される可能性があります。例えば、ESXi サーバが vCenter サーバに接続されると、ESXi サーバ上に `vpxuser` というデフォルトの特権アカウントが作成されます。例えば、vCenterホスト上で[Exploitation for Credential Access](https://attack.mitre.org/techniques/T1212)を使用するなどして、このアカウントの認証情報を侵害することができれば、ESXiサーバにアクセスできるようになります。(引用：Google Cloud Threat Intelligence VMWare ESXi Zero-Day 2023)(引用：Pentera vCenter Information Disclosure)"
                }
            ]
        },
        {
            "id": "T1546",
            "name_eng": "Event Triggered Execution",
            "name_jp": "イベントトリガー実行",
            "description_eng": "Adversaries may establish persistence and/or elevate privileges using system mechanisms that trigger execution based on specific events. Various operating systems have means to monitor and subscribe to events such as logons or other user activity such as running specific applications/binaries. Cloud environments may also support various functions and services that monitor and can be invoked in response to specific cloud events.(Citation: Backdooring an AWS account)(Citation: Varonis Power Automate Data Exfiltration)(Citation: Microsoft DART Case Report 001)\n\nAdversaries may abuse these mechanisms as a means of maintaining persistent access to a victim via repeatedly executing malicious code. After gaining access to a victim system, adversaries may create/modify event triggers to point to malicious content that will be executed whenever the event trigger is invoked.(Citation: FireEye WMI 2015)(Citation: Malware Persistence on OS X)(Citation: amnesia malware)\n\nSince the execution can be proxied by an account with higher permissions, such as SYSTEM or service accounts, an adversary may be able to abuse these triggered execution mechanisms to escalate their privileges.",
            "description_jp": "攻撃者は、特定のイベントに基づいて実行をトリガーするシステムメカニズムを使って、永続性を確立したり、特権を昇格させたりする可能性があります。様々なオペレーティングシステムは、ログオンなどのイベントや、特定のアプリケーション/バイナリの実行などのユーザーアクティビティを監視し、サブスクライブする手段を備えている。クラウド環境はまた、特定のクラウドイベントを監視し、それに応じて呼び出すことができる様々な機能やサービスをサポートしている場合があります。 引用：AWSアカウントのバックドア）（引用：Varonis Power Automate Data Exfiltration）（引用：Microsoft DART Case Report 001\n\n攻撃者は、悪意のあるコードを繰り返し実行することで、被害者への持続的なアクセスを維持する手段として、これらのメカニズムを悪用する可能性があります。被害者システムへのアクセスを獲得した後、敵対者はイベントトリガーを作成/変更し、イベントトリガーが呼び出されるたびに実行される悪意のあるコンテンツを指すようにする可能性があります(引用: FireEye WMI 2015)(Citation: Malware Persistence on OS X)(Citation: amnesia malware)\n\n実行は、SYSTEMやサービスアカウントなど、より高い権限を持つアカウントによってプロキシされる可能性があるため、敵対者はこれらのトリガー実行メカニズムを悪用して特権をエスカレートできる可能性があります。",
            "subtechniques": [
                {
                    "id": "T1546.002",
                    "name_eng": "Screensaver",
                    "name_jp": "スクリーンセーバー",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by user inactivity. Screensavers are programs that execute after a configurable time of user inactivity and consist of Portable Executable (PE) files with a .scr file extension.(Citation: Wikipedia Screensaver) The Windows screensaver application scrnsave.scr is located in <code>C:\\Windows\\System32\\</code>, and <code>C:\\Windows\\sysWOW64\\</code>  on 64-bit Windows systems, along with screensavers included with base Windows installations.\n\nThe following screensaver settings are stored in the Registry (<code>HKCU\\Control Panel\\Desktop\\</code>) and could be manipulated to achieve persistence:\n\n* <code>SCRNSAVE.exe</code> - set to malicious PE path\n* <code>ScreenSaveActive</code> - set to '1' to enable the screensaver\n* <code>ScreenSaverIsSecure</code> - set to '0' to not require a password to unlock\n* <code>ScreenSaveTimeout</code> - sets user inactivity timeout before screensaver is executed\n\nAdversaries can use screensaver settings to maintain persistence by setting the screensaver to run malware after a certain timeframe of user inactivity.(Citation: ESET Gazer Aug 2017)",
                    "description_jp": "攻撃者は、ユーザーの非アクティブをトリガーに悪意のあるコンテンツを実行することで、永続性を確立する可能性があります。スクリーンセーバーは、設定可能な無操作時間の後に実行されるプログラムであり、.scr ファイル拡張子を持つ Portable Executable (PE) ファイルで構成される。(引用: Wikipedia スクリーンセーバー) Windows スクリーンセーバーアプリケーション scrnsave.scr は、基本 Windows インストールに含まれるスクリーンセーバーと共に、<code>C:¥WindowsSystem32</code>、64 ビット Windows システムでは <code>C:¥WindowssysWOW64</code> に配置される。\n\n以下のスクリーンセーバー設定はレジストリ（<code>HKCU</code>Control Panel</code>Desktop</code>）に保存されており、永続化を実現するために操作される可能性があります：\n\n<code>SCRNSAVE.exe<//code> - 悪意のあるPEパスに設定されます。\n<code>ScreenSaveActive</code> - スクリーンセーバーを有効にするために「1」に設定されます。\n<code>ScreenSaverIsSecure</code> - ロック解除にパスワードを必要としないように '0' に設定します。\n<code>ScreenSaveTimeout</code> - スクリーンセーバーが実行される前に、ユーザの非アクティブ時のタイムアウトを設定します。\n\n攻撃者は、スクリーンセーバーの設定を利用して、ユーザーが一定時間操作を行わなかった後にマルウェアを実行するように設定することで、永続性を維持することができます(引用：ESET Gazer 2017年8月号)"
                },
                {
                    "id": "T1546.013",
                    "name_eng": "PowerShell Profile",
                    "name_jp": "PowerShellプロファイル",
                    "description_eng": "Adversaries may gain persistence and elevate privileges by executing malicious content triggered by PowerShell profiles. A PowerShell profile  (<code>profile.ps1</code>) is a script that runs when [PowerShell](https://attack.mitre.org/techniques/T1059/001) starts and can be used as a logon script to customize user environments.\n\n[PowerShell](https://attack.mitre.org/techniques/T1059/001) supports several profiles depending on the user or host program. For example, there can be different profiles for [PowerShell](https://attack.mitre.org/techniques/T1059/001) host programs such as the PowerShell console, PowerShell ISE or Visual Studio Code. An administrator can also configure a profile that applies to all users and host programs on the local computer. (Citation: Microsoft About Profiles) \n\nAdversaries may modify these profiles to include arbitrary commands, functions, modules, and/or [PowerShell](https://attack.mitre.org/techniques/T1059/001) drives to gain persistence. Every time a user opens a [PowerShell](https://attack.mitre.org/techniques/T1059/001) session the modified script will be executed unless the <code>-NoProfile</code> flag is used when it is launched. (Citation: ESET Turla PowerShell May 2019) \n\nAn adversary may also be able to escalate privileges if a script in a PowerShell profile is loaded and executed by an account with higher privileges, such as a domain administrator. (Citation: Wits End and Shady PowerShell Profiles)",
                    "description_jp": "攻撃者は、PowerShell プロファイルをトリガーとして悪意のあるコンテンツを実行することで、永続性を獲得し、特権を昇格させる可能性があります。PowerShellプロファイル（<code>profile.ps1</code>）は、[PowerShell](https://attack.mitre.org/techniques/T1059/001)の起動時に実行されるスクリプトで、ユーザー環境をカスタマイズするためのログオンスクリプトとして使用できます。\n\n[PowerShell](https://attack.mitre.org/techniques/T1059/001)は、ユーザーやホストプログラムに応じた複数のプロファイルをサポートしています。たとえば、PowerShell コンソール、PowerShell ISE、Visual Studio Code など、[PowerShell](https://attack.mitre.org/techniques/T1059/001) ホスト・プログラムごとに異なるプロファイルを設定できます。管理者は、ローカル コンピュータ上のすべてのユーザーとホスト プログラムに適用されるプロファイルを構成することもできます。(引用: Microsoft プロファイルについて)\n\n攻撃者はこれらのプロファイルを変更し、任意のコマンド、関数、モジュール、および/または[PowerShell](https://attack.mitre.org/techniques/T1059/001)ドライブを含めることで、永続性を得ることができます。ユーザーが [PowerShell](https://attack.mitre.org/techniques/T1059/001) セッションを開くたびに、起動時に <code>-NoProfile</code> フラグが使用されていない限り、変更されたスクリプトが実行されます。(引用: ESET Turla PowerShell 2019年5月号)\n\nまた、PowerShellプロファイル内のスクリプトがロードされ、ドメイン管理者などのより高い権限を持つアカウントによって実行された場合、敵対者は権限をエスカレートできる可能性があります。(引用: Wits End and Shady PowerShell Profiles)"
                },
                {
                    "id": "T1546.016",
                    "name_eng": "Installer Packages",
                    "name_jp": "インストーラ・パッケージ",
                    "description_eng": "Adversaries may establish persistence and elevate privileges by using an installer to trigger the execution of malicious content. Installer packages are OS specific and contain the resources an operating system needs to install applications on a system. Installer packages can include scripts that run prior to installation as well as after installation is complete. Installer scripts may inherit elevated permissions when executed. Developers often use these scripts to prepare the environment for installation, check requirements, download dependencies, and remove files after installation.(Citation: Installer Package Scripting Rich Trouton)\n\nUsing legitimate applications, adversaries have distributed applications with modified installer scripts to execute malicious content. When a user installs the application, they may be required to grant administrative permissions to allow the installation. At the end of the installation process of the legitimate application, content such as macOS `postinstall` scripts can be executed with the inherited elevated permissions. Adversaries can use these scripts to execute a malicious executable or install other malicious components (such as a [Launch Daemon](https://attack.mitre.org/techniques/T1543/004)) with the elevated permissions.(Citation: Application Bundle Manipulation Brandon Dalton)(Citation: wardle evilquest parti)(Citation: Windows AppleJeus GReAT)(Citation: Debian Manual Maintainer Scripts)\n\nDepending on the distribution, Linux versions of package installer scripts are sometimes called maintainer scripts or post installation scripts. These scripts can include `preinst`, `postinst`, `prerm`, `postrm` scripts and run as root when executed.\n\nFor Windows, the Microsoft Installer services uses `.msi` files to manage the installing, updating, and uninstalling of applications. These installation routines may also include instructions to perform additional actions that may be abused by adversaries.(Citation: Microsoft Installation Procedures)",
                    "description_jp": "攻撃者は、インストーラを使用して悪意のあるコンテンツを実行させることで、永続性を確立し、特権を昇格させる可能性があります。インストーラパッケージはOS固有のものであり、オペレーティングシステムがシステムにアプリケーションをインストールするために必要なリソースを含んでいます。インストーラパッケージには、インストール前に実行されるスクリプトと、インストール完了後に実行されるスクリプトが含まれることがあります。インストーラスクリプトは、実行時に昇格権限を継承する場合があります。開発者は多くの場合、これらのスクリプトを使用して、インストール環境の準備、要件の確認、依存関係のダウンロード、インストール後のファイルの削除を行います。 (引用: インストーラパッケージスクリプティング Rich Trouton)\n\n敵対者は、正規のアプリケーションを使用して、悪意のあるコンテンツを実行するようにインストーラスクリプトを変更したアプリケーションを配布しています。ユーザがアプリケーションをインストールする際、インストールを許可するために管理者権限を付与する必要がある場合があります。正規のアプリケーションのインストールプロセスの最後に、macOS の `postinstall` スクリプトなどのコンテンツが、継承された昇格権限で実行される可能性があります。攻撃者はこれらのスクリプトを使用して、悪意のある実行ファイルを実行したり、昇格した権限で他の悪意のあるコンポーネント（[Launch Daemon](https://attack.mitre.org/techniques/T1543/004)など）をインストールしたりすることができます。（引用：Application Bundle Manipulation Brandon Dalton）（引用：wardle evilquest parti）（引用：Windows AppleJeus GReAT）（引用：Debian Manual Maintainer Scripts）\n\nディストリビューションによっては、Linux版のパッケージインストーラスクリプトは、メンテナースクリプトやポストインストールスクリプトと呼ばれることもあります。これらのスクリプトには `preinst`、`postinst`、`prerm`、`postrm` スクリプトが含まれ、実行時には root として実行されます。\n\nWindows の場合、Microsoft Installer サービスはアプリケーションのインストー ル、アップデート、アンインストールを管理するために `.msi` ファイルを使用します。これらのインストールルーチンには、敵対者に悪用される可能性のある追加アクションを実行する指示が含まれていることもあります。(引用: Microsoft Installation Procedures)"
                },
                {
                    "id": "T1546.003",
                    "name_eng": "Windows Management Instrumentation Event Subscription",
                    "name_jp": "Windows Management Instrumentation イベントサブスクリプション",
                    "description_eng": "Adversaries may establish persistence and elevate privileges by executing malicious content triggered by a Windows Management Instrumentation (WMI) event subscription. WMI can be used to install event filters, providers, consumers, and bindings that execute code when a defined event occurs. Examples of events that may be subscribed to are the wall clock time, user login, or the computer's uptime.(Citation: Mandiant M-Trends 2015)\n\nAdversaries may use the capabilities of WMI to subscribe to an event and execute arbitrary code when that event occurs, providing persistence on a system.(Citation: FireEye WMI SANS 2015)(Citation: FireEye WMI 2015) Adversaries may also compile WMI scripts – using `mofcomp.exe`  –into Windows Management Object (MOF) files (.mof extension) that can be used to create a malicious subscription.(Citation: Dell WMI Persistence)(Citation: Microsoft MOF May 2018)\n\nWMI subscription execution is proxied by the WMI Provider Host process (WmiPrvSe.exe) and thus may result in elevated SYSTEM privileges.",
                    "description_jp": "攻撃者は、Windows Management Instrumentation (WMI)イベントサブスクリプションによってトリガーされる悪意のあるコンテンツを実行することで、永続性を確立し、特権を昇格させる可能性があります。WMIは、定義されたイベントが発生したときにコードを実行するイベントフィルター、プロバイダー、コンシューマー、バインディングをインストールするために使用することができる。サブスクライブされるイベントの例としては、壁掛け時計の時刻、ユーザーログイン、コンピュータの稼働時間などが挙げられます（引用：Mandiant M-Trends 2015）。\n\n攻撃者は、WMIの機能を使用してイベントをサブスクライブし、そのイベントが発生したときに任意のコードを実行し、システム上に永続性を提供する可能性があります(引用: FireEye WMI SANS 2015)(引用: FireEye WMI 2015) また、攻撃者は、`mofcomp.exe`を使用して、悪意のあるサブスクリプションを作成するために使用できるWindows Management Object (MOF) ファイル(.mof 拡張子)にWMIスクリプトをコンパイルする可能性があります(引用: Dell WMI Persistence)(引用: Microsoft MOF May 2018)\n\nWMI サブスクリプションの実行は、WMI Provider Host プロセス (WmiPrvSe.exe) によってプロキシされるため、SYSTEM 権限が昇格する可能性があります。"
                },
                {
                    "id": "T1546.006",
                    "name_eng": "LC_LOAD_DYLIB Addition",
                    "name_jp": "LC_LOAD_DYLIB 追加",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by the execution of tainted binaries. Mach-O binaries have a series of headers that are used to perform certain operations when a binary is loaded. The LC_LOAD_DYLIB header in a Mach-O binary tells macOS and OS X which dynamic libraries (dylibs) to load during execution time. These can be added ad-hoc to the compiled binary as long as adjustments are made to the rest of the fields and dependencies.(Citation: Writing Bad Malware for OSX) There are tools available to perform these changes.\n\nAdversaries may modify Mach-O binary headers to load and execute malicious dylibs every time the binary is executed. Although any changes will invalidate digital signatures on binaries because the binary is being modified, this can be remediated by simply removing the LC_CODE_SIGNATURE command from the binary so that the signature isn’t checked at load time.(Citation: Malware Persistence on OS X)",
                    "description_jp": "攻撃者は、汚染されたバイナリの実行をトリガーとして悪意のあるコンテンツを実行することで、永続性を確立する可能性がある。Mach-Oバイナリは、バイナリがロードされたときに特定の操作を実行するために使用される一連のヘッダを持っています。Mach-OバイナリのLC_LOAD_DYLIBヘッダは、実行時にどのダイナミックライブラリ(dylibs)をロードするかをmacOSとOS Xに伝えます。これらは、残りのフィールドと依存関係を調整する限り、コンパイルされたバイナリにアドホックに追加することができます（引用：Writing Bad Malware for OSX）これらの変更を実行するために利用可能なツールがあります。\n\n攻撃者は、バイナリが実行されるたびに悪意のあるdylibをロードして実行するように、Mach-Oバイナリのヘッダを変更することができます。バイナリが変更されているため、いかなる変更もバイナリのデジタル署名を無効にしますが、バイナリからLC_CODE_SIGNATUREコマンドを削除するだけで、ロード時に署名がチェックされないようにすることができます。"
                },
                {
                    "id": "T1546.011",
                    "name_eng": "Application Shimming",
                    "name_jp": "アプリケーション・シミング",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by application shims. The Microsoft Windows Application Compatibility Infrastructure/Framework (Application Shim) was created to allow for backward compatibility of software as the operating system codebase changes over time. For example, the application shimming feature allows developers to apply fixes to applications (without rewriting code) that were created for Windows XP so that it will work with Windows 10. (Citation: Elastic Process Injection July 2017)\n\nWithin the framework, shims are created to act as a buffer between the program (or more specifically, the Import Address Table) and the Windows OS. When a program is executed, the shim cache is referenced to determine if the program requires the use of the shim database (.sdb). If so, the shim database uses hooking to redirect the code as necessary in order to communicate with the OS. \n\nA list of all shims currently installed by the default Windows installer (sdbinst.exe) is kept in:\n\n* <code>%WINDIR%\\AppPatch\\sysmain.sdb</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\installedsdb</code>\n\nCustom databases are stored in:\n\n* <code>%WINDIR%\\AppPatch\\custom & %WINDIR%\\AppPatch\\AppPatch64\\Custom</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\custom</code>\n\nTo keep shims secure, Windows designed them to run in user mode so they cannot modify the kernel and you must have administrator privileges to install a shim. However, certain shims can be used to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002) (UAC and RedirectEXE), inject DLLs into processes (InjectDLL), disable Data Execution Prevention (DisableNX) and Structure Exception Handling (DisableSEH), and intercept memory addresses (GetProcAddress).\n\nUtilizing these shims may allow an adversary to perform several malicious acts such as elevate privileges, install backdoors, disable defenses like Windows Defender, etc. (Citation: FireEye Application Shimming) Shims can also be abused to establish persistence by continuously being invoked by affected programs.",
                    "description_jp": "攻撃者は、アプリケーションシムによって引き起こされる悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。Microsoft Windows Application Compatibility Infrastructure/Framework（アプリケーションシム）は、オペレーティングシステムのコードベースが時とともに変化する中で、ソフトウェアの後方互換性を可能にするために作成されました。例えば、アプリケーションシム機能により、開発者はWindows XP用に作成されたアプリケーションに（コードを書き換えることなく）修正を適用し、Windows 10でも動作するようにすることができる。(引用：Elastic Process Injection 2017年7月号）\n\nフレームワーク内では、プログラム（より具体的にはインポート・アドレス・テーブル）とWindows OSの間でバッファとして機能するシムが作成される。プログラムが実行されると、シムキャッシュが参照され、そのプログラムがシムデータベース（.sdb）の使用を必要とするかどうかが判断される。もしそうであれば、シムデータベースはOSと通信するために、必要に応じてコードをリダイレクトするフッキングを使用する。\n\nデフォルトのWindowsインストーラー（sdbinst.exe）によって現在インストールされているすべてのシムのリストが保持されている：\n\n<code>%WINDIR%AppPatch\\sysmain.sdb</code> および\n* に保存される。\n\nカスタム・データベースは\n\n* カスタム・データベースは以下の場所に格納されます。\n<code>hklmsoftware\n\nシムの安全性を保つため、Windows はシムをユーザーモードで実行するように設計しているため、シムはカーネルを変更できず、シムをインストールするには管理者権限が必要です。しかし、特定のシムは[Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)(UACとRedirectEXE)、プロセスへのDLLの注入(InjectDLL)、データ実行防止(DisableNX)と構造体例外処理(DisableSEH)の無効化、メモリアドレスの傍受(GetProcAddress)に使用できます。\n\nこれらのシムを利用することで、敵は特権の昇格、バックドアのインストール、Windows Defenderのような防御機能の無効化など、いくつかの悪意のある行為を実行できる可能性がある（引用：FireEye Application Shimming）。シムはまた、影響を受けるプログラムから継続的に呼び出されることで、永続性を確立するために悪用される可能性もある。"
                },
                {
                    "id": "T1546.015",
                    "name_eng": "Component Object Model Hijacking",
                    "name_jp": "コンポーネント・オブジェクト・モデルのハイジャック",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by hijacked references to Component Object Model (COM) objects. COM is a system within Windows to enable interaction between software components through the operating system.(Citation: Microsoft Component Object Model)  References to various COM objects are stored in the Registry. \n\nAdversaries can use the COM system to insert malicious code that can be executed in place of legitimate software through hijacking the COM references and relationships as a means for persistence. Hijacking a COM object requires a change in the Registry to replace a reference to a legitimate system component which may cause that component to not work when executed. When that system component is executed through normal system operation the adversary's code will be executed instead.(Citation: GDATA COM Hijacking) An adversary is likely to hijack objects that are used frequently enough to maintain a consistent level of persistence, but are unlikely to break noticeable functionality within the system as to avoid system instability that could lead to detection.",
                    "description_jp": "攻撃者は、Component Object Model（COM）オブジェクトへのハイジャックされた参照をトリガーに悪意のあるコンテンツを実行することで、永続性を確立する可能性がある。COM は、オペレーティング・システムを通じてソフトウェア・コンポーネント間の相互作用を可能にする Windows 内のシステムである（引用：Microsoft Component Object Model） 様々な COM オブジェクトへの参照は、レジストリに格納される。\n\n攻撃者は COM システムを利用し、永続化の手段として COM の参照とリレーションシップをハイジャックすることで、正当なソフトウェアの代わりに実行可能な悪意のあるコードを挿入することができます。COM オブジェクトをハイジャックするには、レジストリを変更し、正規のシステム・コンポーネントへの参照を置き換える必要があります。引用：GDATA COM ハイジャック）敵対者は、一貫したレベルの永続性を維持するのに十分な頻度で使用されるオブジェクトをハイジャックする可能性が高いが、検知につながる可能性のあるシステムの不安定性を回避するため、システム内の顕著な機能を破壊する可能性は低い。"
                },
                {
                    "id": "T1546.004",
                    "name_eng": "Unix Shell Configuration Modification",
                    "name_jp": "Unixシェル設定の変更",
                    "description_eng": "Adversaries may establish persistence through executing malicious commands triggered by a user’s shell. User [Unix Shell](https://attack.mitre.org/techniques/T1059/004)s execute several configuration scripts at different points throughout the session based on events. For example, when a user opens a command-line interface or remotely logs in (such as via SSH) a login shell is initiated. The login shell executes scripts from the system (<code>/etc</code>) and the user’s home directory (<code>~/</code>) to configure the environment. All login shells on a system use /etc/profile when initiated. These configuration scripts run at the permission level of their directory and are often used to set environment variables, create aliases, and customize the user’s environment. When the shell exits or terminates, additional shell scripts are executed to ensure the shell exits appropriately. \n\nAdversaries may attempt to establish persistence by inserting commands into scripts automatically executed by shells. Using bash as an example, the default shell for most GNU/Linux systems, adversaries may add commands that launch malicious binaries into the <code>/etc/profile</code> and <code>/etc/profile.d</code> files.(Citation: intezer-kaiji-malware)(Citation: bencane blog bashrc) These files typically require root permissions to modify and are executed each time any shell on a system launches. For user level permissions, adversaries can insert malicious commands into <code>~/.bash_profile</code>, <code>~/.bash_login</code>, or <code>~/.profile</code> which are sourced when a user opens a command-line interface or connects remotely.(Citation: anomali-rocke-tactics)(Citation: Linux manual bash invocation) Since the system only executes the first existing file in the listed order, adversaries have used <code>~/.bash_profile</code> to ensure execution. Adversaries have also leveraged the <code>~/.bashrc</code> file which is additionally executed if the connection is established remotely or an additional interactive shell is opened, such as a new tab in the command-line interface.(Citation: Tsunami)(Citation: anomali-rocke-tactics)(Citation: anomali-linux-rabbit)(Citation: Magento) Some malware targets the termination of a program to trigger execution, adversaries can use the <code>~/.bash_logout</code> file to execute malicious commands at the end of a session. \n\nFor macOS, the functionality of this technique is similar but may leverage zsh, the default shell for macOS 10.15+. When the Terminal.app is opened, the application launches a zsh login shell and a zsh interactive shell. The login shell configures the system environment using <code>/etc/profile</code>, <code>/etc/zshenv</code>, <code>/etc/zprofile</code>, and <code>/etc/zlogin</code>.(Citation: ScriptingOSX zsh)(Citation: PersistentJXA_leopitt)(Citation: code_persistence_zsh)(Citation: macOS MS office sandbox escape) The login shell then configures the user environment with <code>~/.zprofile</code> and <code>~/.zlogin</code>. The interactive shell uses the <code>~/.zshrc</code> to configure the user environment. Upon exiting, <code>/etc/zlogout</code> and <code>~/.zlogout</code> are executed. For legacy programs, macOS executes <code>/etc/bashrc</code> on startup.",
                    "description_jp": "攻撃者は、ユーザのシェルによって引き起こされる悪意のあるコマンドを実行することで、永続性を確立することができる。ユーザーの[Unix Shell](https://attack.mitre.org/techniques/T1059/004)は、イベントに基づいてセッション中の異なる時点でいくつかの設定スクリプトを実行します。例えば、ユーザがコマンドラインインターフェースを開いたり、(SSH経由などで)リモートログインすると、ログインシェルが起動します。ログインシェルはシステム (<code>/etc</code>) とユーザーのホームディレクトリ (<code>~/</code>) からスクリプトを実行して環境を設定します。システム上のすべてのログインシェルは、起動時に /etc/profile を使用します。これらの設定スクリプトは、そのディレクトリの権限レベルで実行され、環境変数の設定、エイリアスの作成、ユーザー環境のカスタマイズによく使われます。シェルが終了または終了すると、シェルが適切に終了するように、追加のシェルスクリプトが実行されます。\n\n攻撃者は、シェルによって自動的に実行されるスクリプトにコマンドを挿入することで、永続性を確立しようとする場合がある。ほとんどのGNU/Linuxシステムのデフォルトシェルであるbashを例にとると、敵対者は悪意のあるバイナリを起動するコマンドを<code>/etc/profile</code>ファイルと<code>/etc/profile.d</code>ファイルに追加する可能性があります。(引用：intezer-kaiji-malware)(引用：bencane blog bashrc) これらのファイルは通常、変更するためにrootパーミッションを必要とし、システム上のシェルが起動するたびに実行されます。ユーザーレベルのパーミッションの場合、敵対者は悪意のあるコマンドを <code>~/.bash_profile</code>、<code>~/.bash_login</code>、<code>~/.profile</code> に挿入することができます。(引用: anomali-rocke-tactics)(Citation: Linux manual bash invocation) システムはリストされた順序で最初に存在するファイルのみを実行するので、敵対者は実行を確実にするために<code>~/.bash_profile</code>を使用してきました。敵はまた、リモートで接続が確立されたり、コマンドラインインターフェイスの新しいタブなど、追加の対話型シェルが開かれた場合に追加で実行される<code>~/.bashrc</code>ファイルも活用しています。(引用：Tsunami)(引用：anomali-rocke-tactics)(引用：anomali-linux-rabbit)(引用：Magento) 実行をトリガーするためにプログラムの終了をターゲットにするマルウェアもあり、敵対者は <code>~/.bash_logout</code> ファイルを使用して、セッションの終了時に悪意のあるコマンドを実行することができます。\n\nmacOSの場合、このテクニックの機能は似ていますが、macOS 10.15+のデフォルトシェルであるzshを活用する可能性があります。Terminal.appを開くと、アプリケーションはzshログインシェルとzsh対話シェルを起動します。ログインシェルは、<code>/etc/profile</code>、<code>/etc/zshenv</code>、<code>/etc/zprofile</code>、<code>/etc/zlogin</code>を使用してシステム環境を設定します。(Citation: ScriptingOSX zsh)(Citation: PersistentJXA_leopitt)(Citation: code_persistence_zsh)(Citation: macOS MS office sandbox escape) ログインシェルは、<code>~/.zprofile</code>と<code>~/.zlogin</code>でユーザー環境を設定します。対話型シェルは <code>~/.zshrc</code> を使ってユーザー環境を設定します。終了時には、<code>/etc/zlogout</code>と<code>~/.zlogout</code>が実行されます。レガシープログラムでは、macOSは起動時に<code>/etc/bashrc</code>を実行する。"
                },
                {
                    "id": "T1546.010",
                    "name_eng": "AppInit DLLs",
                    "name_jp": "AppInit DLLs",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppInit_DLLs</code> value in the Registry keys <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> or <code>HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> are loaded by user32.dll into every process that loads user32.dll. In practice this is nearly every program, since user32.dll is a very common library. (Citation: Elastic Process Injection July 2017)\n\nSimilar to Process Injection, these values can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. (Citation: AppInit Registry) Malicious AppInit DLLs may also provide persistence by continuously being triggered by API activity. \n\nThe AppInit DLL functionality is disabled in Windows 8 and later versions when secure boot is enabled. (Citation: AppInit Secure Boot)",
                    "description_jp": "攻撃者は、プロセスにロードされた AppInit DLL をトリガーとして悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。レジストリキー <code>HKEY_LOCAL_MACHINE_SoftwareMicrosoftWindows NTCurrentVersionWindows</code> または <code>HKEY_LOCAL_MACHINE_SoftwareWow6432NodeMicrosoftWindows NTCurrentVersionWindows</code> の <code>AppInit_DLLs</code> 値で指定されているダイナミックリンクライブラリ (DLL) は、user32.dll をロードするすべてのプロセスにロードされます。dllは、user32.dllをロードするすべてのプロセスにロードされる。user32.dllは非常に一般的なライブラリであるため、実際にはほとんどすべてのプログラムにロードされます。(引用：Elastic Process Injection 2017年7月号)\n\nプロセスインジェクションと同様に、これらの値を悪用して悪意のあるDLLをロードさせ、コンピュータ上の別のプロセスのコンテキストで実行させることで、昇格した特権を取得することができます。(引用：AppInit Registry） また、悪意のあるAppInit DLLは、APIアクティビティによって継続的にトリガーされることで、永続性を提供する可能性もあります。\n\nWindows 8 以降のバージョンでは、セキュアブートが有効になっている場合、AppInit DLL の機能は無効になります。(引用：AppInit セキュアブート）"
                },
                {
                    "id": "T1546.005",
                    "name_eng": "Trap",
                    "name_jp": "トラップ",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by an interrupt signal. The <code>trap</code> command allows programs and shells to specify commands that will be executed upon receiving interrupt signals. A common situation is a script allowing for graceful termination and handling of common keyboard interrupts like <code>ctrl+c</code> and <code>ctrl+d</code>.\n\nAdversaries can use this to register code to be executed when the shell encounters specific interrupts as a persistence mechanism. Trap commands are of the following format <code>trap 'command list' signals</code> where \"command list\" will be executed when \"signals\" are received.(Citation: Trap Manual)(Citation: Cyberciti Trap Statements)",
                    "description_jp": "攻撃者は、割り込みシグナルをトリガーとして悪意のあるコンテンツを実行することで、永続性を確立することができる。<code>trap</code>コマンドは、プログラムやシェルが割り込みシグナルを受信したときに実行されるコマンドを指定できるようにします。よくある状況は、<code>ctrl+c</code> や <code>ctrl+d</code>のような一般的なキーボード割り込みの優雅な終了と処理を可能にするスクリプトです。\n\n攻撃者はこれを利用して、シェルが特定の割り込みに遭遇したときに実行するコードを、永続化メカニズムとして登録することができる。トラップコマンドは以下の形式である。 <code>trap 'command list' signals</code> ここで、\"command list \"は \"signals \"を受信したときに実行される。(引用：トラップマニュアル)(引用：Cyberciti Trap Statements)"
                },
                {
                    "id": "T1546.007",
                    "name_eng": "Netsh Helper DLL",
                    "name_jp": "NetshヘルパーDLL",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by Netsh Helper DLLs. Netsh.exe (also referred to as Netshell) is a command-line scripting utility used to interact with the network configuration of a system. It contains functionality to add helper DLLs for extending functionality of the utility.(Citation: TechNet Netsh) The paths to registered netsh.exe helper DLLs are entered into the Windows Registry at <code>HKLM\\SOFTWARE\\Microsoft\\Netsh</code>.\n\nAdversaries can use netsh.exe helper DLLs to trigger execution of arbitrary code in a persistent manner. This execution would take place anytime netsh.exe is executed, which could happen automatically, with another persistence technique, or if other software (ex: VPN) is present on the system that executes netsh.exe as part of its normal functionality.(Citation: Github Netsh Helper CS Beacon)(Citation: Demaske Netsh Persistence)",
                    "description_jp": "攻撃者は、Netsh Helper DLL によって引き起こされる悪意のあるコンテンツを実行することで、永続性を確立する可能性があります。Netsh.exe (Netshell とも呼ばれる) は、システムのネットワーク構成と対話するために使用されるコマンドライン スクリプト ユーティリティです。このユーティリティには、ユーティリティの機能を拡張するためのヘルパー DLL を追加する機能が含まれています (引用: TechNet Netsh)。登録された netsh.exe ヘルパー DLL へのパスは、Windows レジストリの <code>HKLMSOFTWARE\\MicrosoftNetsh<//code> に入力されます。\n\n攻撃者は、netsh.exeヘルパーDLLを使用して、任意のコードを持続的に実行させることができる。この実行は、netsh.exeが実行されればいつでも行われることになり、自動的、別の永続化手法、または通常の機能の一部としてnetsh.exeを実行する他のソフトウェア（例：VPN）がシステム上に存在する場合に発生する可能性がある。 引用：Github Netsh Helper CS Beacon）（引用：Demaske Netsh Persistence）。"
                },
                {
                    "id": "T1546.012",
                    "name_eng": "Image File Execution Options Injection",
                    "name_jp": "画像ファイル実行オプション・インジェクション",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by Image File Execution Options (IFEO) debuggers. IFEOs enable a developer to attach a debugger to an application. When a process is created, a debugger present in an application’s IFEO will be prepended to the application’s name, effectively launching the new process under the debugger (e.g., <code>C:\\dbg\\ntsd.exe -g  notepad.exe</code>). (Citation: Microsoft Dev Blog IFEO Mar 2010)\n\nIFEOs can be set directly via the Registry or in Global Flags via the GFlags tool. (Citation: Microsoft GFlags Mar 2017) IFEOs are represented as <code>Debugger</code> values in the Registry under <code>HKLM\\SOFTWARE{\\Wow6432Node}\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\<executable></code> where <code>&lt;executable&gt;</code> is the binary on which the debugger is attached. (Citation: Microsoft Dev Blog IFEO Mar 2010)\n\nIFEOs can also enable an arbitrary monitor program to be launched when a specified program silently exits (i.e. is prematurely terminated by itself or a second, non kernel-mode process). (Citation: Microsoft Silent Process Exit NOV 2017) (Citation: Oddvar Moe IFEO APR 2018) Similar to debuggers, silent exit monitoring can be enabled through GFlags and/or by directly modifying IFEO and silent process exit Registry values in <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\</code>. (Citation: Microsoft Silent Process Exit NOV 2017) (Citation: Oddvar Moe IFEO APR 2018)\n\nSimilar to [Accessibility Features](https://attack.mitre.org/techniques/T1546/008), on Windows Vista and later as well as Windows Server 2008 and later, a Registry key may be modified that configures \"cmd.exe,\" or another program that provides backdoor access, as a \"debugger\" for an accessibility program (ex: utilman.exe). After the Registry is modified, pressing the appropriate key combination at the login screen while at the keyboard or when connected with [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) will cause the \"debugger\" program to be executed with SYSTEM privileges. (Citation: Tilbury 2014)\n\nSimilar to [Process Injection](https://attack.mitre.org/techniques/T1055), these values may also be abused to obtain privilege escalation by causing a malicious executable to be loaded and run in the context of separate processes on the computer. (Citation: Elastic Process Injection July 2017) Installing IFEO mechanisms may also provide Persistence via continuous triggered invocation.\n\nMalware may also use IFEO to [Impair Defenses](https://attack.mitre.org/techniques/T1562) by registering invalid debuggers that redirect and effectively disable various system and security applications. (Citation: FSecure Hupigon) (Citation: Symantec Ushedix June 2008)",
                    "description_jp": "攻撃者は、イメージファイル実行オプション（IFEO）デバッガによって引き起こされる悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。IFEO は、開発者がアプリケーションにデバッガをアタッチすることを可能にします。プロセスが作成されると、アプリケーションの IFEO に存在するデバッガーがアプリケーション名の前に追加され、デバッガーの下で新しいプロセスが効果的に起動されます (例: <code>C:³³³³.exe -g notepad.exe</code>)。(引用: Microsoft Dev Blog IFEO Mar 2010)\n\nIFEOは、レジストリを介して直接設定するか、GFlagsツールを介してグローバルフラグに設定することができます。(引用: Microsoft GFlags Mar 2017) IFEO は、レジストリの <code>HKLMSOFTWARE{Wow6432Node}MicrosoftWindows NTCurrentVersionImage File Execution Options<executable></code> の <code>Debugger</code> 値として表され、<code>&lt;executable&gt;</code> はデバッガーがアタッチされているバイナリです。(引用：Microsoft Dev Blog IFEO Mar 2010）\n\nIFEO を使用すると、指定したプログラムがサイレント終了 (それ自身または 2 番目の非カーネル モード プロセスによって早期終了) したときに、任意のモニター プログラムを起動することもできます。(引用: Microsoft Silent Process Exit NOV 2017) (引用: Oddvar Moe IFEO APR 2018) デバッガーと同様に、サイレント終了監視は、GFlags を通して、または <code>HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTのIFEOおよびサイレント終了レジストリ値を直接変更することによって有効にすることができます。(引用：Microsoft Silent Process Exit NOV 2017）（引用：Oddvar Moe IFEO APR 2018）\n\nアクセシビリティ機能](https://attack.mitre.org/techniques/T1546/008)と同様に、Windows Vista以降およびWindows Server 2008以降では、「cmd.exe」またはバックドアアクセスを提供する別のプログラムを、アクセシビリティプログラム(ex: utilman.exe)の「デバッガ」として設定するレジストリキーが変更される可能性があります。レジストリが変更された後、キーボードを操作しているときにログイン画面で適切なキーの組み合わせを押すか、[リモート・デスクトップ・プロトコル](https://attack.mitre.org/techniques/T1021/001)で接続すると、「デバッガー」プログラムがSYSTEM権限で実行されるようになります。(引用：ティルベリー2014）\n\nプロセスインジェクション](https://attack.mitre.org/techniques/T1055)と同様に、これらの値を悪用して、悪意のある実行ファイルをコンピュータ上の別のプロセスのコンテキストで読み込ませて実行させることで、特権の昇格を得ることもできます。(引用: Elastic Process Injection July 2017) IFEO メカニズムをインストールすることは、継続的なトリガー呼び出しによって永続性を提供する可能性もある。\n\nまた、マルウェアはIFEOを使用して、様々なシステムやセキュリティアプリケーションをリダイレクトし、効果的に無効にする無効なデバッガを登録することで、[Impair Defenses](https://attack.mitre.org/techniques/T1562)を行う可能性があります。(引用：FSecure Hupigon) (引用：Symantec Ushedix June 2008)"
                },
                {
                    "id": "T1546.001",
                    "name_eng": "Change Default File Association",
                    "name_jp": "デフォルトのファイルの関連付けを変更する",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by a file type association. When a file is opened, the default program used to open the file (also called the file association or handler) is checked. File association selections are stored in the Windows Registry and can be edited by users, administrators, or programs that have Registry access or by administrators using the built-in assoc utility.(Citation: Microsoft Change Default Programs)(Citation: Microsoft File Handlers)(Citation: Microsoft Assoc Oct 2017) Applications can modify the file association for a given file extension to call an arbitrary program when a file with the given extension is opened.\n\nSystem file associations are listed under <code>HKEY_CLASSES_ROOT\\.[extension]</code>, for example <code>HKEY_CLASSES_ROOT\\.txt</code>. The entries point to a handler for that extension located at <code>HKEY_CLASSES_ROOT\\\\[handler]</code>. The various commands are then listed as subkeys underneath the shell key at <code>HKEY_CLASSES_ROOT\\\\[handler]\\shell\\\\[action]\\command</code>. For example: \n\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\open\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\print\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\printto\\command</code>\n\nThe values of the keys listed are commands that are executed when the handler opens the file extension. Adversaries can modify these values to continually execute arbitrary commands.(Citation: TrendMicro TROJ-FAKEAV OCT 2012)",
                    "description_jp": "攻撃者は、ファイルタイプの関連付けをトリガーとして悪意のあるコンテンツを実行することで、永続性を確立する可能性がある。ファイルを開くと、そのファイルを開くために使用されるデフォルトのプログラム（ファイルの関連付けまたはハンドラとも呼ばれる）がチェックされる。ファイルの関連付けの選択は Windows レジストリに保存され、レジストリにアクセスできるユーザー、管理者、プログラム、または管理者が組み込みの assoc ユーティリティを使用して編集することができます。(引用: Microsoft Change Default Programs)(Citation: Microsoft File Handlers)(Citation: Microsoft Assoc Oct 2017) アプリケーションは、指定された拡張子のファイルが開かれたときに任意のプログラムを呼び出すように、指定された拡張子のファイルの関連付けを変更することができます。\n\nシステムファイルの関連付けは、<code>HKEY_CLASSES_ROOT</code>.[拡張子]</code>の下にリストされており、例えば<code>HKEY_CLASSES_ROOT</code>.txt</code>のようになる。エントリは、<code>HKEY_CLASSES_ROOT</code>[handler]</code>にあるその拡張のハンドラを指す。そして、様々なコマンドは、<code>HKEY_CLASSES_ROOT</code>のシェルキーの下のサブキーとして、<code>HKEY_CLASSES_ROOT</code>[handler]</code>にあるシェルキーの下にリストされる。例えば\n\n<code>HKEY_CLASSES_ROOT ￤txtfile ￤shell ￤command</code> でシェルキーを使用します。\n* <code>HKEY_CLASSES_ROOTtxtfile\\shellprint</code>\n* <code>HKEY_CLASSES_ROOTtxtfile\\shellprinttocommand</code>\n\n列挙されたキーの値は、ハンドラーがファイル拡張子を開いたときに実行されるコマンドである。攻撃者はこれらの値を変更することで、任意のコマンドを継続的に実行することができます。 (引用: TrendMicro TROJ-FAKEAV OCT 2012)"
                },
                {
                    "id": "T1546.009",
                    "name_eng": "AppCert DLLs",
                    "name_jp": "AppCert DLLs",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppCert DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppCertDLLs</code> Registry key under <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\</code> are loaded into every process that calls the ubiquitously used application programming interface (API) functions <code>CreateProcess</code>, <code>CreateProcessAsUser</code>, <code>CreateProcessWithLoginW</code>, <code>CreateProcessWithTokenW</code>, or <code>WinExec</code>. (Citation: Elastic Process Injection July 2017)\n\nSimilar to [Process Injection](https://attack.mitre.org/techniques/T1055), this value can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. Malicious AppCert DLLs may also provide persistence by continuously being triggered by API activity.",
                    "description_jp": "攻撃者は、プロセスにロードされたAppCert DLLをトリガーとして悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。<code>HKEY_LOCAL_MACHINESystemCurrentControlSet\\ControlSession Manager</code>下の<code>AppCertDLLs</code>レジストリキーで指定されるダイナミックリンクライブラリ（DLL）は、広く使用されているアプリケーションプログラミングインターフェース（API）関数<code>CreateProcess</code>を呼び出すすべてのプロセスにロードされます、<code>CreateProcessAsUser</code>、<code>CreateProcessWithLoginW</code>、<code>CreateProcessWithTokenW</code>、<code>WinExec</code> を呼び出すすべてのプロセスにロードされます。(引用：Elastic Process Injection 2017年7月号）\n\nプロセスインジェクション](https://attack.mitre.org/techniques/T1055)と同様に、この値を悪用して、悪意のあるDLLをロードさせ、コンピュータ上の別のプロセスのコンテキストで実行させることで、昇格した権限を取得することができます。また、悪意のあるAppCert DLLは、APIアクティビティによって継続的にトリガーされることで、永続性を提供する可能性もある。"
                },
                {
                    "id": "T1546.017",
                    "name_eng": "Udev Rules",
                    "name_jp": "ウデブ・ルール",
                    "description_eng": "Adversaries may maintain persistence through executing malicious content triggered using udev rules. Udev is the Linux kernel device manager that dynamically manages device nodes, handles access to pseudo-device files in the `/dev` directory, and responds to hardware events, such as when external devices like hard drives or keyboards are plugged in or removed. Udev uses rule files with `match keys` to specify the conditions a hardware event must meet and `action keys` to define the actions that should follow. Root permissions are required to create, modify, or delete rule files located in `/etc/udev/rules.d/`, `/run/udev/rules.d/`, `/usr/lib/udev/rules.d/`, `/usr/local/lib/udev/rules.d/`, and `/lib/udev/rules.d/`. Rule priority is determined by both directory and by the digit prefix in the rule filename.(Citation: Ignacio Udev research 2024)(Citation: Elastic Linux Persistence 2024)\n\nAdversaries may abuse the udev subsystem by adding or modifying rules in udev rule files to execute malicious content. For example, an adversary may configure a rule to execute their binary each time the pseudo-device file, such as `/dev/random`, is accessed by an application. Although udev is limited to running short tasks and is restricted by systemd-udevd's sandbox (blocking network and filesystem access), attackers may use scripting commands under the action key `RUN+=` to detach and run the malicious content’s process in the background to bypass these controls.(Citation: Reichert aon sedexp 2024)",
                    "description_jp": "攻撃者は、udev ルールを使用してトリガーされた悪意のあるコンテンツを実行することで、永続性を維持する可能性があります。Udev は Linux カーネルのデバイス・マネージャーで、デバイス・ノードを動的に管理し、`/dev` ディレクトリにある擬似デバイス・ファイルへのアクセスを処理し、ハード・ドライブやキーボードなどの外部デバイスが接続されたり取り外されたりしたときのようなハードウェア・イベントに応答します。Udev は `match キー` でハードウェアイベントが満たすべき条件を指定し、`action キー` でその後のアクションを定義するルールファイルを使用する。etc/udev/rules.d/`、`/run/udev/rules.d/`、`/usr/lib/udev/rules.d/`、`/usr/local/lib/udev/rules.d/`、`/lib/udev/rules.d/` にあるルールファイルを作成、変更、削除するには root 権限が必要です。ルールの優先順位は、ディレクトリと、ルールファイル名に含まれる数字のプレフィックスによって決まる。(引用: Ignacio Udev research 2024)(Citation: Elastic Linux Persistence 2024)\n\n攻撃者は、悪意のあるコンテンツを実行するためにudevルールファイルにルールを追加または変更することで、udevサブシステムを悪用する可能性があります。例えば、敵は `/dev/random` のような疑似デバイスファイルがアプリケーションによってアクセスされるたびに、自分のバイナリを実行するようにルールを設定するかもしれません。udevは短いタスクの実行に制限されており、systemd-udevdのサンドボックス（ネットワークとファイルシステムへのアクセスをブロック）によって制限されていますが、攻撃者はアクションキー`RUN+=`の下でスクリプトコマンドを使用して、これらの制御をバイパスするためにバックグラウンドで悪意のあるコンテンツのプロセスを切り離して実行することができます（引用：Reichert aon sedexp 2024）。"
                },
                {
                    "id": "T1546.014",
                    "name_eng": "Emond",
                    "name_jp": "エモンド",
                    "description_eng": "Adversaries may gain persistence and elevate privileges by executing malicious content triggered by the Event Monitor Daemon (emond). Emond is a [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) that accepts events from various services, runs them through a simple rules engine, and takes action. The emond binary at <code>/sbin/emond</code> will load any rules from the <code>/etc/emond.d/rules/</code> directory and take action once an explicitly defined event takes place.\n\nThe rule files are in the plist format and define the name, event type, and action to take. Some examples of event types include system startup and user authentication. Examples of actions are to run a system command or send an email. The emond service will not launch if there is no file present in the QueueDirectories path <code>/private/var/db/emondClients</code>, specified in the [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) configuration file at<code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>.(Citation: xorrior emond Jan 2018)(Citation: magnusviri emond Apr 2016)(Citation: sentinelone macos persist Jun 2019)\n\nAdversaries may abuse this service by writing a rule to execute commands when a defined event occurs, such as system start up or user authentication.(Citation: xorrior emond Jan 2018)(Citation: magnusviri emond Apr 2016)(Citation: sentinelone macos persist Jun 2019) Adversaries may also be able to escalate privileges from administrator to root as the emond service is executed with root privileges by the [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) service.",
                    "description_jp": "攻撃者は、Event Monitor Daemon (emond)によってトリガーされた悪意のあるコンテンツを実行することで、永続性を獲得し、特権を昇格させる可能性がある。emondは[Launch Daemon](https://attack.mitre.org/techniques/T1543/004)であり、様々なサービスからイベントを受け取り、シンプルなルールエンジンを通して実行し、アクションを起こします。<code>/sbin/emond</code> にある emond バイナリは、<code>/etc/emond.d/rules/</code> ディレクトリから任意のルールをロードし、明示的に定義されたイベントが発生するとアクションを実行します。\n\nルールファイルは plist 形式で、名前、イベントタイプ、実行するアクションを定義します。イベントタイプの例としては、システムの起動やユーザー認証などがあります。アクションの例としては、システムコマンドの実行や電子メールの送信などがあります。<code>/System/Library/LaunchDaemons/com.apple.emond.plist<//code>にある[Launch Daemon](https://attack.mitre.org/techniques/T1543/004)設定ファイルで指定されたQueueDirectoriesパス<code>/private/var/db/emondClients<//code>にファイルが存在しない場合、emondサービスは起動しません。(引用: xorrior emond 2018年1月)(引用: magnusviri emond 2016年4月)(引用: sentinelone macos persist 2019年6月)\n\nシステム起動やユーザー認証など、定義されたイベントが発生したときにコマンドを実行するルールを記述することで、このサービスを悪用する可能性がある(引用: xorrior emond 2018年1月)(引用: magnusviri emond 2016年4月)(引用: sentinelone macos persist 2019年6月) また、emondサービスは[Launch Daemon](https://attack.mitre.org/techniques/T1543/004) サービスによってroot権限で実行されるため、悪用者は管理者からrootに権限を昇格させることができる可能性がある。"
                },
                {
                    "id": "T1546.008",
                    "name_eng": "Accessibility Features",
                    "name_jp": "アクセシビリティの特徴",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by accessibility features. Windows contains accessibility features that may be launched with a key combination before a user has logged in (ex: when the user is on the Windows logon screen). An adversary can modify the way these programs are launched to get a command prompt or backdoor without logging in to the system.\n\nTwo common accessibility programs are <code>C:\\Windows\\System32\\sethc.exe</code>, launched when the shift key is pressed five times and <code>C:\\Windows\\System32\\utilman.exe</code>, launched when the Windows + U key combination is pressed. The sethc.exe program is often referred to as \"sticky keys\", and has been used by adversaries for unauthenticated access through a remote desktop login screen. (Citation: FireEye Hikit Rootkit)\n\nDepending on the version of Windows, an adversary may take advantage of these features in different ways. Common methods used by adversaries include replacing accessibility feature binaries or pointers/references to these binaries in the Registry. In newer versions of Windows, the replaced binary needs to be digitally signed for x64 systems, the binary must reside in <code>%systemdir%\\</code>, and it must be protected by Windows File or Resource Protection (WFP/WRP). (Citation: DEFCON2016 Sticky Keys) The [Image File Execution Options Injection](https://attack.mitre.org/techniques/T1546/012) debugger method was likely discovered as a potential workaround because it does not require the corresponding accessibility feature binary to be replaced.\n\nFor simple binary replacement on Windows XP and later as well as and Windows Server 2003/R2 and later, for example, the program (e.g., <code>C:\\Windows\\System32\\utilman.exe</code>) may be replaced with \"cmd.exe\" (or another program that provides backdoor access). Subsequently, pressing the appropriate key combination at the login screen while sitting at the keyboard or when connected over [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) will cause the replaced file to be executed with SYSTEM privileges. (Citation: Tilbury 2014)\n\nOther accessibility features exist that may also be leveraged in a similar fashion: (Citation: DEFCON2016 Sticky Keys)(Citation: Narrator Accessibility Abuse)\n\n* On-Screen Keyboard: <code>C:\\Windows\\System32\\osk.exe</code>\n* Magnifier: <code>C:\\Windows\\System32\\Magnify.exe</code>\n* Narrator: <code>C:\\Windows\\System32\\Narrator.exe</code>\n* Display Switcher: <code>C:\\Windows\\System32\\DisplaySwitch.exe</code>\n* App Switcher: <code>C:\\Windows\\System32\\AtBroker.exe</code>",
                    "description_jp": "攻撃者は、アクセシビリティ機能をトリガーとして悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性がある。Windowsには、ユーザがログインする前（例：ユーザがWindowsのログオン画面にいるとき）に、キーの組み合わせで起動できるアクセシビリティ機能があります。敵は、これらのプログラムの起動方法を変更することで、システムにログインせずにコマンドプロンプトやバックドアを取得することができます。\n\n一般的なアクセシビリティプログラムは、シフトキーを5回押したときに起動する<code>C:¥WindowsSystem32¥sethc.exe</code>と、Windows + Uキーの組み合わせを押したときに起動する<code>C:¥WindowsSystem32¥utilman.exe</code>の2つです。sethc.exeプログラムは、しばしば「スティッキーキー」と呼ばれ、敵対者によってリモートデスクトップのログイン画面を介して認証されていないアクセスに使用されている。(引用：FireEye Hikit Rootkit)\n\nWindowsのバージョンによって、敵対者はさまざまな方法でこれらの機能を利用する可能性がある。敵対者が使用する一般的な方法には、レジストリ内のアクセシビリティ機能のバイナリ、またはこれらのバイナリへのポインタ/参照を置き換えることが含まれます。Windows の新しいバージョンでは、置き換えられたバイナリは x64 システム用にデジタル署名されている必要があり、バイナリは <code>%systemdir%<//code> に存在する必要があり、Windows File or Resource Protection (WFP/WRP) によって保護されている必要があります。(引用: DEFCON2016 Sticky Keys) [Image File Execution Options Injection](https://attack.mitre.org/techniques/T1546/012)デバッガー手法は、対応するアクセシビリティ機能バイナリを置き換える必要がないため、潜在的な回避策として発見された可能性が高い。\n\nWindows XP以降やWindows Server 2003/R2以降での単純なバイナリの置き換えでは、例えば、プログラム（例えば、<code>C:³³System32³³utilman.exe</code>）を「cmd.exe」（またはバックドアアクセスを提供する他のプログラム）に置き換えることができる。その後、キーボードの前に座った状態でログイン画面で適切なキーの組み合わせを押すか、[リモートデスクトッププロトコル](https://attack.mitre.org/techniques/T1021/001)で接続すると、置き換えられたファイルがSYSTEM権限で実行されます。(引用：Tilbury 2014）\n\n同様の方法で活用される可能性のある他のアクセシビリティ機能も存在する：(引用：DEFCON2016 Sticky Keys)(引用：Narrator Accessibility Abuse)\n\n* オンスクリーンキーボード：<code>C:◆WindowsSystem32◆osk.exe</code>。\n* 拡大鏡：拡大鏡：<code>C:¥Windows¥System32¥Magnify.exe</code\n* ナレーター：<code>C:¥Windows¥System32¥Narrator.exe<//code\n* ディスプレイスイッチャー：<code>C:¥Windows¥System32¥DisplaySwitch.exe<//code\n* App Switcher：App Switcher: <code>C:¥Windows¥System32¥AtBroker.exe<//code"
                }
            ]
        },
        {
            "id": "T1671",
            "name_eng": "Cloud Application Integration",
            "name_jp": "クラウドアプリケーションの統合",
            "description_eng": "Adversaries may achieve persistence by leveraging OAuth application integrations in a software-as-a-service environment. Adversaries may create a custom application, add a legitimate application into the environment, or even co-opt an existing integration to achieve malicious ends.(Citation: Push Security SaaS Persistence 2022)(Citation: SaaS Attacks GitHub Evil Twin Integrations)\n\nOAuth is an open standard that allows users to authorize applications to access their information on their behalf. In a SaaS environment such as Microsoft 365 or Google Workspace, users may integrate applications to improve their workflow and achieve tasks.  \n\nLeveraging application integrations may allow adversaries to persist in an environment – for example, by granting consent to an application from a high-privileged adversary-controlled account in order to maintain access to its data, even in the event of losing access to the account.(Citation: Wiz Midnight Blizzard 2024)(Citation: Microsoft Malicious OAuth Applications 2022)(Citation: Huntress Persistence Microsoft 365 Compromise 2024) In some cases, integrations may remain valid even after the original consenting user account is disabled.(Citation: Push Security Slack Persistence 2023) Application integrations may also allow adversaries to bypass multi-factor authentication requirements through the use of [Application Access Token](https://attack.mitre.org/techniques/T1550/001)s. Finally, they may enable persistent [Automated Exfiltration](https://attack.mitre.org/techniques/T1020) over time.(Citation: Synes Cyber Corner Malicious Azure Application 2023)\n\nCreating or adding a new application may require the adversary to create a dedicated [Cloud Account](https://attack.mitre.org/techniques/T1136/003) for the application and assign it [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003) – for example, in Microsoft 365 environments, an application can only access resources via an associated service principal.(Citation: Microsoft Entra ID Service Principals)",
            "description_jp": "攻撃者は、SaaS（Software-as-a-Service）環境における OAuth アプリケーションの統合を活用することで、永続性を達成する可能性があります。攻撃者は、カスタムアプリケーションを作成したり、正規のアプリケーションを環境に追加したり、あるいは悪意のある目的を達成するために既存の統合を利用したりする可能性がある。 引用：Push Security SaaS Persistence 2022）（引用：SaaS Attacks GitHub Evil Twin Integrations\n\nOAuthは、ユーザーが自分の代わりに自分の情報にアクセスするアプリケーションを承認することを可能にするオープンスタンダードです。Microsoft 365やGoogle WorkspaceのようなSaaS環境では、ユーザーはワークフローを改善し、タスクを達成するためにアプリケーションを統合することができる。  \n\nアプリケーションの統合を活用することで、例えば、敵対者がコントロールする高特権のアカウントからアプリケーションに同意を与えることで、そのアカウントへのアクセスが失われた場合でも、そのデータへのアクセスを維持することができるなど、敵対者が環境に永続することが可能になるかもしれません。(引用: Wiz Midnight Blizzard 2024)(引用: Microsoft Malicious OAuth Applications 2022)(引用: Huntress Persistence Microsoft 365 Compromise 2024) 場合によっては、同意した元のユーザアカウントが無効化された後でも、統合が有効なままであることがあります(引用: Push Security Slack Persistence 2023) アプリケーションの統合によって、敵対者は[Application Access Token](https://attack.mitre.org/techniques/T1550/001)の使用を通じて、多要素認証要件を回避することもできます。最後に、これらのアプリケーションは、長期にわたって持続的な[自動流出](https://attack.mitre.org/techniques/T1020)を可能にする可能性があります。(引用: Synes Cyber Corner Malicious Azure Application 2023)\n\n例えば、Microsoft 365 の環境では、アプリケーションは関連するサービスプリンシパルを介してのみリソースにアクセスすることができます。",
            "subtechniques": []
        },
        {
            "id": "T1197",
            "name_eng": "BITS Jobs",
            "name_jp": "BITSの求人",
            "description_eng": "Adversaries may abuse BITS jobs to persistently execute code and perform various background tasks. Windows Background Intelligent Transfer Service (BITS) is a low-bandwidth, asynchronous file transfer mechanism exposed through [Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM).(Citation: Microsoft COM)(Citation: Microsoft BITS) BITS is commonly used by updaters, messengers, and other applications preferred to operate in the background (using available idle bandwidth) without interrupting other networked applications. File transfer tasks are implemented as BITS jobs, which contain a queue of one or more file operations.\n\nThe interface to create and manage BITS jobs is accessible through [PowerShell](https://attack.mitre.org/techniques/T1059/001) and the [BITSAdmin](https://attack.mitre.org/software/S0190) tool.(Citation: Microsoft BITS)(Citation: Microsoft BITSAdmin)\n\nAdversaries may abuse BITS to download (e.g. [Ingress Tool Transfer](https://attack.mitre.org/techniques/T1105)), execute, and even clean up after running malicious code (e.g. [Indicator Removal](https://attack.mitre.org/techniques/T1070)). BITS tasks are self-contained in the BITS job database, without new files or registry modifications, and often permitted by host firewalls.(Citation: CTU BITS Malware June 2016)(Citation: Mondok Windows PiggyBack BITS May 2007)(Citation: Symantec BITS May 2007) BITS enabled execution may also enable persistence by creating long-standing jobs (the default maximum lifetime is 90 days and extendable) or invoking an arbitrary program when a job completes or errors (including after system reboots).(Citation: PaloAlto UBoatRAT Nov 2017)(Citation: CTU BITS Malware June 2016)\n\nBITS upload functionalities can also be used to perform [Exfiltration Over Alternative Protocol](https://attack.mitre.org/techniques/T1048).(Citation: CTU BITS Malware June 2016)",
            "description_jp": "攻撃者は BITS ジョブを悪用して、コードを持続的に実行したり、さまざまなバックグラウンドタスクを実行したりする可能性がある。Windows Background Intelligent Transfer Service (BITS) は、[Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) を通じて公開される、低帯域幅の非同期ファイル転送メカニズムである。(引用: Microsoft COM)(引用: Microsoft BITS) BITS は、アップデータ、メッセンジャー、および他のネットワークアプリケーションを中断することなくバックグラウンドで動作する(利用可能なアイドル帯域幅を使用する)ことを好む他のアプリケーションによって一般的に使用される。ファイル転送タスクはBITSジョブとして実装され、1つ以上のファイル操作のキューを含む。\n\nBITSジョブを作成および管理するためのインターフェイスは、[PowerShell](https://attack.mitre.org/techniques/T1059/001)および[BITSAdmin](https://attack.mitre.org/software/S0190)ツールからアクセスできます。(引用：Microsoft BITS)(引用：Microsoft BITSAdmin)\n\n攻撃者はBITSを悪用して、悪意のあるコードのダウンロード（[Ingress Tool Transfer](https://attack.mitre.org/techniques/T1105)など）、実行、さらには実行後のクリーンアップ（[Indicator Removal](https://attack.mitre.org/techniques/T1070)など）を行う可能性があります。BITSタスクは、BITSジョブデータベース内で自己完結しており、新しいファイルやレジストリを変更することなく、多くの場合、ホストのファイアウォールで許可されています。(引用:CTU BITS Malware June 2016)(引用:Mondok Windows PiggyBack BITS May 2007)(引用:Symantec BITS May 2007) BITSを有効にした実行は、長期間のジョブ(デフォルトの最大寿命は90日で、拡張可能)を作成したり、ジョブが完了またはエラー(システムリブート後を含む)になったときに任意のプログラムを呼び出したりして、永続性を有効にすることもできる(引用:PaloAlto UBoatRAT Nov 2017)(Citation: CTU BITS Malware June 2016)\n\nBITSのアップロード機能を使用して、[Exfiltration Over Alternative Protocol](https://attack.mitre.org/techniques/T1048)を実行することもできます(引用: CTU BITS Malware June 2016)。",
            "subtechniques": []
        },
        {
            "id": "T1505",
            "name_eng": "Server Software Component",
            "name_jp": "サーバー・ソフトウェア・コンポーネント",
            "description_eng": "Adversaries may abuse legitimate extensible development features of servers to establish persistent access to systems. Enterprise server applications may include features that allow developers to write and install software or scripts to extend the functionality of the main application. Adversaries may install malicious components to extend and abuse server applications.(Citation: volexity_0day_sophos_FW)",
            "description_jp": "攻撃者は、サーバの正当な拡張可能な開発機能を悪用して、システムへの永続的なアクセスを確立する可能性があります。エンタープライズサーバアプリケーションには、開発者がメインのアプリケーションの機能を拡張するためのソフトウェアやスクリプトを書いたりインストールしたりできる機能が含まれていることがあります。攻撃者は、サーバーアプリケーションを拡張して悪用するために、悪意のあるコンポーネントをインストールする可能性があります。(引用：volexity_0day_sophos_FW)",
            "subtechniques": [
                {
                    "id": "T1505.002",
                    "name_eng": "Transport Agent",
                    "name_jp": "輸送代理店",
                    "description_eng": "Adversaries may abuse Microsoft transport agents to establish persistent access to systems. Microsoft Exchange transport agents can operate on email messages passing through the transport pipeline to perform various tasks such as filtering spam, filtering malicious attachments, journaling, or adding a corporate signature to the end of all outgoing emails.(Citation: Microsoft TransportAgent Jun 2016)(Citation: ESET LightNeuron May 2019) Transport agents can be written by application developers and then compiled to .NET assemblies that are subsequently registered with the Exchange server. Transport agents will be invoked during a specified stage of email processing and carry out developer defined tasks. \n\nAdversaries may register a malicious transport agent to provide a persistence mechanism in Exchange Server that can be triggered by adversary-specified email events.(Citation: ESET LightNeuron May 2019) Though a malicious transport agent may be invoked for all emails passing through the Exchange transport pipeline, the agent can be configured to only carry out specific tasks in response to adversary defined criteria. For example, the transport agent may only carry out an action like copying in-transit attachments and saving them for later exfiltration if the recipient email address matches an entry on a list provided by the adversary.",
                    "description_jp": "攻撃者はマイクロソフトのトランスポートエージェントを悪用して、システムへの永続的なアクセスを確立する可能性があります。Microsoft Exchangeのトランスポートエージェントは、トランスポートパイプラインを通過する電子メールメッセージに対して動作し、スパムのフィルタリング、悪意のある添付ファイルのフィルタリング、ジャーナリング、すべての送信電子メールの末尾への企業署名の追加など、さまざまなタスクを実行することができます(引用：Microsoft TransportAgent 2016年6月)(引用：ESET LightNeuron 2019年5月) トランスポートエージェントは、アプリケーション開発者によって記述され、その後Exchangeサーバーに登録される.NETアセンブリにコンパイルされます。トランスポートエージェントは、電子メール処理の指定された段階で呼び出され、開発者が定義したタスクを実行します。\n\n敵対者は、悪意のあるトランスポートエージェントを登録することで、敵対者が指定した電子メールイベントによってトリガーできる永続化メカニズムを Exchange Server に提供することができます（引用：ESET LightNeuron May 2019） 悪意のあるトランスポートエージェントは、Exchange トランスポートパイプラインを通過するすべての電子メールに対して呼び出される可能性がありますが、敵対者が定義した基準に対応して特定のタスクのみを実行するようにエージェントを構成することができます。例えば、トランスポートエージェントは、受信者の電子メールアドレスが敵対者によって提供されたリストのエントリと一致する場合にのみ、転送中の添付ファイルをコピーし、後で流出させるために保存するといったアクションを実行することができます。"
                },
                {
                    "id": "T1505.004",
                    "name_eng": "IIS Components",
                    "name_jp": "IISコンポーネント",
                    "description_eng": "Adversaries may install malicious components that run on Internet Information Services (IIS) web servers to establish persistence. IIS provides several mechanisms to extend the functionality of the web servers. For example, Internet Server Application Programming Interface (ISAPI) extensions and filters can be installed to examine and/or modify incoming and outgoing IIS web requests. Extensions and filters are deployed as DLL files that export three functions: <code>Get{Extension/Filter}Version</code>, <code>Http{Extension/Filter}Proc</code>, and (optionally) <code>Terminate{Extension/Filter}</code>. IIS modules may also be installed to extend IIS web servers.(Citation: Microsoft ISAPI Extension Overview 2017)(Citation: Microsoft ISAPI Filter Overview 2017)(Citation: IIS Backdoor 2011)(Citation: Trustwave IIS Module 2013)\n\nAdversaries may install malicious ISAPI extensions and filters to observe and/or modify traffic, execute commands on compromised machines, or proxy command and control traffic. ISAPI extensions and filters may have access to all IIS web requests and responses. For example, an adversary may abuse these mechanisms to modify HTTP responses in order to distribute malicious commands/content to previously comprised hosts.(Citation: Microsoft ISAPI Filter Overview 2017)(Citation: Microsoft ISAPI Extension Overview 2017)(Citation: Microsoft ISAPI Extension All Incoming 2017)(Citation: Dell TG-3390)(Citation: Trustwave IIS Module 2013)(Citation: MMPC ISAPI Filter 2012)\n\nAdversaries may also install malicious IIS modules to observe and/or modify traffic. IIS 7.0 introduced modules that provide the same unrestricted access to HTTP requests and responses as ISAPI extensions and filters. IIS modules can be written as a DLL that exports <code>RegisterModule</code>, or as a .NET application that interfaces with ASP.NET APIs to access IIS HTTP requests.(Citation: Microsoft IIS Modules Overview 2007)(Citation: Trustwave IIS Module 2013)(Citation: ESET IIS Malware 2021)",
                    "description_jp": "攻撃者は、インターネット・インフォメーション・サービス（IIS）ウェブ・サーバ上で動作する悪意のあるコンポーネントをインストールし、永続性を確立する可能性がある。IIS には、Web サーバの機能を拡張するためのメカニズムがいくつか用意されている。例えば、ISAPI（Internet Server Application Programming Interface）拡張やフィルタをインストールすることで、IISのWebリクエストの送受信を検査したり、変更したりすることができます。拡張とフィルタは、3 つの関数をエクスポートする DLL ファイルとして展開されます：<code>Get{Extension/Filter}Version<//code>, <code>Http{Extension/Filter}Proc<//code>, そして (オプションで) <code>Terminate{Extension/Filter}<//code> です。IIS モジュールは、IIS Web サーバーを拡張するためにインストールすることもできます。(引用: Microsoft ISAPI Extension Overview 2017)(Citation: Microsoft ISAPI Filter Overview 2017)(Citation: IIS Backdoor 2011)(Citation: Trustwave IIS Module 2013)\n\n攻撃者は、悪意のある ISAPI 拡張機能およびフィルタをインストールして、トラフィックを監視および/または変更したり、侵害されたマシン上でコマンドを実行したり、コマンドおよび制御トラフィックをプロキシしたりする可能性があります。ISAPI 拡張やフィルタは、IIS のすべての Web リクエストとレスポンスにアクセスできる可能性があります。たとえば、悪意のあるコマンド/コンテンツを事前に構成されたホストに配布するために、敵対者がこれらのメカニズムを悪用して HTTP レスポンスを変更する可能性があります(引用: Microsoft ISAPI Filter Overview 2017)(引用: Microsoft ISAPI Extension Overview 2017)(引用: Microsoft ISAPI Extension All Incoming 2017)(引用: Dell TG-3390)(引用: Trustwave IIS Module 2013)(引用: MMPC ISAPI Filter 2012)\n\n攻撃者はまた、悪意のある IIS モジュールをインストールし、トラフィックを監視および/または変更する可能性があります。IIS 7.0 では、ISAPI 拡張やフィルタと同じように HTTP リクエストとレスポンスに無制限にアクセスできるモジュールが導入されました。IIS モジュールは、<code>RegisterModule</code> をエクスポートする DLL として記述することも、ASP.NET API と連携して IIS HTTP リクエストにアクセスする .NET アプリケーションとして記述することもできます（引用：Microsoft IIS Modules Overview 2007）（引用：Trustwave IIS Module 2013）（引用：ESET IIS Malware 2021）。"
                },
                {
                    "id": "T1505.003",
                    "name_eng": "Web Shell",
                    "name_jp": "ウェブシェル",
                    "description_eng": "Adversaries may backdoor web servers with web shells to establish persistent access to systems. A Web shell is a Web script that is placed on an openly accessible Web server to allow an adversary to access the Web server as a gateway into a network. A Web shell may provide a set of functions to execute or a command-line interface on the system that hosts the Web server.(Citation: volexity_0day_sophos_FW)\n\nIn addition to a server-side script, a Web shell may have a client interface program that is used to talk to the Web server (e.g. [China Chopper](https://attack.mitre.org/software/S0020) Web shell client).(Citation: Lee 2013)",
                    "description_jp": "攻撃者は、システムへの永続的なアクセスを確立するために、ウェブシェルを使ってウェブサーバをバックドア化することがある。ウェブシェルとは、敵がネットワークへのゲートウェイとしてウェブサーバーにアクセスできるようにするために、一般にアクセス可能なウェブサーバーに配置されるウェブスクリプトのことです。Webシェルは、Webサーバーをホストするシステム上で実行する一連の関数やコマンドラインインターフェースを提供する場合がある(引用：volexity_0day_sophos_FW)。\n\nサーバー側のスクリプトに加えて、Web シェルは、Web サーバーと対話するために使用されるクライアント・インターフェース・プログラムを持つことがあります（例：[China Chopper](https://attack.mitre.org/software/S0020) Web シェル・クライアント）。(引用：Lee 2013)"
                },
                {
                    "id": "T1505.005",
                    "name_eng": "Terminal Services DLL",
                    "name_jp": "ターミナルサービスDLL",
                    "description_eng": "Adversaries may abuse components of Terminal Services to enable persistent access to systems. Microsoft Terminal Services, renamed to Remote Desktop Services in some Windows Server OSs as of 2022, enable remote terminal connections to hosts. Terminal Services allows servers to transmit a full, interactive, graphical user interface to clients via RDP.(Citation: Microsoft Remote Desktop Services)\n\n[Windows Service](https://attack.mitre.org/techniques/T1543/003)s that are run as a \"generic\" process (ex: <code>svchost.exe</code>) load the service's DLL file, the location of which is stored in a Registry entry named <code>ServiceDll</code>.(Citation: Microsoft System Services Fundamentals) The <code>termsrv.dll</code> file, typically stored in `%SystemRoot%\\System32\\`, is the default <code>ServiceDll</code> value for Terminal Services in `HKLM\\System\\CurrentControlSet\\services\\TermService\\Parameters\\`.\n\nAdversaries may modify and/or replace the Terminal Services DLL to enable persistent access to victimized hosts.(Citation: James TermServ DLL) Modifications to this DLL could be done to execute arbitrary payloads (while also potentially preserving normal <code>termsrv.dll</code> functionality) as well as to simply enable abusable features of Terminal Services. For example, an adversary may enable features such as concurrent [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) sessions by either patching the <code>termsrv.dll</code> file or modifying the <code>ServiceDll</code> value to point to a DLL that provides increased RDP functionality.(Citation: Windows OS Hub RDP)(Citation: RDPWrap Github) On a non-server Windows OS this increased functionality may also enable an adversary to avoid Terminal Services prompts that warn/log out users of a system when a new RDP session is created.",
                    "description_jp": "攻撃者はターミナルサービスのコンポーネントを悪用し、システムへの永続的なアクセスを可能にする可能性がある。Microsoft Terminal Servicesは、2022年現在、一部のWindows Server OSでRemote Desktop Servicesに改名されており、ホストへのリモート端末接続を可能にする。ターミナルサービスにより、サーバーはRDPを介してクライアントに完全でインタラクティブなグラフィカルユーザーインターフェースを送信できる。\n\n[Windowsサービス](https://attack.mitre.org/techniques/T1543/003)は、「一般的な」プロセス（例：<code>svchost.exe</code>）として実行され、サービスのDLLファイルを読み込みます。その場所は、<code>ServiceDll</code>というレジストリエントリに保存されます。(引用: Microsoft System Services Fundamentals) <code>termsrv.dll</code>ファイルは、通常、`%SystemRoot%System32`に格納され、`HKLMSStimeParameters`のターミナルサービスのデフォルトの<code>ServiceDll</code>値である。\n\n攻撃者は、犠牲となったホストへの永続的なアクセスを可能にするために、ターミナルサービス DLL を変更または置き換える可能性があります。(引用: James TermServ DLL) この DLL への変更は、ターミナルサービスの悪用可能な機能を単に有効にするだけでなく、任意のペイロードを実行するために (通常の <code>termsrv.dll</code> 機能を維持する可能性もあります) 行われる可能性があります。たとえば、<code>termsrv.dll</code> ファイルにパッチを適用するか、<code>ServiceDll</code> の値を変更して RDP 機能を向上させる DLL を指すようにすることで、同時 [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) セッションなどの機能を有効にすることができます。(引用: Windows OS Hub RDP)(引用: RDPWrap Github) 非サーバー Windows OS では、この機能強化により、新しい RDP セッションが作成されたときにシステムのユーザーに警告/ログアウトを促すターミナル サービスのプロンプトを回避できるようになる可能性もあります。"
                },
                {
                    "id": "T1505.006",
                    "name_eng": "vSphere Installation Bundles",
                    "name_jp": "vSphereインストール・バンドル",
                    "description_eng": "Adversaries may abuse vSphere Installation Bundles (VIBs) to establish persistent access to ESXi hypervisors. VIBs are collections of files used for software distribution and virtual system management in VMware environments. Since ESXi uses an in-memory filesystem where changes made to most files are stored in RAM rather than in persistent storage, these modifications are lost after a reboot. However, VIBs can be used to create startup tasks, apply custom firewall rules, or deploy binaries that persist across reboots. Typically, administrators use VIBs for updates and system maintenance.\n\nVIBs can be broken down into three components:(Citation: VMware VIBs)\n\n* VIB payload: a `.vgz` archive containing the directories and files to be created and executed on boot when the VIBs are loaded.  \n* Signature file: verifies the host acceptance level of a VIB, indicating what testing and validation has been done by VMware or its partners before publication of a VIB. By default, ESXi hosts require a minimum acceptance level of PartnerSupported for VIB installation, meaning the VIB is published by a trusted VMware partner. However, privileged users can change the default acceptance level using the `esxcli` command line interface. Additionally, VIBs are able to be installed regardless of acceptance level by using the <code> esxcli software vib install --force</code> command. \n* XML descriptor file: a configuration file containing associated VIB metadata, such as the name of the VIB and its dependencies.  \n\nAdversaries may leverage malicious VIB packages to maintain persistent access to ESXi hypervisors, allowing system changes to be executed upon each bootup of ESXi – such as using  `esxcli` to enable firewall rules for backdoor traffic, creating listeners on hard coded ports, and executing backdoors.(Citation: Google Cloud Threat Intelligence ESXi VIBs 2022) Adversaries may also masquerade their malicious VIB files as PartnerSupported by modifying the XML descriptor file.(Citation: Google Cloud Threat Intelligence ESXi VIBs 2022)",
                    "description_jp": "攻撃者は、vSphere Installation Bundles (VIB) を悪用して、ESXi ハイパーバイザーへの永続的なアクセスを確立する可能性があります。VIBは、VMware環境におけるソフトウェアの配布や仮想システムの管理に使用されるファイルの集合体です。ESXi はインメモリ・ファイルシステムを使用しており、ほとんどのファイルに加えられた変更は、永続ストレージではなく RAM に保存されるため、これらの変更は再起動後に失われます。しかし、VIB を使用することで、スタートアップ・タスクの作成、カスタム・ファイアウォール・ルールの適用、または再起動後も持続するバイナリの展開が可能になります。通常、管理者はアップデートとシステム・メンテナンスに VIB を使用します。\n\nVIBは、次の3つのコンポーネントに分けることができます。\n\n* VIBペイロード：VIBがロードされたときにブート時に作成および実行されるディレクトリとファイルを含む`.vgz`アーカイブ。  \n* 署名ファイル：VIB のホストの受け入れレベルを検証するもので、VIB の公開前に VMware またはそのパートナーによってどのようなテストと検証が行われたかを示します。デフォルトでは、ESXi ホストは、VIB のインストールに PartnerSupported という最小の受け入れレベルを必要とします。ただし、特権ユーザは `esxcli` コマンドラインインタフェースを使用してデフォルトのアクセプタンスレベルを変更できます。さらに、<code> esxcli software vib install --force</code> コマンドを使用すると、受け入れレベルに関係なく VIB をインストールできます。\n* XML 記述ファイル: VIB の名前や依存関係など、関連する VIB メタデータを含む設定ファイル。  \n\nたとえば、`esxcli` を使用してバックドア トラフィック用のファイアウォール ルールを有効にしたり、ハードコードされたポートにリスナーを作成したり、バックドアを実行したりします。(引用: Google Cloud Threat Intelligence ESXi VIBs 2022) また、攻撃者は、XML 記述子ファイルを修正することによって、悪意のある VIB ファイルを PartnerSupported として偽装する可能性もあります。(引用: Google Cloud Threat Intelligence ESXi VIBs 2022)"
                },
                {
                    "id": "T1505.001",
                    "name_eng": "SQL Stored Procedures",
                    "name_jp": "SQLストアドプロシージャ",
                    "description_eng": "Adversaries may abuse SQL stored procedures to establish persistent access to systems. SQL Stored Procedures are code that can be saved and reused so that database users do not waste time rewriting frequently used SQL queries. Stored procedures can be invoked via SQL statements to the database using the procedure name or via defined events (e.g. when a SQL server application is started/restarted).\n\nAdversaries may craft malicious stored procedures that can provide a persistence mechanism in SQL database servers.(Citation: NetSPI Startup Stored Procedures)(Citation: Kaspersky MSSQL Aug 2019) To execute operating system commands through SQL syntax the adversary may have to enable additional functionality, such as xp_cmdshell for MSSQL Server.(Citation: NetSPI Startup Stored Procedures)(Citation: Kaspersky MSSQL Aug 2019)(Citation: Microsoft xp_cmdshell 2017) \n\nMicrosoft SQL Server can enable common language runtime (CLR) integration. With CLR integration enabled, application developers can write stored procedures using any .NET framework language (e.g. VB .NET, C#, etc.).(Citation: Microsoft CLR Integration 2017) Adversaries may craft or modify CLR assemblies that are linked to stored procedures since these CLR assemblies can be made to execute arbitrary commands.(Citation: NetSPI SQL Server CLR)",
                    "description_jp": "攻撃者は、SQLストアド・プロシージャを悪用してシステムへの永続的なアクセスを確立する可能性があります。SQLストアド・プロシージャは、データベース・ユーザーが頻繁に使用するSQLクエリを書き直さなくても済むように、保存して再利用できるコードです。ストアド・プロシージャは、プロシージャ名を使用したデータベースへの SQL 文、または定義されたイベント（SQL サーバー・アプリケーションの起動/再起動時など）を介して呼び出すことができます。\n\n攻撃者は、SQL データベースサーバーの永続化メカニズムを提供できる悪意のあるストアド プロシージャを作成する可能性があります(引用: NetSPI Startup Stored Procedures)(Citation: Kaspersky MSSQL Aug 2019) SQL 構文を通じてオペレーティング システム コマンドを実行するには、MSSQL Server 用の xp_cmdshell などの追加機能を有効にする必要があります(引用: NetSPI Startup Stored Procedures)(Citation: Kaspersky MSSQL Aug 2019)(Citation: Microsoft xp_cmdshell 2017)\n\nMicrosoft SQL Serverは、共通言語ランタイム（CLR）統合を有効にすることができます。CLR統合を有効にすると、アプリケーション開発者は任意の.NETフレームワーク言語（VB .NET、C#など）を使用してストアドプロシージャを記述できます。(引用：Microsoft CLR Integration 2017) これらのCLRアセンブリは任意のコマンドを実行させることができるため、攻撃者はストアドプロシージャにリンクされているCLRアセンブリを細工または変更する可能性があります。(引用：NetSPI SQL Server CLR)"
                }
            ]
        },
        {
            "id": "T1668",
            "name_eng": "Exclusive Control",
            "name_jp": "排他制御",
            "description_eng": "Adversaries who successfully compromise a system may attempt to maintain persistence by “closing the door” behind them  – in other words, by preventing other threat actors from initially accessing or maintaining a foothold on the same system. \n\nFor example, adversaries may patch a vulnerable, compromised system(Citation: Mandiant-iab-control)(Citation: CERT AT Fortinent Ransomware 2025) to prevent other threat actors from leveraging that vulnerability in the future. They may “close the door” in other ways, such as disabling vulnerable services(Citation: sophos-multiple-attackers), stripping privileges from accounts(Citation: aquasec-postgres-processes), or removing other malware already on the compromised device.(Citation: fsecure-netsky)\n\nHindering other threat actors may allow an adversary to maintain sole access to a compromised system or network. This prevents the threat actor from needing to compete with or even being removed themselves by other threat actors. It also reduces the “noise” in the environment, lowering the possibility of being caught and evicted by defenders. Finally, in the case of [Resource Hijacking](https://attack.mitre.org/techniques/T1496), leveraging a compromised device’s full power allows the threat actor to maximize profit.(Citation: sophos-multiple-attackers)",
            "description_jp": "システムの侵害に成功した敵対者は、自分の背後にある「ドアを閉める」ことによって、つまり、他の脅威行為者が同じシステムに最初にアクセスしたり、足場を維持したりすることを阻止することによって、永続性を維持しようとするかもしれない。\n\n例えば、敵対者は、他の脅威行為者が将来その脆弱性を活用することを防ぐために、脆弱性があり侵害されたシステム（引用：Mandiant-iab-control）（引用：CERT AT Fortinent Ransomware 2025）にパッチを適用することがある。また、脆弱性のあるサービスを無効にしたり（引用：sophos-multiple-attackers）、アカウントから権限を剥奪したり（引用：aquasec-postgres-processes）、侵害されたデバイス上にすでに存在する他のマルウェアを削除したりするなど、他の方法で「ドアを閉める」こともあります（引用：fsecure-netsky）。\n\n他の脅威行為者を妨害することで、敵対者は侵害されたシステムやネットワークへの単独アクセスを維持することができます。これにより、脅威行為者は他の脅威行為者と競合する必要がなくなったり、あるいは他の脅威行為者自身によって排除されることもなくなります。また、環境中の「ノイズ」を減らすことで、防御側に捕捉され、退去させられる可能性を低くする。最後に、[Resource Hijacking](https://attack.mitre.org/techniques/T1496)の場合、侵害されたデバイスのフルパワーを活用することで、脅威行為者は利益を最大化することができます。(引用：sophos-multiple-attackers)",
            "subtechniques": []
        },
        {
            "id": "T1136",
            "name_eng": "Create Account",
            "name_jp": "アカウント作成",
            "description_eng": "Adversaries may create an account to maintain access to victim systems.(Citation: Symantec WastedLocker June 2020) With a sufficient level of access, creating such accounts may be used to establish secondary credentialed access that do not require persistent remote access tools to be deployed on the system.\n\nAccounts may be created on the local system or within a domain or cloud tenant. In cloud environments, adversaries may create accounts that only have access to specific services, which can reduce the chance of detection.",
            "description_jp": "攻撃者は、被害者のシステムへのアクセスを維持するためにアカウントを作成する可能性がある。（引用：Symantec WastedLocker June 2020） 十分なレベルのアクセスがあれば、このようなアカウントの作成は、システムに永続的なリモートアクセスツールを展開する必要のない二次的な認証アクセスを確立するために使用される可能性がある。\n\nアカウントはローカル・システム上、またはドメインやクラウド・テナント内に作成することができる。クラウド環境では、敵対者は特定のサービスにのみアクセスできるアカウントを作成することができる。",
            "subtechniques": [
                {
                    "id": "T1136.003",
                    "name_eng": "Cloud Account",
                    "name_jp": "クラウドアカウント",
                    "description_eng": "Adversaries may create a cloud account to maintain access to victim systems. With a sufficient level of access, such accounts may be used to establish secondary credentialed access that does not require persistent remote access tools to be deployed on the system.(Citation: Microsoft O365 Admin Roles)(Citation: Microsoft Support O365 Add Another Admin, October 2019)(Citation: AWS Create IAM User)(Citation: GCP Create Cloud Identity Users)(Citation: Microsoft Azure AD Users)\n\nIn addition to user accounts, cloud accounts may be associated with services. Cloud providers handle the concept of service accounts in different ways. In Azure, service accounts include service principals and managed identities, which can be linked to various resources such as OAuth applications, serverless functions, and virtual machines in order to grant those resources permissions to perform various activities in the environment.(Citation: Microsoft Entra ID Service Principals) In GCP, service accounts can also be linked to specific resources, as well as be impersonated by other accounts for [Temporary Elevated Cloud Access](https://attack.mitre.org/techniques/T1548/005).(Citation: GCP Service Accounts) While AWS has no specific concept of service accounts, resources can be directly granted permission to assume roles.(Citation: AWS Instance Profiles)(Citation: AWS Lambda Execution Role)\n\nAdversaries may create accounts that only have access to specific cloud services, which can reduce the chance of detection.\n\nOnce an adversary has created a cloud account, they can then manipulate that account to ensure persistence and allow access to additional resources - for example, by adding [Additional Cloud Credentials](https://attack.mitre.org/techniques/T1098/001) or assigning [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003).",
                    "description_jp": "攻撃者は、被害者のシステムへのアクセスを維持するためにクラウドアカウントを作成することがある。十分なレベルのアクセスがあれば、このようなアカウントを使用して、システムに永続的なリモートアクセスツールを展開する必要のない二次的な認証アクセスを確立することができる。 引用：Microsoft O365 Admin Roles）（引用：Microsoft Support O365 Add Another Admin, October 2019）（引用：AWS Create IAM User）（引用：GCP Create Cloud Identity Users）（引用：Microsoft Azure AD Users）。\n\nユーザーアカウントに加えて、クラウドアカウントがサービスに関連付けられることもある。クラウドプロバイダは、サービスアカウントの概念をさまざまな方法で扱っている。Azureでは、サービスアカウントにはサービスプリンシパルとマネージドIDが含まれ、OAuthアプリケーション、サーバーレス機能、仮想マシンなどのさまざまなリソースにリンクすることで、それらのリソースに環境内でさまざまなアクティビティを実行する許可を与えることができる。(引用: Microsoft Entra ID Service Principals) GCPでは、サービスアカウントは特定のリソースにリンクされるだけでなく、[Temporary Elevated Cloud Access](https://attack.mitre.org/techniques/T1548/005)のために他のアカウントになりすますこともできる。(引用: GCP Service Accounts) AWSにはサービスアカウントという特定の概念はないが、リソースに直接ロールを引き受ける権限を付与することができる。(引用: AWS Instance Profiles)(引用: AWS Lambda Execution Role)\n\n攻撃者は、特定のクラウドサービスにのみアクセスできるアカウントを作成する可能性があり、検知の機会を減らすことができる。\n\n一旦敵対者がクラウドアカウントを作成したら、そのアカウントを操作して、例えば[Additional Cloud Credentials](https://attack.mitre.org/techniques/T1098/001)を追加したり、[Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003)を割り当てたりして、永続性を確保し、追加リソースへのアクセスを許可することができます。"
                },
                {
                    "id": "T1136.001",
                    "name_eng": "Local Account",
                    "name_jp": "ローカルアカウント",
                    "description_eng": "Adversaries may create a local account to maintain access to victim systems. Local accounts are those configured by an organization for use by users, remote support, services, or for administration on a single system or service. \n\nFor example, with a sufficient level of access, the Windows <code>net user /add</code> command can be used to create a local account.  In Linux, the `useradd` command can be used, while on macOS systems, the <code>dscl -create</code> command can be used. Local accounts may also be added to network devices, often via common [Network Device CLI](https://attack.mitre.org/techniques/T1059/008) commands such as <code>username</code>, to ESXi servers via `esxcli system account add`, or to Kubernetes clusters using the `kubectl` utility.(Citation: cisco_username_cmd)(Citation: Kubernetes Service Accounts Security)\n\nSuch accounts may be used to establish secondary credentialed access that do not require persistent remote access tools to be deployed on the system.",
                    "description_jp": "攻撃者は、被害者システムへのアクセスを維持するためにローカルアカウントを作成することがある。ローカル・アカウントとは、ユーザ、リモート・サポート、サービス、または単一のシステムまたはサービス上の管理用に組織によって設定されたものである。\n\n例えば、十分なアクセスレベルがあれば、Windowsの<code>net user /add</code>コマンドを使ってローカルアカウントを作成することができる。  Linux では `useradd` コマンドを、macOS システムでは <code>dscl -create</code> コマンドを使うことができる。ローカルアカウントは、多くの場合、<code>username</code>のような一般的な[Network Device CLI](https://attack.mitre.org/techniques/T1059/008)コマンドを介してネットワークデバイスに、`esxcli system account add`を介してESXiサーバに、または`kubectl`ユーティリティを使用してKubernetesクラスタに追加することもできる。(引用: cisco_username_cmd)(引用: Kubernetes Service Accounts Security)\n\nこのようなアカウントは、システム上に永続的なリモートアクセスツールを展開する必要のない、二次的な認証アクセスを確立するために使用することができる。"
                },
                {
                    "id": "T1136.002",
                    "name_eng": "Domain Account",
                    "name_jp": "ドメインアカウント",
                    "description_eng": "Adversaries may create a domain account to maintain access to victim systems. Domain accounts are those managed by Active Directory Domain Services where access and permissions are configured across systems and services that are part of that domain. Domain accounts can cover user, administrator, and service accounts. With a sufficient level of access, the <code>net user /add /domain</code> command can be used to create a domain account.(Citation: Savill 1999)\n\nSuch accounts may be used to establish secondary credentialed access that do not require persistent remote access tools to be deployed on the system.",
                    "description_jp": "攻撃者は、被害者のシステムへのアクセスを維持するためにドメインアカウントを作成することがある。ドメインアカウントとは、Active Directoryドメインサービスによって管理されるもので、そのドメインの一部であるシステムやサービス全体でアクセスやパーミッションが設定される。ドメインアカウントには、ユーザーアカウント、管理者アカウント、サービスアカウントがある。十分なアクセスレベルがあれば、<code>net user /add /domain</code>コマンドを使ってドメインアカウントを作成することができる(引用: Savill 1999)\n\nこのようなアカウントは、システムに永続的なリモートアクセスツールを配備する必要のない、二次的な認証されたアクセスを確立するために使われるかもしれない。"
                }
            ]
        },
        {
            "id": "T1653",
            "name_eng": "Power Settings",
            "name_jp": "電源設定",
            "description_eng": "Adversaries may impair a system's ability to hibernate, reboot, or shut down in order to extend access to infected machines. When a computer enters a dormant state, some or all software and hardware may cease to operate which can disrupt malicious activity.(Citation: Sleep, shut down, hibernate)\n\nAdversaries may abuse system utilities and configuration settings to maintain access by preventing machines from entering a state, such as standby, that can terminate malicious activity.(Citation: Microsoft: Powercfg command-line options)(Citation: systemdsleep Linux)\n\nFor example, `powercfg` controls all configurable power system settings on a Windows system and can be abused to prevent an infected host from locking or shutting down.(Citation: Two New Monero Malware Attacks Target Windows and Android Users) Adversaries may also extend system lock screen timeout settings.(Citation: BATLOADER: The Evasive Downloader Malware) Other relevant settings, such as disk and hibernate timeout, can be similarly abused to keep the infected machine running even if no user is active.(Citation: CoinLoader: A Sophisticated Malware Loader Campaign)\n\nAware that some malware cannot survive system reboots, adversaries may entirely delete files used to invoke system shut down or reboot.(Citation: Condi-Botnet-binaries)",
            "description_jp": "攻撃者は、感染したマシンへのアクセスを拡大するために、システムの休止状態、再起動、シャットダウンの能力を損なうことがある。コンピュータが休止状態に入ると、一部またはすべてのソフトウェアとハードウェアの動作が停止し、悪意のある活動を妨害する可能性がある。 引用：スリープ、シャットダウン、ハイバネート\n\n攻撃者は、システムユーティリティや構成設定を悪用して、マシンがスタンバイ状態などの悪意のある活動を停止できる状態になるのを防ぎ、アクセスを維持する可能性がある(引用: Microsoft: Powercfg コマンドラインオプション)(引用: systemdsleep Linux)\n\n例えば、`powercfg`は、Windowsシステム上で構成可能なすべての電源システム設定を制御し、感染したホストがロックまたはシャットダウンするのを防ぐために悪用される可能性がある(引用：WindowsとAndroidユーザーをターゲットにした2つの新しいMoneroマルウェア攻撃) 敵はまた、システムロック画面のタイムアウト設定を拡張する可能性がある。(引用：BATLOADER: The Evasive Downloader Malware) ディスクやハイバネートのタイムアウトなど、その他の関連する設定も同様に悪用され、ユーザーがアクティブでなくても感染したマシンを実行し続けることができます。 (引用：CoinLoader: A Sophisticated Malware Loader Campaign)\n\nマルウェアの中には、システムの再起動に耐えられないものもあるため、敵対者は、システムのシャットダウンや再起動を呼び出すために使用されるファイルを完全に削除することがあります（引用：Condi-Botnet-binaries）。",
            "subtechniques": []
        },
        {
            "id": "T1556",
            "name_eng": "Modify Authentication Process",
            "name_jp": "認証プロセスの変更",
            "description_eng": "Adversaries may modify authentication mechanisms and processes to access user credentials or enable otherwise unwarranted access to accounts. The authentication process is handled by mechanisms, such as the Local Security Authentication Server (LSASS) process and the Security Accounts Manager (SAM) on Windows, pluggable authentication modules (PAM) on Unix-based systems, and authorization plugins on MacOS systems, responsible for gathering, storing, and validating credentials. By modifying an authentication process, an adversary may be able to authenticate to a service or system without using [Valid Accounts](https://attack.mitre.org/techniques/T1078).\n\nAdversaries may maliciously modify a part of this process to either reveal credentials or bypass authentication mechanisms. Compromised credentials or access may be used to bypass access controls placed on various resources on systems within the network and may even be used for persistent access to remote systems and externally available services, such as VPNs, Outlook Web Access and remote desktop.",
            "description_jp": "攻撃者は、認証メカニズムやプロセスを改ざんして、ユーザー認証情報にアクセスしたり、アカウントへの不当なアクセスを可能にしたりする可能性がある。認証プロセスは、Windows の Local Security Authentication Server (LSASS) プロセスや Security Accounts Manager (SAM)、Unix ベースのシステムの Pluggable Authentication Module (PAM)、MacOS システムの Authorization Plugins などのメカニズムによって処理され、認証情報の収集、保存、検証を行う。認証プロセスを変更することで、敵は[Valid Accounts](https://attack.mitre.org/techniques/T1078)を使わずにサービスやシステムを認証できるかもしれない。\n\n敵対者はこのプロセスの一部を悪意を持って変更し、クレデンシャルを明らかにするか、認証メカニズムをバイパスする。侵害された認証情報またはアクセスは、ネットワーク内のシステム上のさまざまなリソースに配置されたアクセス制御をバイパスするために使用される可能性があり、VPN、Outlook Web Access、リモートデスクトップなどのリモートシステムや外部で利用可能なサービスへの永続的なアクセスに使用される可能性さえある。",
            "subtechniques": [
                {
                    "id": "T1556.004",
                    "name_eng": "Network Device Authentication",
                    "name_jp": "ネットワーク機器認証",
                    "description_eng": "Adversaries may use [Patch System Image](https://attack.mitre.org/techniques/T1601/001) to hard code a password in the operating system, thus bypassing of native authentication mechanisms for local accounts on network devices.\n\n[Modify System Image](https://attack.mitre.org/techniques/T1601) may include implanted code to the operating system for network devices to provide access for adversaries using a specific password.  The modification includes a specific password which is implanted in the operating system image via the patch.  Upon authentication attempts, the inserted code will first check to see if the user input is the password. If so, access is granted. Otherwise, the implanted code will pass the credentials on for verification of potentially valid credentials.(Citation: Mandiant - Synful Knock)",
                    "description_jp": "攻撃者は、[Patch System Image](https://attack.mitre.org/techniques/T1601/001)を使用して、オペレーティングシステムにパスワードをハードコードし、ネットワークデバイス上のローカルアカウントのネイティブ認証メカニズムをバイパスする可能性がある。\n\n[システムイメージの修正](https://attack.mitre.org/techniques/T1601)は、ネットワークデバイスのオペレーティングシステムに、特定のパスワードを使用して敵にアクセスを提供するためのコードを埋め込む可能性があります。  この修正には、パッチを介してオペレーティングシステムイメージに埋め込まれる特定のパスワードが含まれます。  認証が試みられると、挿入されたコードはまずユーザー入力がパスワードかどうかをチェックする。もしそうなら、アクセスは許可される。そうでない場合、埋め込まれたコードは潜在的に有効な認証情報を検証するために認証情報を渡す。 引用：Mandiant - Synful Knock"
                },
                {
                    "id": "T1556.001",
                    "name_eng": "Domain Controller Authentication",
                    "name_jp": "ドメインコントローラ認証",
                    "description_eng": "Adversaries may patch the authentication process on a domain controller to bypass the typical authentication mechanisms and enable access to accounts. \n\nMalware may be used to inject false credentials into the authentication process on a domain controller with the intent of creating a backdoor used to access any user’s account and/or credentials (ex: [Skeleton Key](https://attack.mitre.org/software/S0007)). Skeleton key works through a patch on an enterprise domain controller authentication process (LSASS) with credentials that adversaries may use to bypass the standard authentication system. Once patched, an adversary can use the injected password to successfully authenticate as any domain user account (until the the skeleton key is erased from memory by a reboot of the domain controller). Authenticated access may enable unfettered access to hosts and/or resources within single-factor authentication environments.(Citation: Dell Skeleton)",
                    "description_jp": "攻撃者は、ドメインコントローラの認証プロセスにパッチを当て、典型的な認証メカニズムをバイパスし、アカウントへのアクセスを可能にする可能性がある。\n\nマルウェアは、任意のユーザーのアカウントや認証情報にアクセスするためのバックドアを作成する目的で、ドメインコントローラの認証プロセスに偽の認証情報を注入するために使用される可能性があります（例：[Skeleton Key](https://attack.mitre.org/software/S0007)）。スケルトン・キーは、敵が標準認証システムをバイパスするために使用する可能性のある認証情報を使用して、エンタープライズ・ドメイン・コントローラの認証プロセス(LSASS)にパッチを適用することで機能する。いったんパッチが適用されると、敵対者は注入されたパスワードを使用して、（ドメインコントローラの再起動によってスケルトンキーがメモリから消去されるまで）ドメインユーザーアカウントとして認証に成功することができる。認証されたアクセスは、一要素認証環境内のホストおよび/またはリソースへの自由なアクセスを可能にする可能性がある(引用：Dell Skeleton)"
                },
                {
                    "id": "T1556.009",
                    "name_eng": "Conditional Access Policies",
                    "name_jp": "条件付きアクセス・ポリシー",
                    "description_eng": "Adversaries may disable or modify conditional access policies to enable persistent access to compromised accounts. Conditional access policies are additional verifications used by identity providers and identity and access management systems to determine whether a user should be granted access to a resource.\n\nFor example, in Entra ID, Okta, and JumpCloud, users can be denied access to applications based on their IP address, device enrollment status, and use of multi-factor authentication.(Citation: Microsoft Conditional Access)(Citation: JumpCloud Conditional Access Policies)(Citation: Okta Conditional Access Policies) In some cases, identity providers may also support the use of risk-based metrics to deny sign-ins based on a variety of indicators. In AWS and GCP, IAM policies can contain `condition` attributes that verify arbitrary constraints such as the source IP, the date the request was made, and the nature of the resources or regions being requested.(Citation: AWS IAM Conditions)(Citation: GCP IAM Conditions) These measures help to prevent compromised credentials from resulting in unauthorized access to data or resources, as well as limit user permissions to only those required. \n\nBy modifying conditional access policies, such as adding additional trusted IP ranges, removing [Multi-Factor Authentication](https://attack.mitre.org/techniques/T1556/006) requirements, or allowing additional [Unused/Unsupported Cloud Regions](https://attack.mitre.org/techniques/T1535), adversaries may be able to ensure persistent access to accounts and circumvent defensive measures.",
                    "description_jp": "攻撃者は、条件付きアクセス・ポリシーを無効にしたり変更したりして、危殆化したア カウントへの永続的なアクセスを可能にすることがある。条件付きアクセス・ポリシーは、ID プロバイダおよび ID とアクセス管理システムによって使用 される追加の検証であり、リソースへのアクセスをユーザに許可すべきかどうかを決定する。\n\nたとえば、Entra ID、Okta、および JumpCloud では、IP アドレス、デバイスの登録状態、および多要素認証の使用に基づいて、ユー ザのアプリケーションへのアクセスを拒否することができる（引用：Microsoft Conditional Access）（引用：JumpCloud Conditional Access Policies）（引用：Okta Conditional Access Policies） 場合によっては、ID プロバイダは、さまざまな指標に基づいてサインインを拒否するリスクベースの測定 基準の使用もサポートしている。AWS と GCP では、IAM ポリシーに `condition` 属性を含めることができ、ソース IP、リクエストが行われた日付、リクエストされたリソースやリージョンの性質など、任意の制約を検証することができる（引用：AWS IAM Conditions）。\n\n信頼できる IP 範囲の追加、[多要素認証](https://attack.mitre.org/techniques/T1556/006) 要件の削除、[未使用/未サポートのクラウド領域](https://attack.mitre.org/techniques/T1535) の追加許可など、条件付きアクセスポリシーを変更することで、敵対者はアカウントへの永続的なアクセスを確保し、防御策を回避できる可能性がある。"
                },
                {
                    "id": "T1556.008",
                    "name_eng": "Network Provider DLL",
                    "name_jp": "ネットワークプロバイダDLL",
                    "description_eng": "Adversaries may register malicious network provider dynamic link libraries (DLLs) to capture cleartext user credentials during the authentication process. Network provider DLLs allow Windows to interface with specific network protocols and can also support add-on credential management functions.(Citation: Network Provider API) During the logon process, Winlogon (the interactive logon module) sends credentials to the local `mpnotify.exe` process via RPC. The `mpnotify.exe` process then shares the credentials in cleartext with registered credential managers when notifying that a logon event is happening.(Citation: NPPSPY - Huntress)(Citation: NPPSPY Video)(Citation: NPLogonNotify) \n\nAdversaries can configure a malicious network provider DLL to receive credentials from `mpnotify.exe`.(Citation: NPPSPY) Once installed as a credential manager (via the Registry), a malicious DLL can receive and save credentials each time a user logs onto a Windows workstation or domain via the `NPLogonNotify()` function.(Citation: NPLogonNotify)\n\nAdversaries may target planting malicious network provider DLLs on systems known to have increased logon activity and/or administrator logon activity, such as servers and domain controllers.(Citation: NPPSPY - Huntress)",
                    "description_jp": "攻撃者は、悪意のあるネットワークプロバイダ・ダイナミックリンク・ライブラリ（DLL）を登録し、認証プロセス中に平文のユーザー認証情報を取得する可能性がある。ネットワークプロバイダーDLLは、Windowsが特定のネットワークプロトコルとインターフェースすることを可能にし、アドオンの資格情報管理機能をサポートすることもできる(引用: Network Provider API)。ログオンプロセス中、Winlogon(対話型ログオンモジュール)はRPCを介してローカルの`mpnotify.exe`プロセスに資格情報を送信する。その後、`mpnotify.exe`プロセスは、ログオンイベントが発生していることを通知する際に、登録されたクレデンシャルマネージャとクレデンシャルをクリアテキストで共有する。 引用：NPPSPY - Huntress）（引用：NPPSPYビデオ）（引用：NPLogonNotify\n\n(引用: NPPSPY) 悪意のあるネットワークプロバイダ DLL は、`mpnotify.exe` から認証情報を受け取るように設定できる。(引用: NPPSPY) 認証情報マネージャとして (レジストリを介して) インストールされると、悪意のある DLL は、`NPLogonNotify()` 関数を介して、ユーザーが Windows ワークステーションまたはドメインにログオンするたびに認証情報を受け取り、保存できる。\n\n攻撃者は、サーバーやドメインコントローラなど、ログオンアクティビティや管理者ログオンアクティビティが増加していることが知られているシステムに、悪意のあるネットワークプロバイダ DLL を植え付けることを標的にする可能性がある(引用：NPPSPY - Huntress)。"
                },
                {
                    "id": "T1556.002",
                    "name_eng": "Password Filter DLL",
                    "name_jp": "パスワードフィルタDLL",
                    "description_eng": "Adversaries may register malicious password filter dynamic link libraries (DLLs) into the authentication process to acquire user credentials as they are validated. \n\nWindows password filters are password policy enforcement mechanisms for both domain and local accounts. Filters are implemented as DLLs containing a method to validate potential passwords against password policies. Filter DLLs can be positioned on local computers for local accounts and/or domain controllers for domain accounts. Before registering new passwords in the Security Accounts Manager (SAM), the Local Security Authority (LSA) requests validation from each registered filter. Any potential changes cannot take effect until every registered filter acknowledges validation. \n\nAdversaries can register malicious password filters to harvest credentials from local computers and/or entire domains. To perform proper validation, filters must receive plain-text credentials from the LSA. A malicious password filter would receive these plain-text credentials every time a password request is made.(Citation: Carnal Ownage Password Filters Sept 2013)",
                    "description_jp": "攻撃者は、悪意のあるパスワード・フィルタ・ダイナミック・リンク・ライブラリ（DLL）を認証プロセスに登録し、認証されたユーザー認証情報を取得する可能性がある。\n\nWindows パスワード・フィルタは、ドメイン・アカウントとローカル・アカウントの両方に対するパスワー ド・ポリシー強制メカニズムである。フィルタは、パスワードポリシーに照らして潜在的なパスワードを検証するメソッドを含む DLL として実装されます。フィルターDLLは、ローカルアカウントの場合はローカルコンピューター上に、 ドメインアカウントの場合はドメインコントローラー上に置くことができる。新しいパスワードをSecurity Accounts Manager (SAM)に登録する前に、Local Security Authority (LSA)は登録された各フィルタに検証を要求する。登録されたすべてのフィルタが検証を承認するまで、変更される可能性のある内容は有効にならない。\n\n攻撃者は、ローカルコンピュータやドメイン全体から認証情報を採取するために、悪意のあるパスワードフィルタを登録することができる。適切な検証を行うには、フィルタは LSA からプレーンテキストの認証情報を受け取らなければならない。悪意のあるパスワードフィルタは、パスワード要求が行われるたびに、これらのプレーンテキストの認証情報を受け取ることになる(引用：Carnal Ownage Password Filters Sept 2013)"
                },
                {
                    "id": "T1556.006",
                    "name_eng": "Multi-Factor Authentication",
                    "name_jp": "多要素認証",
                    "description_eng": "Adversaries may disable or modify multi-factor authentication (MFA) mechanisms to enable persistent access to compromised accounts.\n\nOnce adversaries have gained access to a network by either compromising an account lacking MFA or by employing an MFA bypass method such as [Multi-Factor Authentication Request Generation](https://attack.mitre.org/techniques/T1621), adversaries may leverage their access to modify or completely disable MFA defenses. This can be accomplished by abusing legitimate features, such as excluding users from Azure AD Conditional Access Policies, registering a new yet vulnerable/adversary-controlled MFA method, or by manually patching MFA programs and configuration files to bypass expected functionality.(Citation: Mandiant APT42)(Citation: Azure AD Conditional Access Exclusions)\n\nFor example, modifying the Windows hosts file (`C:\\windows\\system32\\drivers\\etc\\hosts`) to redirect MFA calls to localhost instead of an MFA server may cause the MFA process to fail. If a \"fail open\" policy is in place, any otherwise successful authentication attempt may be granted access without enforcing MFA. (Citation: Russians Exploit Default MFA Protocol - CISA March 2022) \n\nDepending on the scope, goals, and privileges of the adversary, MFA defenses may be disabled for individual accounts or for all accounts tied to a larger group, such as all domain accounts in a victim's network environment.(Citation: Russians Exploit Default MFA Protocol - CISA March 2022)",
                    "description_jp": "攻撃者は、侵害されたアカウントへの持続的なアクセスを可能にするために、多要素認証（MFA）メカニズムを無効にしたり、変更したりする可能性がある。\n\n敵対者は、MFA を欠くアカウントを侵害するか、[Multi-Factor Authentication Request Generation](https://attack.mitre.org/techniques/T1621) のような MFA バイパス手法を採用することでネットワークにアクセスできるようになると、そのアクセス権を活用して MFA 防御を変更したり、完全に無効にしたりする可能性があります。これは、Azure ADの条件付きアクセスポリシーからユーザーを除外する、新しいが脆弱である/敵に制御されたMFAメソッドを登録する、または期待される機能をバイパスするためにMFAプログラムや設定ファイルに手動でパッチを適用するなど、正当な機能を悪用することによって達成することができる。 引用：Mandiant APT42）（引用：Azure ADの条件付きアクセス除外について\n\n例えば、MFA 呼び出しを MFA サーバではなく localhost にリダイレクトするように、Windows の hosts ファイル（`C:∕windowssystem∕drivers∕drivers∕cachehosts`）を変更すると、MFA プロセスが失敗する可能性がある。フェイルオープン」ポリシーが設定されている場合、そうでなければ成功した認証の試みは、MFAを実施することなくアクセスが許可される可能性がある。(引用: ロシア人によるデフォルト MFA プロトコルの悪用 - CISA March 2022)\n\n敵対者の範囲、目的、権限によっては、MFA 防御が個々のアカウントに対して無効にされる場合もあれば、被害者のネットワーク環境内のすべてのドメインアカウントなど、より大きなグループに関連付けられたすべてのアカウントに対して無効にされる場合もある（引用：Russians Exploit Default MFA Protocol - CISA March 2022）。"
                },
                {
                    "id": "T1556.007",
                    "name_eng": "Hybrid Identity",
                    "name_jp": "ハイブリッド・アイデンティティ",
                    "description_eng": "Adversaries may patch, modify, or otherwise backdoor cloud authentication processes that are tied to on-premises user identities in order to bypass typical authentication mechanisms, access credentials, and enable persistent access to accounts.  \n\nMany organizations maintain hybrid user and device identities that are shared between on-premises and cloud-based environments. These can be maintained in a number of ways. For example, Microsoft Entra ID includes three options for synchronizing identities between Active Directory and Entra ID(Citation: Azure AD Hybrid Identity):\n\n* Password Hash Synchronization (PHS), in which a privileged on-premises account synchronizes user password hashes between Active Directory and Entra ID, allowing authentication to Entra ID to take place entirely in the cloud \n* Pass Through Authentication (PTA), in which Entra ID authentication attempts are forwarded to an on-premises PTA agent, which validates the credentials against Active Directory \n* Active Directory Federation Services (AD FS), in which a trust relationship is established between Active Directory and Entra ID \n\nAD FS can also be used with other SaaS and cloud platforms such as AWS and GCP, which will hand off the authentication process to AD FS and receive a token containing the hybrid users’ identity and privileges. \n\nBy modifying authentication processes tied to hybrid identities, an adversary may be able to establish persistent privileged access to cloud resources. For example, adversaries who compromise an on-premises server running a PTA agent may inject a malicious DLL into the `AzureADConnectAuthenticationAgentService` process that authorizes all attempts to authenticate to Entra ID, as well as records user credentials.(Citation: Azure AD Connect for Read Teamers)(Citation: AADInternals Azure AD On-Prem to Cloud) In environments using AD FS, an adversary may edit the `Microsoft.IdentityServer.Servicehost` configuration file to load a malicious DLL that generates authentication tokens for any user with any set of claims, thereby bypassing multi-factor authentication and defined AD FS policies.(Citation: MagicWeb)\n\nIn some cases, adversaries may be able to modify the hybrid identity authentication process from the cloud. For example, adversaries who compromise a Global Administrator account in an Entra ID tenant may be able to register a new PTA agent via the web console, similarly allowing them to harvest credentials and log into the Entra ID environment as any user.(Citation: Mandiant Azure AD Backdoors)",
                    "description_jp": "攻撃者は、典型的な認証メカニズムを迂回し、クレデンシャルにアクセスし、アカウントへの永続的なアクセスを可能にするために、オンプレミス・ユーザ・アイデンティティに関連付けられたクラウド認証プロセスにパッチを当てたり、修正したり、その他の方法でバックドアを仕掛ける可能性がある。  \n\n多くの組織が、オンプレミスとクラウドベースの環境間で共有されるハイブリッド・ユーザ・ アイデンティティとハイブリッド・デバイス・アイデンティティを維持している。これらは様々な方法で維持することができる。例えば、Microsoft Entra IDには、Active DirectoryとEntra IDの間でIDを同期するための3つのオプションがある（引用：Azure AD Hybrid Identity）：\n\n* オンプレミスの特権アカウントが Active Directory と Entra ID の間でユーザーのパスワードハッシュを同期することで、Entra ID への認証が完全にクラウドで行われるようにする。\n* Entra IDの認証試行がオンプレミスのPTAエージェントに転送され、PTAエージェントがActive Directoryに対して認証情報を検証します。\n* Active DirectoryとEntra IDの間に信頼関係が確立される。\n\nAD FSは、AWSやGCPなどの他のSaaSやクラウドプラットフォームでも使用することができ、認証プロセスをAD FSに渡し、ハイブリッドユーザーのIDと権限を含むトークンを受け取る。\n\nハイブリッド・アイデンティティに関連付けられた認証プロセスを変更することで、敵対者はクラウド・リソースへの永続的な特権アクセスを確立できる可能性があります。たとえば、PTA エージェントを実行しているオンプレミスのサーバーを侵害する敵対者は、Entra ID への認証のすべての試みを承認し、ユーザー資格情報を記録する `AzureADConnectAuthenticationAgentService` プロセスに悪意のある DLL を注入することができます。(引用: Azure AD Connect for Read Teamers)(引用: AADInternals Azure AD On-Prem to Cloud) AD FSを使用する環境では、敵対者が`Microsoft.IdentityServer.Servicehost`構成ファイルを編集して悪意のあるDLLをロードする可能性がある。この悪意のあるDLLは、任意のクレームセットを持つ任意のユーザーに対して認証トークンを生成するため、多要素認証と定義されたAD FSポリシーをバイパスする(引用: MagicWeb)。\n\n場合によっては、敵対者はクラウドからハイブリッド ID 認証プロセスを変更することができる。たとえば、Entra ID テナントのグローバル管理者アカウントを侵害した敵対者は、Web コンソールを介して新しい PTA エージェントを登録できる可能性があり、同様に認証情報を採取して任意のユーザーとして Entra ID 環境にログインできるようになります（引用：Mandiant Azure AD Backdoors）。"
                },
                {
                    "id": "T1556.005",
                    "name_eng": "Reversible Encryption",
                    "name_jp": "可逆暗号化",
                    "description_eng": "An adversary may abuse Active Directory authentication encryption properties to gain access to credentials on Windows systems. The <code>AllowReversiblePasswordEncryption</code> property specifies whether reversible password encryption for an account is enabled or disabled. By default this property is disabled (instead storing user credentials as the output of one-way hashing functions) and should not be enabled unless legacy or other software require it.(Citation: store_pwd_rev_enc)\n\nIf the property is enabled and/or a user changes their password after it is enabled, an adversary may be able to obtain the plaintext of passwords created/changed after the property was enabled. To decrypt the passwords, an adversary needs four components:\n\n1. Encrypted password (<code>G$RADIUSCHAP</code>) from the Active Directory user-structure <code>userParameters</code>\n2. 16 byte randomly-generated value (<code>G$RADIUSCHAPKEY</code>) also from <code>userParameters</code>\n3. Global LSA secret (<code>G$MSRADIUSCHAPKEY</code>)\n4. Static key hardcoded in the Remote Access Subauthentication DLL (<code>RASSFM.DLL</code>)\n\nWith this information, an adversary may be able to reproduce the encryption key and subsequently decrypt the encrypted password value.(Citation: how_pwd_rev_enc_1)(Citation: how_pwd_rev_enc_2)\n\nAn adversary may set this property at various scopes through Local Group Policy Editor, user properties, Fine-Grained Password Policy (FGPP), or via the ActiveDirectory [PowerShell](https://attack.mitre.org/techniques/T1059/001) module. For example, an adversary may implement and apply a FGPP to users or groups if the Domain Functional Level is set to \"Windows Server 2008\" or higher.(Citation: dump_pwd_dcsync) In PowerShell, an adversary may make associated changes to user settings using commands similar to <code>Set-ADUser -AllowReversiblePasswordEncryption $true</code>.",
                    "description_jp": "敵対者は、Active Directory 認証の暗号化プロパティを悪用して、Windows システム上の資格情報にアクセスする可能性がある。<code>AllowReversiblePasswordEncryption</code> プロパティは、アカウントの可逆パスワード暗号化を有効にするか無効にするかを指定します。デフォルトでは、このプロパティは無効になっており（代わりに一方向ハッシュ関数の出力としてユーザー認証情報を格納する）、レガシーや他のソフトウェアがそれを必要としない限り、有効にすべきではありません。\n\nこのプロパティが有効になっている場合、および/または有効になっている後にユーザーがパスワードを変更した場合、敵対者はプロパティが有効になってから作成/変更されたパスワードの平文を取得できる可能性があります。パスワードを解読するために、敵は4つのコンポーネントを必要とする：\n\n1.Active Directoryのユーザー構造<code>userParameters</code>から暗号化されたパスワード(<code>G$RADIUSCHAP</code>)。\n2.同じく<code>userParameters</code>から16バイトのランダムに生成された値(<code>G$RADIUSCHAPKEY</code>)\n3.グローバルLSAシークレット (<code>G$MSRADIUSCHAPKEY</code>)\n4.リモートアクセス下位認証DLLにハードコードされた静的キー (<code>RASSFM.DLL</code>)\n\nこの情報があれば、敵は暗号化キーを複製し、暗号化されたパスワード値を復号化できる可能性がある(引用：how_pwd_rev_enc_1)(引用：how_pwd_rev_enc_2)\n\n敵対者は、ローカルグループポリシーエディタ、ユーザープロパティ、FGPP(Fine-Grained Password Policy)、または ActiveDirectory [PowerShell](https://attack.mitre.org/techniques/T1059/001) モジュールを通して、様々なスコープでこのプロパティを設定することができる。(引用: dump_pwd_dcsync) PowerShellでは、敵は<code>Set-ADUser -AllowReversiblePasswordEncryption $true</code>のようなコマンドを使用して、ユーザー設定に関連する変更を行うことができます。"
                },
                {
                    "id": "T1556.003",
                    "name_eng": "Pluggable Authentication Modules",
                    "name_jp": "プラガブル認証モジュール",
                    "description_eng": "Adversaries may modify pluggable authentication modules (PAM) to access user credentials or enable otherwise unwarranted access to accounts. PAM is a modular system of configuration files, libraries, and executable files which guide authentication for many services. The most common authentication module is <code>pam_unix.so</code>, which retrieves, sets, and verifies account authentication information in <code>/etc/passwd</code> and <code>/etc/shadow</code>.(Citation: Apple PAM)(Citation: Man Pam_Unix)(Citation: Red Hat PAM)\n\nAdversaries may modify components of the PAM system to create backdoors. PAM components, such as <code>pam_unix.so</code>, can be patched to accept arbitrary adversary supplied values as legitimate credentials.(Citation: PAM Backdoor)\n\nMalicious modifications to the PAM system may also be abused to steal credentials. Adversaries may infect PAM resources with code to harvest user credentials, since the values exchanged with PAM components may be plain-text since PAM does not store passwords.(Citation: PAM Creds)(Citation: Apple PAM)",
                    "description_jp": "攻撃者は、pluggable authentication modules (PAM)を改変して、ユーザ認証情報にアクセスしたり、アカウントへの不当なアクセスを可能にしたりする可能性がある。PAM は、設定ファイル、ライブラリ、実行ファイルからなるモジュール・システムであり、 多くのサービスの認証を誘導する。最も一般的な認証モジュールは <code>pam_unix.so</code> であり、 <code>/etc/passwd</code> と <code>/etc/shadow</code> にあるアカウント認証情報を取得、設定、検証する。\n\n攻撃者はバックドアを作成するためにPAMシステムのコンポーネントを変更することができる。<code>pam_unix.so</code> のような PAM コンポーネントは、任意の敵が提供した値を正当な認証情報として受け入れるようにパッチを当てることができる。\n\nPAM システムに対する悪意のある変更も、クレデンシャルを盗むために悪用される可能性がある。PAM はパスワードを保存しないため、PAM コンポーネントと交換される値はプレーンテキストである可能性がある。(引用：PAM Creds)(引用：Apple PAM)"
                }
            ]
        }
    ]
}