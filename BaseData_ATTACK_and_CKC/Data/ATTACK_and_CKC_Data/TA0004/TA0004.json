{
    "id": "TA0004",
    "name_eng": "Privilege Escalation",
    "name_jp": "特権のエスカレーション",
    "description_eng": "The adversary is trying to gain higher-level permissions.\n\nPrivilege Escalation consists of techniques that adversaries use to gain higher-level permissions on a system or network. Adversaries can often enter and explore a network with unprivileged access but require elevated permissions to follow through on their objectives. Common approaches are to take advantage of system weaknesses, misconfigurations, and vulnerabilities. Examples of elevated access include: \n\n* SYSTEM/root level\n* local administrator\n* user account with admin-like access \n* user accounts with access to specific system or perform specific function\n\nThese techniques often overlap with Persistence techniques, as OS features that let an adversary persist can execute in an elevated context.",
    "description_jp": "敵はより高いレベルの許可を得ようとしている。\n\n特権の昇格は、敵対者がシステムやネットワーク上でより高いレベルのパーミッションを獲得するために使用するテクニックで構成されています。敵対者は、多くの場合、非特権アクセスでネットワークに侵入し、探索することができますが、目的を遂行するためには、上位の権限が必要になります。一般的なアプローチは、システムの弱点、設定ミス、脆弱性を利用することです。昇格アクセスには、次のような例があります：\n\n* SYSTEM/root レベル\n* ローカル管理者\n* 管理者レベルのユーザーアカウント\n* 特定のシステムへのアクセスまたは特定の機能を実行するユーザー・アカウント\n\n敵対者に永続性を持たせるOSの機能は、昇格したコンテキストで実行できるため、これらのテクニックは永続性のテクニックと重なることが多い。",
    "ckc_map_info": [
        {
            "ckc_id": "ckc-005",
            "ckc_phase_number": 5,
            "ckc_phase_name_en": "Installation",
            "ckc_description_en": "Attacker installs malware or establishes persistent access on the compromised system. This allows the attacker to maintain control for future activities.",
            "ckc_phase_name_jp": "インストール",
            "ckc_description_jp": "攻撃者は、侵害されたシステムにマルウェアをインストールするか、永続的なアクセスを確立します。これにより、攻撃者は将来の活動のために制御を維持できます。"
        },
        {
            "ckc_id": "ckc-006",
            "ckc_phase_number": 6,
            "ckc_phase_name_en": "Command and Control (C2)",
            "ckc_description_en": "Attacker establishes a communication channel with the compromised system to remotely control it, exfiltrate data, or issue further commands.",
            "ckc_phase_name_jp": "コマンド＆コントロール (C2)",
            "ckc_description_jp": "攻撃者は、侵害されたシステムとの通信チャネルを確立し、リモートで制御したり、データを窃取したり、さらなるコマンドを発行したりします。"
        }
    ],
    "ckc_mapping_rational": "より高い権限レベルを獲得する活動。インストールフェーズで高権限を確保したり、C2確立後にさらなる権限昇格を試みたりする。",
    "techniques": [
        {
            "id": "T1037",
            "name_eng": "Boot or Logon Initialization Scripts",
            "name_jp": "ブートまたはログオン初期化スクリプト",
            "description_eng": "Adversaries may use scripts automatically executed at boot or logon initialization to establish persistence.(Citation: Mandiant APT29 Eye Spy Email Nov 22)(Citation: Anomali Rocke March 2019) Initialization scripts can be used to perform administrative functions, which may often execute other programs or send information to an internal logging server. These scripts can vary based on operating system and whether applied locally or remotely.  \n\nAdversaries may use these scripts to maintain persistence on a single system. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary. \n\nAn adversary may also be able to escalate their privileges since some boot or logon initialization scripts run with higher privileges.",
            "description_jp": "攻撃者は、ブートやログオンの初期化時に自動的に実行されるスクリプトを使用して、永続性を確立する可能性があります（引用：Mandiant APT29 Eye Spy Email 11月22日）（引用：Anomali Rocke 2019年3月）初期化スクリプトは、管理機能を実行するために使用することができ、多くの場合、他のプログラムを実行したり、内部のログサーバーに情報を送信したりすることがあります。これらのスクリプトは、オペレーティング システムや、ローカルまたはリモートで適用されるかどうかによって異なります。  \n\n攻撃者は、これらのスクリプトを使用して、1つのシステム上で永続性を維持することがある。ログオンスクリプトのアクセス構成によっては、ローカル認証情報または管理者アカウントのいずれかが必要となる場合がある。\n\nまた、ブートスクリプトやログオン初期化スクリプトの中には、より高い特権で実行されるものがあるため、敵対者は特権をエスカレートできる可能性があります。",
            "subtechniques": [
                {
                    "id": "T1037.004",
                    "name_eng": "RC Scripts",
                    "name_jp": "RCスクリプト",
                    "description_eng": "Adversaries may establish persistence by modifying RC scripts, which are executed during a Unix-like system’s startup. These files allow system administrators to map and start custom services at startup for different run levels. RC scripts require root privileges to modify.\n\nAdversaries may establish persistence by adding a malicious binary path or shell commands to <code>rc.local</code>, <code>rc.common</code>, and other RC scripts specific to the Unix-like distribution.(Citation: IranThreats Kittens Dec 2017)(Citation: Intezer HiddenWasp Map 2019) Upon reboot, the system executes the script's contents as root, resulting in persistence.\n\nAdversary abuse of RC scripts is especially effective for lightweight Unix-like distributions using the root user as default, such as ESXi hypervisors, IoT, or embedded systems.(Citation: intezer-kaiji-malware) As ESXi servers store most system files in memory and therefore discard changes on shutdown, leveraging `/etc/rc.local.d/local.sh` is one of the few mechanisms for enabling persistence across reboots.(Citation: Juniper Networks ESXi Backdoor 2022)\n\nSeveral Unix-like systems have moved to Systemd and deprecated the use of RC scripts. This is now a deprecated mechanism in macOS in favor of [Launchd](https://attack.mitre.org/techniques/T1053/004).(Citation: Apple Developer Doco Archive Launchd)(Citation: Startup Items) This technique can be used on Mac OS X Panther v10.3 and earlier versions which still execute the RC scripts.(Citation: Methods of Mac Malware Persistence) To maintain backwards compatibility some systems, such as Ubuntu, will execute the RC scripts if they exist with the correct file permissions.(Citation: Ubuntu Manpage systemd rc)",
                    "description_jp": "攻撃者は、Unixライクなシステムのスタートアップ時に実行されるRCスクリプトを修正することで、永続性を確立することができる。これらのファイルにより、システム管理者はスタートアップ時に異なるランレベル用のカスタムサービスをマッピングして起動することができる。RCスクリプトを変更するには、root権限が必要である。\n\n攻撃者は、悪意のあるバイナリパスやシェルコマンドを<code>rc.local</code>、<code>rc.common</code>、およびUnixライクなディストリビューションに固有のその他のRCスクリプトに追加することで、永続性を確立する可能性があります。(引用: IranThreats Kittens Dec 2017)(Citation: Intezer HiddenWasp Map 2019) 再起動時に、システムはスクリプトの内容をrootとして実行し、永続性をもたらします。\n\nRCスクリプトを悪用する攻撃者は、ESXiハイパーバイザー、IoT、組み込みシステムなど、デフォルトでrootユーザーを使用する軽量のUnix系ディストリビューションで特に効果的です。(引用：intezer-kaiji-malware) ESXiサーバーはほとんどのシステムファイルをメモリに保存するため、シャットダウン時に変更を破棄します。\n\nいくつかのUnixライクなシステムはSystemdに移行し、RCスクリプトの使用を非推奨とした。これは現在、macOSでは非推奨のメカニズムであり、[Launchd](https://attack.mitre.org/techniques/T1053/004)を採用しています。(引用: Apple Developer Doco Archive Launchd)(Citation: Startup Items) このテクニックは、RCスクリプトをまだ実行しているMac OS X Panther v10.3以前のバージョンでも使用できます。(引用: Methods of Mac Malware Persistence) 後方互換性を維持するために、Ubuntuなどの一部のシステムでは、RCスクリプトが正しいファイルパーミッションで存在する場合、RCスクリプトを実行します。(引用: Ubuntu Manpage systemd rc)"
                },
                {
                    "id": "T1037.001",
                    "name_eng": "Logon Script (Windows)",
                    "name_jp": "ログオン・スクリプト（Windows）",
                    "description_eng": "Adversaries may use Windows logon scripts automatically executed at logon initialization to establish persistence. Windows allows logon scripts to be run whenever a specific user or group of users log into a system.(Citation: TechNet Logon Scripts) This is done via adding a path to a script to the <code>HKCU\\Environment\\UserInitMprLogonScript</code> Registry key.(Citation: Hexacorn Logon Scripts)\n\nAdversaries may use these scripts to maintain persistence on a single system. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.",
                    "description_jp": "攻撃者は、ログオン初期化時に自動的に実行されるWindowsログオンスクリプトを使用して、永続性を確立する可能性がある。Windowsでは、特定のユーザーまたはユーザーグループがシステムにログインするたびにログオンスクリプトを実行することができます（引用：TechNet Logon Scripts）。これは、スクリプトへのパスを<code>HKCUUentEnvormentUserInitMprLogonScript</code>レジストリキーに追加することで実行されます（引用：Hexacorn Logon Scripts）。\n\n攻撃者はこれらのスクリプトを使用して、1つのシステム上で永続性を維持する可能性がある。ログオンスクリプトのアクセス構成によっては、ローカル認証情報または管理者アカウントが必要になる場合があります。"
                },
                {
                    "id": "T1037.003",
                    "name_eng": "Network Logon Script",
                    "name_jp": "ネットワークログオンスクリプト",
                    "description_eng": "Adversaries may use network logon scripts automatically executed at logon initialization to establish persistence. Network logon scripts can be assigned using Active Directory or Group Policy Objects.(Citation: Petri Logon Script AD) These logon scripts run with the privileges of the user they are assigned to. Depending on the systems within the network, initializing one of these scripts could apply to more than one or potentially all systems.  \n \nAdversaries may use these scripts to maintain persistence on a network. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.",
                    "description_jp": "攻撃者は、ログオン初期化時に自動的に実行されるネットワークログオンスクリプトを使用して、永続性を確立する可能性がある。ネットワークログオンスクリプトは、Active Directoryまたはグループポリシーオブジェクトを使用して割り当てることができます（引用：Petri Logon Script AD）。これらのログオンスクリプトは、割り当てられたユーザーの権限で実行されます。ネットワーク内のシステムによっては、これらのスクリプトの1つを初期化すると、複数のシステム、またはすべてのシステムに適用される可能性がある。  \n \n攻撃者は、これらのスクリプトを使用して、ネットワーク上の永続性を維持する可能性がある。ログオンスクリプトのアクセス構成によっては、ローカル認証情報または管理者アカウ ントが必要になる場合があります。"
                },
                {
                    "id": "T1037.005",
                    "name_eng": "Startup Items",
                    "name_jp": "スタートアップ・アイテム",
                    "description_eng": "Adversaries may use startup items automatically executed at boot initialization to establish persistence. Startup items execute during the final phase of the boot process and contain shell scripts or other executable files along with configuration information used by the system to determine the execution order for all startup items.(Citation: Startup Items)\n\nThis is technically a deprecated technology (superseded by [Launch Daemon](https://attack.mitre.org/techniques/T1543/004)), and thus the appropriate folder, <code>/Library/StartupItems</code> isn’t guaranteed to exist on the system by default, but does appear to exist by default on macOS Sierra. A startup item is a directory whose executable and configuration property list (plist), <code>StartupParameters.plist</code>, reside in the top-level directory. \n\nAn adversary can create the appropriate folders/files in the StartupItems directory to register their own persistence mechanism.(Citation: Methods of Mac Malware Persistence) Additionally, since StartupItems run during the bootup phase of macOS, they will run as the elevated root user.",
                    "description_jp": "攻撃者は、ブート初期化時に自動的に実行されるスタートアップ項目を使用して、永続性を確立する可能性がある。スタートアップアイテムは、ブートプロセスの最終段階で実行され、シェルスクリプトやその他の実行可能ファイルを、システムがすべてのスタートアップアイテムの実行順序を決定するために使用する設定情報とともに含んでいる(引用：スタートアップアイテム)。\n\nこれは技術的に非推奨の技術であり（[Launch Daemon](https://attack.mitre.org/techniques/T1543/004) に取って代わられた）、したがって適切なフォルダ <code>/Library/StartupItems</code> がデフォルトでシステムに存在することは保証されていませんが、macOS Sierra ではデフォルトで存在するようです。スタートアップアイテムは、実行ファイルと設定プロパティリスト（plist）である<code>StartupParameters.plist</code>が最上位ディレクトリに存在するディレクトリです。\n\n敵対者は、StartupItemsディレクトリ内に適切なフォルダ/ファイルを作成し、独自の永続化メカニズムを登録することができる（引用：Methods of Mac Malware Persistence）。さらに、StartupItemsはmacOSの起動フェーズで実行されるため、昇格したルートユーザーとして実行される。"
                },
                {
                    "id": "T1037.002",
                    "name_eng": "Login Hook",
                    "name_jp": "ログインフック",
                    "description_eng": "Adversaries may use a Login Hook to establish persistence executed upon user logon. A login hook is a plist file that points to a specific script to execute with root privileges upon user logon. The plist file is located in the <code>/Library/Preferences/com.apple.loginwindow.plist</code> file and can be modified using the <code>defaults</code> command-line utility. This behavior is the same for logout hooks where a script can be executed upon user logout. All hooks require administrator permissions to modify or create hooks.(Citation: Login Scripts Apple Dev)(Citation: LoginWindowScripts Apple Dev) \n\nAdversaries can add or insert a path to a malicious script in the <code>com.apple.loginwindow.plist</code> file, using the <code>LoginHook</code> or <code>LogoutHook</code> key-value pair. The malicious script is executed upon the next user login. If a login hook already exists, adversaries can add additional commands to an existing login hook. There can be only one login and logout hook on a system at a time.(Citation: S1 macOs Persistence)(Citation: Wardle Persistence Chapter)\n\n**Note:** Login hooks were deprecated in 10.11 version of macOS in favor of [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) and [Launch Agent](https://attack.mitre.org/techniques/T1543/001)",
                    "description_jp": "攻撃者は、ユーザーログオン時に実行される永続性を確立するために、ログインフックを使用する可能性がある。ログインフックは、ユーザーログオン時にroot権限で実行される特定のスクリプトを指すplistファイルです。plistファイルは<code>/Library/Preferences/com.apple.loginwindow.plist<//code>ファイルにあり、<code>defaults<//code>コマンドラインユーティリティを使って変更できます。この動作は、ユーザーのログアウト時にスクリプトを実行できるログアウトフックでも同じです。すべてのフックには、フックを変更または作成するための管理者権限が必要です。(引用: Login Scripts Apple Dev)(Citation: LoginWindowScripts Apple Dev)\n\n攻撃者は、<code>LoginHook</code>または<code>LogoutHook</code>のキーと値のペアを使用して、悪意のあるスクリプトへのパスを<code>com.apple.loginwindow.plist</code>ファイルに追加または挿入できます。悪意のあるスクリプトは、次のユーザーログイン時に実行されます。ログインフックがすでに存在する場合、敵対者は既存のログインフックにコマンドを追加することができます。ログインフックとログアウトフックは、システム上に一度に1つしか存在できない(引用：S1 macOs Persistence)(引用：Wardle Persistence Chapter)\n\n**注: **ログインフックは、macOSの10.11バージョンで非推奨となり、[Launch Daemon](https://attack.mitre.org/techniques/T1543/004) と [Launch Agent](https://attack.mitre.org/techniques/T1543/001) が採用されました。"
                }
            ]
        },
        {
            "id": "T1543",
            "name_eng": "Create or Modify System Process",
            "name_jp": "システムプロセスの作成または変更",
            "description_eng": "Adversaries may create or modify system-level processes to repeatedly execute malicious payloads as part of persistence. When operating systems boot up, they can start processes that perform background system functions. On Windows and Linux, these system processes are referred to as services.(Citation: TechNet Services) On macOS, launchd processes known as [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) and [Launch Agent](https://attack.mitre.org/techniques/T1543/001) are run to finish system initialization and load user specific parameters.(Citation: AppleDocs Launch Agent Daemons) \n\nAdversaries may install new services, daemons, or agents that can be configured to execute at startup or a repeatable interval in order to establish persistence. Similarly, adversaries may modify existing services, daemons, or agents to achieve the same effect.  \n\nServices, daemons, or agents may be created with administrator privileges but executed under root/SYSTEM privileges. Adversaries may leverage this functionality to create or modify system processes in order to escalate privileges.(Citation: OSX Malware Detection)",
            "description_jp": "攻撃者は、システムレベルのプロセスを作成または変更し、永続化の一環として悪意のあるペイロードを繰り返し実行する可能性があります。オペレーティングシステムが起動すると、バックグラウンドのシステム機能を実行するプロセスを開始することができる。引用：TechNet Services） macOSでは、[Launch Daemon](https://attack.mitre.org/techniques/T1543/004)および[Launch Agent](https://attack.mitre.org/techniques/T1543/001)として知られるlaunchdプロセスが実行され、システムの初期化を完了し、ユーザー固有のパラメータをロードします。\n\n攻撃者は、永続性を確立するために、起動時または繰り返し実行されるように設定できる新しいサービス、デーモン、またはエージェントをインストールすることができる。同様に、敵対者は既存のサービス、デーモン、またはエージェントを変更して、同じ効果を得ることもできる。  \n\nサービス、デーモン、またはエージェントは、管理者権限で作成されるが、root/SYSTEM 権限で実行されるかもしれない。敵はこの機能を利用して、特権をエスカレートさせるためにシステムプロセスを作成または変更する可能性があります。 引用：OSXマルウェア検出",
            "subtechniques": [
                {
                    "id": "T1543.004",
                    "name_eng": "Launch Daemon",
                    "name_jp": "デーモン起動",
                    "description_eng": "Adversaries may create or modify Launch Daemons to execute malicious payloads as part of persistence. Launch Daemons are plist files used to interact with Launchd, the service management framework used by macOS. Launch Daemons require elevated privileges to install, are executed for every user on a system prior to login, and run in the background without the need for user interaction. During the macOS initialization startup, the launchd process loads the parameters for launch-on-demand system-level daemons from plist files found in <code>/System/Library/LaunchDaemons/</code> and <code>/Library/LaunchDaemons/</code>. Required Launch Daemons parameters include a <code>Label</code> to identify the task, <code>Program</code> to provide a path to the executable, and <code>RunAtLoad</code> to specify when the task is run. Launch Daemons are often used to provide access to shared resources, updates to software, or conduct automation tasks.(Citation: AppleDocs Launch Agent Daemons)(Citation: Methods of Mac Malware Persistence)(Citation: launchd Keywords for plists)\n\nAdversaries may install a Launch Daemon configured to execute at startup by using the <code>RunAtLoad</code> parameter set to <code>true</code> and the <code>Program</code> parameter set to the malicious executable path. The daemon name may be disguised by using a name from a related operating system or benign software (i.e. [Masquerading](https://attack.mitre.org/techniques/T1036)). When the Launch Daemon is executed, the program inherits administrative permissions.(Citation: WireLurker)(Citation: OSX Malware Detection)\n\nAdditionally, system configuration changes (such as the installation of third party package managing software) may cause folders such as <code>usr/local/bin</code> to become globally writeable. So, it is possible for poor configurations to allow an adversary to modify executables referenced by current Launch Daemon's plist files.(Citation: LaunchDaemon Hijacking)(Citation: sentinelone macos persist Jun 2019)",
                    "description_jp": "攻撃者は、永続化の一環として悪意のあるペイロードを実行するためにLaunch Daemonを作成または変更する可能性があります。Launch Daemonは、macOSで使用されるサービス管理フレームワークであるLaunchdとやり取りするために使用されるplistファイルです。Launch Daemonのインストールには昇格権限が必要で、ログイン前にシステム上のすべてのユーザーに対して実行され、ユーザーの操作を必要とせずにバックグラウンドで実行されます。macOS の初期化起動中に、launchd プロセスは、<code>/System/Library/LaunchDaemons/</code> および <code>/Library/LaunchDaemons/</code> にある plist ファイルから、起動オンデマンドのシステムレベルデーモンのパラメータをロードします。Launch Daemons の必須パラメータには、タスクを識別するための <code>Label</code> 、実行ファイルへのパスを提供する <code>Program</code> 、タスクが実行されるタイミングを指定する <code>RunAtLoad</code> が含まれます。Launchデーモンは、共有リソースへのアクセス、ソフトウェアのアップデート、自動化タスクの実行によく使用されます。 (引用: AppleDocs Launch Agent Daemons)(Citation: Methods of Mac Malware Persistence)(Citation: launchd Plistsのキーワード)\n\n攻撃者は、<code>RunAtLoad</code> パラメータを <code>true</code> に設定し、<code>Program</code> パラメータを悪意のある実行可能パスに設定することで、起動時に実行するように設定された Launch Daemon をインストールすることができます。デーモン名は、関連するオペレーティングシステムまたは良性のソフトウェアからの名前を使用して偽装することができます（すなわち、[Masquerading](https://attack.mitre.org/techniques/T1036)）。Launch Daemonが実行されると、プログラムは管理者権限を継承します。(引用：WireLurker)(引用：OSX Malware Detection)\n\nさらに、システム設定の変更（サードパーティ製のパッケージ管理ソフトウェアのインストールなど）によって、<code>usr/local/bin</code>などのフォルダがグローバルに書き込み可能になることがあります。そのため、設定の不備によって、現在のLaunch Daemonのplistファイルによって参照される実行可能ファイルを敵対者が変更できる可能性があります。 引用：LaunchDaemonハイジャック）（引用：sentinelone macos persist 2019年6月号"
                },
                {
                    "id": "T1543.005",
                    "name_eng": "Container Service",
                    "name_jp": "コンテナサービス",
                    "description_eng": "Adversaries may create or modify container or container cluster management tools that run as daemons, agents, or services on individual hosts. These include software for creating and managing individual containers, such as Docker and Podman, as well as container cluster node-level agents such as kubelet. By modifying these services, an adversary may be able to achieve persistence or escalate their privileges on a host.\n\nFor example, by using the `docker run` or `podman run` command with the `restart=always` directive, a container can be configured to persistently restart on the host.(Citation: AquaSec TeamTNT 2023) A user with access to the (rootful) docker command may also be able to escalate their privileges on the host.(Citation: GTFOBins Docker)\n\nIn Kubernetes environments, DaemonSets allow an adversary to persistently [Deploy Container](https://attack.mitre.org/techniques/T1610)s on all nodes, including ones added later to the cluster.(Citation: Aquasec Kubernetes Attack 2023)(Citation: Kubernetes DaemonSet) Pods can also be deployed to specific nodes using the `nodeSelector` or `nodeName` fields in the pod spec.(Citation: Kubernetes Assigning Pods to Nodes)(Citation: AppSecco Kubernetes Namespace Breakout 2020)\n\nNote that containers can also be configured to run as [Systemd Service](https://attack.mitre.org/techniques/T1543/002)s.(Citation: Podman Systemd)(Citation: Docker Systemd)",
                    "description_jp": "攻撃者は、個々のホスト上でデーモン、エージェント、またはサービスとして実行されるコンテナまたはコンテナ・クラスタ管理ツールを作成または変更する可能性があります。これには、DockerやPodmanなどの個々のコンテナを作成および管理するソフトウェアや、kubeletなどのコンテナ・クラスタ・ノード・レベルのエージェントが含まれます。これらのサービスを変更することで、敵はホスト上で永続性を実現したり、特権をエスカレートしたりできる可能性があります。\n\n例えば、`docker run`コマンドや`podman run`コマンドに`restart=always`ディレクティブを指定することで、コンテナをホスト上で持続的に再起動するように設定することができる。(引用：AquaSec TeamTNT 2023) また、(rootfulな)dockerコマンドにアクセスできるユーザーであれば、ホスト上で特権をエスカレートできる可能性がある。\n\nKubernetes環境では、DaemonSetによって、敵対者は、クラスタに後から追加されたものも含め、すべてのノード上で永続的に[Deploy Container](https://attack.mitre.org/techniques/T1610)することができます。(引用: Aquasec Kubernetes Attack 2023)(引用: Kubernetes DaemonSet) Podは、Pod specの`nodeSelector`または`nodeName`フィールドを使用して特定のノードにデプロイすることもできます(引用: Kubernetes Assigning Pods to Nodes)(引用: AppSecco Kubernetes Namespace Breakout 2020)\n\nコンテナは[Systemd Service](https://attack.mitre.org/techniques/T1543/002)として実行するように設定することもできることに注意してください。(引用: Podman Systemd)(引用: Docker Systemd)"
                },
                {
                    "id": "T1543.001",
                    "name_eng": "Launch Agent",
                    "name_jp": "ローンチエージェント",
                    "description_eng": "Adversaries may create or modify launch agents to repeatedly execute malicious payloads as part of persistence. When a user logs in, a per-user launchd process is started which loads the parameters for each launch-on-demand user agent from the property list (.plist) file found in <code>/System/Library/LaunchAgents</code>, <code>/Library/LaunchAgents</code>, and <code>~/Library/LaunchAgents</code>.(Citation: AppleDocs Launch Agent Daemons)(Citation: OSX Keydnap malware) (Citation: Antiquated Mac Malware) Property list files use the <code>Label</code>, <code>ProgramArguments </code>, and <code>RunAtLoad</code> keys to identify the Launch Agent's name, executable location, and execution time.(Citation: OSX.Dok Malware) Launch Agents are often installed to perform updates to programs, launch user specified programs at login, or to conduct other developer tasks.\n\n Launch Agents can also be executed using the [Launchctl](https://attack.mitre.org/techniques/T1569/001) command.\n \nAdversaries may install a new Launch Agent that executes at login by placing a .plist file into the appropriate folders with the <code>RunAtLoad</code> or <code>KeepAlive</code> keys set to <code>true</code>.(Citation: Sofacy Komplex Trojan)(Citation: Methods of Mac Malware Persistence) The Launch Agent name may be disguised by using a name from the related operating system or benign software. Launch Agents are created with user level privileges and execute with user level permissions.(Citation: OSX Malware Detection)(Citation: OceanLotus for OS X)",
                    "description_jp": "攻撃者は、永続性の一部として悪意のあるペイロードを繰り返し実行するために、ローンチエージェントを作成または変更する可能性があります。ユーザーがログインすると、ユーザーごとの launchd プロセスが開始され、<code>/System/Library/LaunchAgents</code>、<code>/Library/LaunchAgents</code>、<code>~/Library/LaunchAgents</code> にあるプロパティリスト (.plist) ファイルから、各 launch-on-demand ユーザーエージェントのパラメータがロードされます。(引用：AppleDocs Launch Agent Daemons)(引用：OSX Keydnap malware)(引用：Antiquated Mac Malware) プロパティリストファイルは、<code>Label</code>、<code>ProgramArguments</code>、<code>RunAtLoad</code>キーを使用して、Launch Agentの名前、実行可能な場所、および実行時間を特定します。(引用：OSX.Dok Malware) Launch Agentは、プログラムのアップデートを実行したり、ログイン時にユーザーが指定したプログラムを起動したり、その他の開発者タスクを実行したりするためにインストールされることがよくあります。\n\n 起動エージェントは、[Launchctl](https://attack.mitre.org/techniques/T1569/001)コマンドを使用して実行することもできます。\n \n攻撃者は、<code>RunAtLoad</code>キーまたは<code>KeepAlive</code>キーを<code>true</code>に設定した.plistファイルを適切なフォルダに配置することで、ログイン時に実行される新しいLaunch Agentをインストールすることができます（引用：Sofacy Komplex Trojan）（引用：Methods of Mac Malware Persistence）Launch Agentの名前は、関連するオペレーティングシステムまたは良性のソフトウェアの名前を使用して偽装することができます。起動エージェントは、ユーザーレベルの権限で作成され、ユーザーレベルの権限で実行されます。 引用：OSXマルウェア検出）（引用：OceanLotus for OS X"
                },
                {
                    "id": "T1543.002",
                    "name_eng": "Systemd Service",
                    "name_jp": "Systemdサービス",
                    "description_eng": "Adversaries may create or modify systemd services to repeatedly execute malicious payloads as part of persistence. Systemd is a system and service manager commonly used for managing background daemon processes (also known as services) and other system resources.(Citation: Linux man-pages: systemd January 2014) Systemd is the default initialization (init) system on many Linux distributions replacing legacy init systems, including SysVinit and Upstart, while remaining backwards compatible.  \n\nSystemd utilizes unit configuration files with the `.service` file extension to encode information about a service's process. By default, system level unit files are stored in the `/systemd/system` directory of the root owned directories (`/`). User level unit files are stored in the `/systemd/user` directories of the user owned directories (`$HOME`).(Citation: lambert systemd 2022) \n\nInside the `.service` unit files, the following directives are used to execute commands:(Citation: freedesktop systemd.service)  \n\n* `ExecStart`, `ExecStartPre`, and `ExecStartPost` directives execute when a service is started manually by `systemctl` or on system start if the service is set to automatically start.\n* `ExecReload` directive executes when a service restarts. \n* `ExecStop`, `ExecStopPre`, and `ExecStopPost` directives execute when a service is stopped.  \n\nAdversaries have created new service files, altered the commands a `.service` file’s directive executes, and modified the user directive a `.service` file executes as, which could result in privilege escalation. Adversaries may also place symbolic links in these directories, enabling systemd to find these payloads regardless of where they reside on the filesystem.(Citation: Anomali Rocke March 2019)(Citation: airwalk backdoor unix systems)(Citation: Rapid7 Service Persistence 22JUNE2016) \n\nThe `.service` file’s User directive can be used to run service as a specific user, which could result in privilege escalation based on specific user/group permissions. \n\nSystemd services can be created via systemd generators, which support the dynamic generation of unit files. Systemd generators are small executables that run during boot or configuration reloads to dynamically create or modify systemd unit files by converting non-native configurations into services, symlinks, or drop-ins (i.e., [Boot or Logon Initialization Scripts](https://attack.mitre.org/techniques/T1037)).(Citation: Elastic Security Labs Linux Persistence 2024)(Citation: Pepe Berba Systemd 2022)",
                    "description_jp": "攻撃者は、永続化の一環として悪意のあるペイロードを繰り返し実行するために、systemdサービスを作成または変更する可能性があります。Systemdは、バックグラウンドのデーモンプロセス（サービスとも呼ばれる）やその他のシステムリソースを管理するために一般的に使用されるシステムおよびサービスマネージャです。(引用: Linux man-pages: systemd January 2014) Systemdは、多くのLinuxディストリビューションで、SysVinitやUpstartなどのレガシーなinitシステムに取って代わるデフォルトの初期化（init）システムです。  \n\nSystemd はサービスのプロセスに関する情報をエンコードするために `.service` ファイル拡張子を持つユニット設定ファイルを利用します。デフォルトでは、システムレベルのユニットファイルはルート所有ディレクトリ (`//`) の `/systemd/system` ディレクトリに格納されます。ユーザーレベルのユニットファイルは、ユーザー所有のディレクトリ (`$HOME`) の `/systemd/user` ディレクトリに格納される。(引用: lambert systemd 2022)\n\nユニットファイル `.service` 内では、以下のディレクティブがコマンド実行に使用される:(引用: freedesktop systemd.service)\n\n* ExecStart`、`ExecStartPre`、`ExecStartPost` ディレクティブは、サービスが `systemctl` によって手動で起動されたとき、またはサービスが自動的に起動するように設定されている場合はシステム起動時に実行されます。\n* ExecReload` ディレクティブはサービスが再起動したときに実行される。\n* ExecStop`, `ExecStopPre`, `ExecStopPost` ディレクティブはサービスが停止したときに実行される。  \n\n逆境者は新しいサービスファイルを作成したり、`.service` ファイルのディレクティブが実行するコマンドを変更したり、`.service` ファイルが実行するユーザディレクティブを変更したりして、特権を昇格させる可能性があります。攻撃者はまた、これらのディレクトリにシンボリックリンクを設置し、ファイルシステムのどこに存在するかに関係なく、systemd がこれらのペイロードを見つけられるようにする可能性があります。(引用: Anomali Rocke March 2019)(引用: airwalk backdoor unix systems)(引用: Rapid7 Service Persistence 22JUNE2016)\n\n.service`ファイルのUserディレクティブは、特定のユーザーとしてサービスを実行するために使用することができ、特定のユーザー/グループのパーミッションに基づいて特権の昇格を引き起こす可能性があります。\n\nSystemd サービスは、ユニットファイルの動的生成をサポートする systemd ジェネレータを使って作成できます。Systemd ジェネレータは、ブートや設定のリロード中に実行される小さな実行ファイルで、ネイティブでない設定をサービスやシンボリックリンク、ドロップイン（[Boot or Logon Initialization Scripts](https://attack.mitre.org/techniques/T1037)など）に変換することで、systemd ユニットファイルを動的に作成または変更します。(引用: Elastic Security Labs Linux Persistence 2024)(Citation: Pepe Berba Systemd 2022)"
                },
                {
                    "id": "T1543.003",
                    "name_eng": "Windows Service",
                    "name_jp": "Windowsサービス",
                    "description_eng": "Adversaries may create or modify Windows services to repeatedly execute malicious payloads as part of persistence. When Windows boots up, it starts programs or applications called services that perform background system functions.(Citation: TechNet Services) Windows service configuration information, including the file path to the service's executable or recovery programs/commands, is stored in the Windows Registry.\n\nAdversaries may install a new service or modify an existing service to execute at startup in order to persist on a system. Service configurations can be set or modified using system utilities (such as sc.exe), by directly modifying the Registry, or by interacting directly with the Windows API. \n\nAdversaries may also use services to install and execute malicious drivers. For example, after dropping a driver file (ex: `.sys`) to disk, the payload can be loaded and registered via [Native API](https://attack.mitre.org/techniques/T1106) functions such as `CreateServiceW()` (or manually via functions such as `ZwLoadDriver()` and `ZwSetValueKey()`), by creating the required service Registry values (i.e. [Modify Registry](https://attack.mitre.org/techniques/T1112)), or by using command-line utilities such as `PnPUtil.exe`.(Citation: Symantec W.32 Stuxnet Dossier)(Citation: Crowdstrike DriveSlayer February 2022)(Citation: Unit42 AcidBox June 2020) Adversaries may leverage these drivers as [Rootkit](https://attack.mitre.org/techniques/T1014)s to hide the presence of malicious activity on a system. Adversaries may also load a signed yet vulnerable driver onto a compromised machine (known as \"Bring Your Own Vulnerable Driver\" (BYOVD)) as part of [Exploitation for Privilege Escalation](https://attack.mitre.org/techniques/T1068).(Citation: ESET InvisiMole June 2020)(Citation: Unit42 AcidBox June 2020)\n\nServices may be created with administrator privileges but are executed under SYSTEM privileges, so an adversary may also use a service to escalate privileges. Adversaries may also directly start services through [Service Execution](https://attack.mitre.org/techniques/T1569/002).\n\nTo make detection analysis more challenging, malicious services may also incorporate [Masquerade Task or Service](https://attack.mitre.org/techniques/T1036/004) (ex: using a service and/or payload name related to a legitimate OS or benign software component). Adversaries may also create ‘hidden’ services (i.e., [Hide Artifacts](https://attack.mitre.org/techniques/T1564)), for example by using the `sc sdset` command to set service permissions via the Service Descriptor Definition Language (SDDL). This may hide a Windows service from the view of standard service enumeration methods such as `Get-Service`, `sc query`, and `services.exe`.(Citation: SANS 1)(Citation: SANS 2)",
                    "description_jp": "攻撃者は、永続化の一環として悪意のあるペイロードを繰り返し実行するために、Windowsサービスを作成または変更する可能性がある。Windowsが起動すると、バックグラウンドのシステム機能を実行するサービスと呼ばれるプログラムやアプリケーションが起動する（引用：TechNet Services）。サービスの実行ファイルや回復プログラム/コマンドへのファイルパスを含むWindowsサービス構成情報は、Windowsレジストリに保存される。\n\n攻撃者は、システム上で持続するために、新しいサービスをインストールしたり、既存のサービスを変更して起動時に実行したりする可能性がある。サービスコンフィギュレーションは、システムユーティリティ（sc.exeなど）を使用するか、レジストリを直接変更するか、Windows APIと直接やりとりすることで設定または変更できる。\n\n攻撃者はまた、サービスを使って悪意のあるドライバーをインストールし、実行することもある。例えば、ドライバファイル(ex: `.sys`)をディスクにドロップした後、`CreateServiceW()`のような[Native API](https://attack.mitre.org/techniques/T1106)関数(または `ZwLoadDriver()`や`ZwSetValueKey()`のような関数を介して手動で)、必要なサービスレジストリ値を作成することによって、ペイロードをロードして登録することができる。レジストリの変更](https://attack.mitre.org/techniques/T1112) などの関数を使用するか、`PnPUtil.exe` などのコマンドラインユーティリティを使用します。Stuxnet Dossier)(Citation: Crowdstrike DriveSlayer February 2022)(Citation: Unit42 AcidBox June 2020) 敵対者は、これらのドライバを[Rootkit](https://attack.mitre.org/techniques/T1014)として活用し、システム上の悪意のある活動の存在を隠す可能性があります。攻撃者はまた、[Exploitation for Privilege Escalation](https://attack.mitre.org/techniques/T1068)の一環として、署名済みでありながら脆弱なドライバを侵害されたマシンにロードする可能性があります(「Bring Your Own Vulnerable Driver」(BYOVD)として知られています)(引用: ESET InvisiMole 2020年6月)(引用: Unit42 AcidBox 2020年6月)\n\nサービスは管理者権限で作成されますが、SYSTEM権限で実行されるため、敵は特権をエスカレートさせるためにサービスを使用する可能性もあります。また、敵は[Service Execution](https://attack.mitre.org/techniques/T1569/002)を通じてサービスを直接起動することもできます。\n\n検出分析をより困難にするために、悪意のあるサービスは[マスカレードタスクまたはサービス](https://attack.mitre.org/techniques/T1036/004)(例：正規のOSまたは良性のソフトウェアコンポーネントに関連するサービス名および/またはペイロード名を使用)を組み込むこともあります。例えば、`sc sdset` コマンドを使用して、Service Descriptor Definition Language (SDDL) 経由でサービスのパーミッションを設定します。これは、`Get-Service`、`sc query`、`services.exe`などの標準的なサービス列挙メソッドの視界からWindowsサービスを隠す可能性がある（引用：SANS 1）（引用：SANS 2）。"
                }
            ]
        },
        {
            "id": "T1547",
            "name_eng": "Boot or Logon Autostart Execution",
            "name_jp": "ブートまたはログオンの自動開始実行",
            "description_eng": "Adversaries may configure system settings to automatically execute a program during system boot or logon to maintain persistence or gain higher-level privileges on compromised systems. Operating systems may have mechanisms for automatically running a program on system boot or account logon.(Citation: Microsoft Run Key)(Citation: MSDN Authentication Packages)(Citation: Microsoft TimeProvider)(Citation: Cylance Reg Persistence Sept 2013)(Citation: Linux Kernel Programming) These mechanisms may include automatically executing programs that are placed in specially designated directories or are referenced by repositories that store configuration information, such as the Windows Registry. An adversary may achieve the same goal by modifying or extending features of the kernel.\n\nSince some boot or logon autostart programs run with higher privileges, an adversary may leverage these to elevate privileges.",
            "description_jp": "攻撃者は、侵害されたシステム上で永続性を維持したり、より高いレベルの特権を獲得したりするために、システムの起動時やログオン時にプログラムを自動的に実行するようにシステム設定を構成することがあります。オペレーティングシステムは、システムブート時またはアカウントログオン時にプログラムを自動的に実行するメカニズムを備えている場合があります（引用：Microsoft Run Key）（引用：MSDN Authentication Packages）（引用：Microsoft TimeProvider）（引用：Cylance Reg Persistence Sept 2013）（引用：Linux Kernel Programming）これらのメカニズムには、特別に指定されたディレクトリに配置されたプログラムを自動的に実行したり、Windowsレジストリなどの構成情報を格納するリポジトリから参照されたりする場合があります。敵対者は、カーネルの機能を変更または拡張することで、同じ目標を達成することができる。\n\nブートまたはログオンの自動開始プログラムの中には、より高い特権で実行されるものがあるため、敵対者はこれらを利用して特権を昇格させる可能性がある。",
            "subtechniques": [
                {
                    "id": "T1547.009",
                    "name_eng": "Shortcut Modification",
                    "name_jp": "ショートカットの変更",
                    "description_eng": "Adversaries may create or modify shortcuts that can execute a program during system boot or user login. Shortcuts or symbolic links are used to reference other files or programs that will be opened or executed when the shortcut is clicked or executed by a system startup process.\n\nAdversaries may abuse shortcuts in the startup folder to execute their tools and achieve persistence.(Citation: Shortcut for Persistence ) Although often used as payloads in an infection chain (e.g. [Spearphishing Attachment](https://attack.mitre.org/techniques/T1566/001)), adversaries may also create a new shortcut as a means of indirection, while also abusing [Masquerading](https://attack.mitre.org/techniques/T1036) to make the malicious shortcut appear as a legitimate program. Adversaries can also edit the target path or entirely replace an existing shortcut so their malware will be executed instead of the intended legitimate program.\n\nShortcuts can also be abused to establish persistence by implementing other methods. For example, LNK browser extensions may be modified (e.g. [Browser Extensions](https://attack.mitre.org/techniques/T1176/001)) to persistently launch malware.",
                    "description_jp": "攻撃者は、システム起動中やユーザーログイン中にプログラムを実行できるショートカットを作成または変更する可能性があります。ショートカットやシンボリックリンクは、そのショートカットがクリックされたり、システムの起動プロセスで実行されたりしたときに開かれたり実行されたりする他のファイルやプログラムを参照するために使用されます。\n\n攻撃者は、スタートアップフォルダ内のショートカットを悪用してツールを実行し、永続性を実現することがあります。(引用: 永続性を実現するショートカット) 感染チェーンのペイロードとして使用されることがよくありますが (例: [Spearphishing Attachment](https://attack.mitre.org/techniques/T1566/001)) 、攻撃者は、不正なショートカットを正規のプログラムのように見せるために [Masquerading] (https://attack.mitre.org/techniques/T1036) を悪用しながら、間接的な手段として新しいショートカットを作成することもあります。また、標的のパスを編集したり、既存のショートカットを完全に置き換えたりすることで、意図した正規プログラムの代わりにマルウェアを実行させることも可能です。\n\nまた、ショートカットを悪用して、他の方法を実装することで永続性を確立することも可能です。たとえば、LNKブラウザの拡張機能を変更して（[ブラウザ拡張機能](https://attack.mitre.org/techniques/T1176/001)など）、マルウェアを持続的に起動させることができます。"
                },
                {
                    "id": "T1547.006",
                    "name_eng": "Kernel Modules and Extensions",
                    "name_jp": "カーネルモジュールと拡張機能",
                    "description_eng": "Adversaries may modify the kernel to automatically execute programs on system boot. Loadable Kernel Modules (LKMs) are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system.(Citation: Linux Kernel Programming) \n\nWhen used maliciously, LKMs can be a type of kernel-mode [Rootkit](https://attack.mitre.org/techniques/T1014) that run with the highest operating system privilege (Ring 0).(Citation: Linux Kernel Module Programming Guide) Common features of LKM based rootkits include: hiding itself, selective hiding of files, processes and network activity, as well as log tampering, providing authenticated backdoors, and enabling root access to non-privileged users.(Citation: iDefense Rootkit Overview)\n\nKernel extensions, also called kext, are used in macOS to load functionality onto a system similar to LKMs for Linux. Since the kernel is responsible for enforcing security and the kernel extensions run as apart of the kernel, kexts are not governed by macOS security policies. Kexts are loaded and unloaded through <code>kextload</code> and <code>kextunload</code> commands. Kexts need to be signed with a developer ID that is granted privileges by Apple allowing it to sign Kernel extensions. Developers without these privileges may still sign kexts but they will not load unless SIP is disabled. If SIP is enabled, the kext signature is verified before being added to the AuxKC.(Citation: System and kernel extensions in macOS)\n\nSince macOS Catalina 10.15, kernel extensions have been deprecated in favor of System Extensions. However, kexts are still allowed as \"Legacy System Extensions\" since there is no System Extension for Kernel Programming Interfaces.(Citation: Apple Kernel Extension Deprecation)\n\nAdversaries can use LKMs and kexts to conduct [Persistence](https://attack.mitre.org/tactics/TA0003) and/or [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) on a system. Examples have been found in the wild, and there are some relevant open source projects as well.(Citation: Volatility Phalanx2)(Citation: CrowdStrike Linux Rootkit)(Citation: GitHub Reptile)(Citation: GitHub Diamorphine)(Citation: RSAC 2015 San Francisco Patrick Wardle)(Citation: Synack Secure Kernel Extension Broken)(Citation: Securelist Ventir)(Citation: Trend Micro Skidmap)",
                    "description_jp": "攻撃者は、システム起動時に自動的にプログラムを実行するようにカーネルを変更する可能性があります。ローダブルカーネルモジュール（LKM）は、要求に応じてカーネルにロードしたりアンロードしたりできるコードの断片です。システムを再起動することなく、カーネルの機能を拡張します。例えば、モジュールの一種にデバイス・ドライバがあり、カーネルがシステムに接続されたハードウェアにアクセスできるようにする。 引用：Linuxカーネル・プログラミング\n\n悪意を持って使用された場合、LKMはカーネルモード[ルートキット](https://attack.mitre.org/techniques/T1014)の一種となり、オペレーティングシステムの最高権限(Ring 0)で実行されます(引用: Linux Kernel Module Programming Guide)。LKMベースのルートキットの一般的な機能には、自身を隠すこと、ファイル、プロセス、ネットワーク活動の選択的な非表示、およびログの改ざん、認証済みのバックドアの提供、非特権ユーザーへのルートアクセスの有効化などがあります(引用: iDefense Rootkit Overview)。\n\nkextとも呼ばれるカーネル拡張機能は、LinuxのLKMと同様にシステムに機能をロードするためにmacOSで使用されます。カーネルはセキュリティを実施する責任があり、カーネル拡張機能はカーネルの一部として実行されるため、kextはmacOSのセキュリティポリシーに支配されません。Kextsは<code>kextload</code>と<code>kextunload</code>コマンドでロードとアンロードを行います。Kext は、Apple からカーネル拡張に署名できる権限を与えられた開発者 ID で署名する必要があります。これらの権限を持たない開発者でもkextに署名することはできますが、SIPが無効になっていない限りロードされません。SIPが有効になっている場合、kextの署名はAuxKCに追加される前に検証されます。(引用: macOSにおけるシステムとカーネル拡張)\n\nmacOS Catalina 10.15以降、カーネル拡張機能は廃止され、システム拡張機能が使用されるようになりました。しかし、カーネルプログラミングインタフェースのシステム拡張がないため、kextは「レガシーシステム拡張」として許可されています。\n\n攻撃者は LKM と kext を使って、システム上で [Persistence](https://attack.mitre.org/tactics/TA0003) や [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) を行うことができます。例としては、Volatility Phalanx2)(引用: CrowdStrike Linux Rootkit)(引用: GitHub Reptile)(引用: GitHub Diamorphine)(引用: RSAC 2015 San Francisco Patrick Wardle)(引用: Synack Secure Kernel Extension Broken)(引用: Securelist Ventir)(引用: Trend Micro Skidmap)"
                },
                {
                    "id": "T1547.007",
                    "name_eng": "Re-opened Applications",
                    "name_jp": "再募集",
                    "description_eng": "Adversaries may modify plist files to automatically run an application when a user logs in. When a user logs out or restarts via the macOS Graphical User Interface (GUI), a prompt is provided to the user with a checkbox to \"Reopen windows when logging back in\".(Citation: Re-Open windows on Mac) When selected, all applications currently open are added to a property list file named <code>com.apple.loginwindow.[UUID].plist</code> within the <code>~/Library/Preferences/ByHost</code> directory.(Citation: Methods of Mac Malware Persistence)(Citation: Wardle Persistence Chapter) Applications listed in this file are automatically reopened upon the user’s next logon.\n\nAdversaries can establish [Persistence](https://attack.mitre.org/tactics/TA0003) by adding a malicious application path to the <code>com.apple.loginwindow.[UUID].plist</code> file to execute payloads when a user logs in.",
                    "description_jp": "攻撃者は、ユーザーがログインしたときに自動的にアプリケーションを実行するようにplistファイルを変更する可能性がある。ユーザーがmacOSのグラフィカル・ユーザー・インターフェース（GUI）を使ってログアウトまたは再起動すると、「再ログイン時にウィンドウを開き直す」というチェックボックスが付いたプロンプトが表示される（引用：Re-Open windows on Mac）。apple.loginwindow.[UUID].plist<//code>という名前のプロパティ リスト ファイルに追加されます。(引用: Mac マルウェア永続化の方法)(引用: Wardle 永続化の章) このファイルにリストされているアプリケーションは、ユーザーの次のログオン時に自動的に再開されます。\n\n攻撃者は、<code>com.apple.loginwindow.[UUID].plist</code>ファイルに悪意のあるアプリケーションのパスを追加することで、[Persistence](https://attack.mitre.org/tactics/TA0003)を確立し、ユーザーがログインしたときにペイロードを実行することができます。"
                },
                {
                    "id": "T1547.004",
                    "name_eng": "Winlogon Helper DLL",
                    "name_jp": "ウィンログオンヘルパーDLL",
                    "description_eng": "Adversaries may abuse features of Winlogon to execute DLLs and/or executables when a user logs in. Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete. Registry entries in <code>HKLM\\Software[\\\\Wow6432Node\\\\]\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> and <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> are used to manage additional helper programs and functionalities that support Winlogon.(Citation: Cylance Reg Persistence Sept 2013) \n\nMalicious modifications to these Registry keys may cause Winlogon to load and execute malicious DLLs and/or executables. Specifically, the following subkeys have been known to be possibly vulnerable to abuse: (Citation: Cylance Reg Persistence Sept 2013)\n\n* Winlogon\\Notify - points to notification package DLLs that handle Winlogon events\n* Winlogon\\Userinit - points to userinit.exe, the user initialization program executed when a user logs on\n* Winlogon\\Shell - points to explorer.exe, the system shell executed when a user logs on\n\nAdversaries may take advantage of these features to repeatedly execute malicious code and establish persistence.",
                    "description_jp": "攻撃者はWinlogonの機能を悪用し、ユーザーがログインした際にDLLや実行ファイルを実行する可能性がある。Winlogon.exe は、ログオン/ログオフ時のアクションや、Ctrl-Alt-Delete によってトリガーされるセキュア アテンション シーケンス (SAS) を担当する Windows コンポーネントです。<code>HKLMSoftware[◆Wow6432Node]◆MicrosoftWindows NTCurrentVersion</code>と<code>HKCUSoftware</code>のレジストリエントリは、Winlogonをサポートする追加のヘルパープログラムと機能を管理するために使用される(Citation: Cylance Reg Persistence Sept 2013)\n\nこれらのレジストリキーに悪意のある変更を加えると、Winlogonが悪意のあるDLLや実行可能ファイルをロードして実行する可能性があります。具体的には、以下のサブキーが悪用される可能性があることが知られています: (引用: Cylance Reg Persistence Sept 2013)\n\n* WinlogonNotify - Winlogonイベントを処理する通知パッケージDLLを指す。\n* WinlogonUserinit - userinit.exe（ユーザーがログオンしたときに実行されるユーザー初期化プログラム）を指す。\n* WinlogonShell - explorer.exe（ユーザがログオンしたときに実行されるシス テムシェル）を指す。\n\nWinlogonShell-ユーザがログオンしたときに実行されるシステム・シェルであるexplorer.exeを指す。"
                },
                {
                    "id": "T1547.005",
                    "name_eng": "Security Support Provider",
                    "name_jp": "セキュリティ・サポート・プロバイダー",
                    "description_eng": "Adversaries may abuse security support providers (SSPs) to execute DLLs when the system boots. Windows SSP DLLs are loaded into the Local Security Authority (LSA) process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user's Domain password or smart card PINs.\n\nThe SSP configuration is stored in two Registry keys: <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages</code> and <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig\\Security Packages</code>. An adversary may modify these Registry keys to add new SSPs, which will be loaded the next time the system boots, or when the AddSecurityPackage Windows API function is called.(Citation: Graeber 2014)",
                    "description_jp": "攻撃者は、セキュリティサポートプロバイダ（SSP）を悪用して、システム起動時に DLL を実行する可能性がある。WindowsのSSP DLLは、システム起動時にローカルセキュリティオーソリティ（LSA）プロセスにロードされる。LSA にロードされると、SSP DLL は、ログオンしているユーザーのドメイン・パスワードやスマート・カードの PIN など、Windows に保存されている暗号化されたパスワードや平文のパスワードにアクセスできるようになる。\n\nSSP 構成は、2つのレジストリ・キーに格納される：<Code>HKLMSYSTEM\\CurrentControlSetControlLsaSecurity Packages</code> と <Code>HKLMSYSTEM\\CurrentControlSetControlLsaOSConfig\\Security Packages</code> である。敵対者は、これらのレジストリ・キーを変更して新しいSSPを追加し、次回システム起動時、またはAddSecurityPackage Windows API関数が呼び出されたときにロードする可能性がある(Citation: Graeber 2014)。"
                },
                {
                    "id": "T1547.001",
                    "name_eng": "Registry Run Keys / Startup Folder",
                    "name_jp": "レジストリの実行キー / スタートアップフォルダ",
                    "description_eng": "Adversaries may achieve persistence by adding a program to a startup folder or referencing it with a Registry run key. Adding an entry to the \"run keys\" in the Registry or startup folder will cause the program referenced to be executed when a user logs in.(Citation: Microsoft Run Key) These programs will be executed under the context of the user and will have the account's associated permissions level.\n\nThe following run keys are created by default on Windows systems:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code>\n\nRun keys may exist under multiple hives.(Citation: Microsoft Wow6432Node 2018)(Citation: Malwarebytes Wow6432Node 2016) The <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx</code> is also available but is not created by default on Windows Vista and newer. Registry run key entries can reference programs directly or list them as a dependency.(Citation: Microsoft Run Key) For example, it is possible to load a DLL at logon using a \"Depend\" key with RunOnceEx: <code>reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\0001\\Depend /v 1 /d \"C:\\temp\\evil[.]dll\"</code> (Citation: Oddvar Moe RunOnceEx Mar 2018)\n\nPlacing a program within a startup folder will also cause that program to execute when a user logs in. There is a startup folder location for individual user accounts as well as a system-wide startup folder that will be checked regardless of which user account logs in. The startup folder path for the current user is <code>C:\\Users\\\\[Username]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup</code>. The startup folder path for all users is <code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp</code>.\n\nThe following Registry keys can be used to set startup folder items for persistence:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n\nThe following Registry keys can control automatic startup of services during boot:\n\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices</code>\n\nUsing policy settings to specify startup programs creates corresponding values in either of two Registry keys:\n\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run</code>\n\nPrograms listed in the load value of the registry key <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> run automatically for the currently logged-on user.\n\nBy default, the multistring <code>BootExecute</code> value of the registry key <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager</code> is set to <code>autocheck autochk *</code>. This value causes Windows, at startup, to check the file-system integrity of the hard disks if the system has been shut down abnormally. Adversaries can add other programs or processes to this registry value which will automatically launch at boot.\n\nAdversaries can use these configuration locations to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use [Masquerading](https://attack.mitre.org/techniques/T1036) to make the Registry entries look as if they are associated with legitimate programs.",
                    "description_jp": "攻撃者は、プログラムをスタートアップフォルダに追加したり、レジストリのランキーで参照したりすることで、永続性を実現することができる。レジストリまたはスタートアップフォルダの「実行キー」にエントリを追加すると、ユーザーがログインしたときに参照されたプログラムが実行されるようになる（引用：Microsoft Run Key）。\n\nWindowsシステムでは、以下のランキーがデフォルトで作成される：\n\n* <code>HKEY_CURRENT_USERSoftwareMicrosoftWindows\\CurrentVersion\\Run</code>\n* <code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersionRunOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\MicrosoftWindows\\CurrentVersion</code>Run</code>\n* <code>HKEY_LOCAL_MACHINE_Software\\MicrosoftWindows\\CurrentVersion\\RunOnce</code>\n\nランキーは複数のハイブの下に存在する可能性があります。(引用: Microsoft Wow6432Node 2018)(引用: Malwarebytes Wow6432Node 2016) <code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindows\\CurrentVersionRunOnceEx</code> も利用可能ですが、Windows Vista以降ではデフォルトでは作成されません。レジストリのランキーエントリは、プログラムを直接参照することも、依存関係としてリストすることもできます。 引用：Microsoft Run Key） 例えば、RunOnceExで「Depend」キーを使用してログオン時にDLLをロードすることが可能です：<code>reg add HKLMSOFTWARE\\MicrosoftWindowsCurrentVersionRunOnceEx0001Depend /v 1 /d \"C:゙temp\\evil[.]dll\"</code> （引用：Oddvar Moe RunOnceEx 2018年3月号\n\nスタートアップフォルダ内にプログラムを配置すると、ユーザーがログインしたときにそのプログラムが実行されるようにもなる。個々のユーザーアカウント用のスタートアップフォルダーの場所と、どのユーザーアカウントがログインしてもチェックされるシステム全体のスタートアップフォルダーがあります。現在のユーザーのスタートアップフォルダのパスは<code>C:¥Users¥Windows¥AppData¥Roaming¥Microsoft¥Windows¥Start Menu¥ProgramsStartup</code>である。全ユーザのスタートアップフォルダのパスは<code>C:¥ProgramData¥Microsoft¥Windows¥Start Menu¥Programs¥StartUp</code>です。\n\n以下のレジストリ・キーを使用して、永続化するスタートアップ・フォルダ項目を設定できます：\n\n<code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n* <code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersionExplorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWAREMicrosoftWindows\\CurrentVersion ReplicaShell Folders</code>\n* <code>HKEY_LOCAL_MACHINE ProxySOFTWARE</code> * <code>HKEY_LOCAL_MACHINE ProxySOFTWARE</code> * <code>HKEY_LOCAL_MACHINE ProxySOFTWARE</code\n\n以下のレジストリキーは、ブート時のサービスの自動起動を制御できます：\n\n<code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_CURRENT_USERソフトウェアの章\n* <code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindows\\CurrentVersionRunServices</code>\n* <code>HKEY_CURRENT_USER\\SoftwareMicrosoftWindows\\CurrentVersion\\RunServices</code>\n\nポリシー設定を使用してスタートアップ プログラムを指定すると、2 つのレジストリ キーのいずれかに対応する値が作成されます：\n\n<code>HKEY_LOCAL_MACHINE\\SoftwareMicrosoftWindowsCurrentVersion\\Policies\\Explorer\\Run</code>\n<code>HKEY_CURRENT_USER Software\\MicrosoftWindows\\CurrentVersion\\Policies\\Explorer</Run</code>\n\nレジストリキー<code>HKEY_CURRENT_USER</code>のロード値にリストされているプログラムは、現在ログオンしているユーザーに対して自動的に実行されます。\n\nデフォルトでは、レジストリ・キー<code>HKEY_LOCAL_MACHINE</code>の</code>BootExecute</code>値は<code>autocheck autochk *</code>に設定されています。この値は、システムが異常にシャットダウンされた場合、起動時にWindowsがハード ディスクのファイル システムの整合性をチェックするようにします。攻撃者は、起動時に自動的に起動する他のプログラムやプロセスを、このレジストリ値に追加することができる。\n\n攻撃者は、リモートアクセスツールなどのマルウェアを実行するために、これらの設定ロケーションを使用し、システムの再起動を通じて永続性を維持することができます。また、攻撃者は[Masquerading](https://attack.mitre.org/techniques/T1036)を使用して、レジストリエントリが正規のプログラムに関連付けられているかのように見せかけることもできます。"
                },
                {
                    "id": "T1547.008",
                    "name_eng": "LSASS Driver",
                    "name_jp": "LSASSドライバー",
                    "description_eng": "Adversaries may modify or add LSASS drivers to obtain persistence on compromised systems. The Windows security subsystem is a set of components that manage and enforce the security policy for a computer or domain. The Local Security Authority (LSA) is the main component responsible for local security policy and user authentication. The LSA includes multiple dynamic link libraries (DLLs) associated with various other security functions, all of which run in the context of the LSA Subsystem Service (LSASS) lsass.exe process.(Citation: Microsoft Security Subsystem)\n\nAdversaries may target LSASS drivers to obtain persistence. By either replacing or adding illegitimate drivers (e.g., [Hijack Execution Flow](https://attack.mitre.org/techniques/T1574)), an adversary can use LSA operations to continuously execute malicious payloads.",
                    "description_jp": "攻撃者はLSASSドライバを変更または追加して、侵害されたシステム上で永続性を得ることができる。Windowsセキュリティサブシステムは、コンピュータやドメインのセキュリティポリシーを管理・実施するコンポーネントの集合である。ローカルセキュリティオーソリティ（LSA）は、ローカルセキュリティポリシーとユーザー認証を担当する主要コンポーネントである。LSAには、他のさまざまなセキュリティ機能に関連する複数のダイナミックリンクライブラリ（DLL）が含まれており、これらはすべてLSAサブシステムサービス（LSASS）lsass.exeプロセスのコンテキストで実行される（引用：Microsoft Security Subsystem）。\n\n攻撃者は、LSASSドライバを標的として永続性を獲得する可能性があります。不正なドライバ(例えば、[Hijack Execution Flow](https://attack.mitre.org/techniques/T1574))を置き換えたり追加したりすることで、敵対者はLSAオペレーションを使用して悪意のあるペイロードを継続的に実行することができます。"
                },
                {
                    "id": "T1547.012",
                    "name_eng": "Print Processors",
                    "name_jp": "プリントプロセッサー",
                    "description_eng": "Adversaries may abuse print processors to run malicious DLLs during system boot for persistence and/or privilege escalation. Print processors are DLLs that are loaded by the print spooler service, `spoolsv.exe`, during boot.(Citation: Microsoft Intro Print Processors)\n\nAdversaries may abuse the print spooler service by adding print processors that load malicious DLLs at startup. A print processor can be installed through the <code>AddPrintProcessor</code> API call with an account that has <code>SeLoadDriverPrivilege</code> enabled. Alternatively, a print processor can be registered to the print spooler service by adding the <code>HKLM\\SYSTEM\\\\[CurrentControlSet or ControlSet001]\\Control\\Print\\Environments\\\\[Windows architecture: e.g., Windows x64]\\Print Processors\\\\[user defined]\\Driver</code> Registry key that points to the DLL.\n\nFor the malicious print processor to be correctly installed, the payload must be located in the dedicated system print-processor directory, that can be found with the <code>GetPrintProcessorDirectory</code> API call, or referenced via a relative path from this directory.(Citation: Microsoft AddPrintProcessor May 2018) After the print processors are installed, the print spooler service, which starts during boot, must be restarted in order for them to run.(Citation: ESET PipeMon May 2020)\n\nThe print spooler service runs under SYSTEM level permissions, therefore print processors installed by an adversary may run under elevated privileges.",
                    "description_jp": "攻撃者はプリントプロセッサを悪用して、システムブート中に悪意のある DLL を実行し、永続化や権限昇格を行う可能性がある。プリントプロセッサは、ブート中にプリントスプーラサービスである `spoolsv.exe` によってロードされる DLL である。(引用: Microsoft Intro Print Processors)\n\n攻撃者は、起動時に悪意のあるDLLをロードするプリントプロセッサを追加することで、プリントスプーラサービスを悪用する可能性があります。プリント プロセッサは、<code>SeLoadDriverPrivilege</code> を有効にしたアカウントで、<code>AddPrintProcessor</code> API 呼び出しによってインストールできます。または、DLLを指すレジストリキー<code>HKLMSYSTEM</code>[CurrentControlSet or ControlSet001]◆ControlPrint</code>[Windowsアーキテクチャ: 例: Windows x64]◆Print Processors</code>[ユーザー定義]◆Driver</code>を追加することで、プリントプロセッサをプリントスプーラサービスに登録できます。\n\n悪意のあるプリント プロセッサが正しくインストールされるには、ペイロードが専用のシステム プリント プロセッサ ディレクトリに配置されている必要があり、このディレクトリは <code>GetPrintProcessorDirectory</code> API 呼び出しで見つけることができるか、このディレクトリからの相対パスを介して参照されます (引用: Microsoft AddPrintProcessor 2018年5月)。プリント プロセッサがインストールされた後、それらを実行するには、ブート中に起動するプリント スプーラ サービスを再起動する必要があります (引用: ESET PipeMon 2020年5月)。\n\nプリントスプーラサービスはSYSTEMレベルの権限で実行されるため、敵がインストールしたプリントプロセッサは昇格した権限で実行される可能性があります。"
                },
                {
                    "id": "T1547.014",
                    "name_eng": "Active Setup",
                    "name_jp": "アクティブセットアップ",
                    "description_eng": "Adversaries may achieve persistence by adding a Registry key to the Active Setup of the local machine. Active Setup is a Windows mechanism that is used to execute programs when a user logs in. The value stored in the Registry key will be executed after a user logs into the computer.(Citation: Klein Active Setup 2010) These programs will be executed under the context of the user and will have the account's associated permissions level.\n\nAdversaries may abuse Active Setup by creating a key under <code> HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\</code> and setting a malicious value for <code>StubPath</code>. This value will serve as the program that will be executed when a user logs into the computer.(Citation: Mandiant Glyer APT 2010)(Citation: Citizenlab Packrat 2015)(Citation: FireEye CFR Watering Hole 2012)(Citation: SECURELIST Bright Star 2015)(Citation: paloalto Tropic Trooper 2016)\n\nAdversaries can abuse these components to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use [Masquerading](https://attack.mitre.org/techniques/T1036) to make the Registry entries look as if they are associated with legitimate programs.",
                    "description_jp": "攻撃者は、ローカル・マシンのアクティブ・セットアップにレジストリ・キーを追加することで、永続性を実現することができる。アクティブ・セットアップは、ユーザーがログインしたときにプログラムを実行するために使用されるWindowsのメカニズムである。レジストリ・キーに格納された値は、ユーザがコンピュータにログインした後に実行される(引用: Klein Active Setup 2010)。これらのプログラムは、ユーザのコンテキスト下で実行され、アカウントに関連付けられた権限レベルを持つ。\n\n攻撃者は、<code> HKLMSOFTWAREMicrosoftActive Setup\\Installed Components</code>の下にキーを作成し、<code>StubPath</code>に悪意のある値を設定することで、Active Setupを悪用する可能性があります。この値は、ユーザーがコンピュータにログインしたときに実行されるプログラムとして機能します。 引用：Mandiant Glyer APT 2010）（ 引用：Citizenlab Packrat 2015）（ 引用：FireEye CFR Watering Hole 2012）（ 引用：SECURELIST Bright Star 2015）（ 引用：paloalto Tropic Trooper 2016\n\n攻撃者はこれらのコンポーネントを悪用して、リモートアクセスツールなどのマルウェアを実行し、システムの再起動を通じて永続性を維持することができます。また、攻撃者は[Masquerading](https://attack.mitre.org/techniques/T1036)を使用して、レジストリエントリが正規のプログラムに関連付けられているかのように見せかけることもあります。"
                },
                {
                    "id": "T1547.015",
                    "name_eng": "Login Items",
                    "name_jp": "ログイン項目",
                    "description_eng": "Adversaries may add login items to execute upon user login to gain persistence or escalate privileges. Login items are applications, documents, folders, or server connections that are automatically launched when a user logs in.(Citation: Open Login Items Apple) Login items can be added via a shared file list or Service Management Framework.(Citation: Adding Login Items) Shared file list login items can be set using scripting languages such as [AppleScript](https://attack.mitre.org/techniques/T1059/002), whereas the Service Management Framework uses the API call <code>SMLoginItemSetEnabled</code>.\n\nLogin items installed using the Service Management Framework leverage <code>launchd</code>, are not visible in the System Preferences, and can only be removed by the application that created them.(Citation: Adding Login Items)(Citation: SMLoginItemSetEnabled Schroeder 2013) Login items created using a shared file list are visible in System Preferences, can hide the application when it launches, and are executed through LaunchServices, not launchd, to open applications, documents, or URLs without using Finder.(Citation: Launch Services Apple Developer) Users and applications use login items to configure their user environment to launch commonly used services or applications, such as email, chat, and music applications.\n\nAdversaries can utilize [AppleScript](https://attack.mitre.org/techniques/T1059/002) and [Native API](https://attack.mitre.org/techniques/T1106) calls to create a login item to spawn malicious executables.(Citation: ELC Running at startup) Prior to version 10.5 on macOS, adversaries can add login items by using [AppleScript](https://attack.mitre.org/techniques/T1059/002) to send an Apple events to the “System Events” process, which has an AppleScript dictionary for manipulating login items.(Citation: Login Items AE) Adversaries can use a command such as <code>tell application “System Events” to make login item at end with properties /path/to/executable</code>.(Citation: Startup Items Eclectic)(Citation: hexed osx.dok analysis 2019)(Citation: Add List Remove Login Items Apple Script) This command adds the path of the malicious executable to the login item file list located in <code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm</code>.(Citation: Startup Items Eclectic) Adversaries can also use login items to launch executables that can be used to control the victim system remotely or as a means to gain privilege escalation by prompting for user credentials.(Citation: objsee mac malware 2017)(Citation: CheckPoint Dok)(Citation: objsee netwire backdoor 2019)",
                    "description_jp": "攻撃者は、ユーザーのログイン時に実行するログイン項目を追加して、永続性を得たり特権を昇格させたりする可能性がある。ログイン項目とは、ユーザーがログインしたときに自動的に起動されるアプリケーション、ドキュメント、フォルダ、またはサーバー接続のことです。(引用: Open Login Items Apple) ログイン項目は、共有ファイルリストまたはサービス管理フレームワークを介して追加することができます。(引用: Adding Login Items) 共有ファイルリストのログイン項目は、次のようなスクリプト言語を使って設定できます。 [AppleScript](https://attack.mitre.org/techniques/T1059/002), 一方、Service Management FrameworkはAPIコール<code>SMLoginItemSetEnabled</code>を使用します。\n\nサービス管理フレームワークのレバレッジ<code>launchd</code>を使用してインストールされたログイン項目は、システム環境設定には表示されず、それらを作成したアプリケーションによってのみ削除することができます。(引用: Adding Login Items)(引用: SMLoginItemSetEnabled Schroeder 2013) 共有ファイルリストを使用して作成されたログイン項目は、システム環境設定で表示され、起動時にアプリケーションを隠すことができ、launchdではなくLaunchServicesを介して実行され、Finderを使用せずにアプリケーション、ドキュメント、またはURLを開くことができます。(引用: Launch Services Apple Developer) ユーザーやアプリケーションは、ログイン項目を使用してユーザー環境を設定し、電子メール、チャット、音楽アプリケーションなど、よく使用されるサービスやアプリケーションを起動します。\n\n攻撃者は、[AppleScript](https://attack.mitre.org/techniques/T1059/002)および[Native API](https://attack.mitre.org/techniques/T1106)コールを利用してログイン項目を作成し、悪意のある実行可能ファイルを生成することができます。(引用: ELC Running at startup) macOSのバージョン10.5以前では、敵対者は[AppleScript](https://attack.mitre.org/techniques/T1059/002)を使用して、ログイン項目を操作するためのAppleScript辞書を持つ「システムイベント」プロセスにAppleイベントを送信することで、ログイン項目を追加することができる。(引用: Login Items AE) 攻撃者は、 <code>tell application “System Events” to make login item at end with properties /path/to/executable</code> のようなコマンドを使うことができます。(引用: Startup Items Eclectic)(引用: hexed osx.dok analysis 2019)(引用: Add List Remove Login Items Apple Script) このコマンドは、 <code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm</code> にあるログイン項目ファイルリストに悪意のある実行ファイルのパスを追加します。(引用: Startup Items Eclectic) 攻撃者はまた、ログイン・アイテムを使用して、被害者システムをリモートで制御するために使用できる実行可能ファイルを起動したり、ユーザー認証情報の入力を促して特権を昇格させる手段として使用したりすることもできる。(引用: objsee mac malware 2017)(引用: CheckPoint Dok)(引用: objsee netwire backdoor 2019)"
                },
                {
                    "id": "T1547.013",
                    "name_eng": "XDG Autostart Entries",
                    "name_jp": "XDGオートスタートエントリー",
                    "description_eng": "Adversaries may add or modify XDG Autostart Entries to execute malicious programs or commands when a user’s desktop environment is loaded at login. XDG Autostart entries are available for any XDG-compliant Linux system. XDG Autostart entries use Desktop Entry files (`.desktop`) to configure the user’s desktop environment upon user login. These configuration files determine what applications launch upon user login, define associated applications to open specific file types, and define applications used to open removable media.(Citation: Free Desktop Application Autostart Feb 2006)(Citation: Free Desktop Entry Keys)\n\nAdversaries may abuse this feature to establish persistence by adding a path to a malicious binary or command to the `Exec` directive in the `.desktop` configuration file. When the user’s desktop environment is loaded at user login, the `.desktop` files located in the XDG Autostart directories are automatically executed. System-wide Autostart entries are located in the `/etc/xdg/autostart` directory while the user entries are located in the `~/.config/autostart` directory.\n\nAdversaries may combine this technique with [Masquerading](https://attack.mitre.org/techniques/T1036) to blend malicious Autostart entries with legitimate programs.(Citation: Red Canary Netwire Linux 2022)",
                    "description_jp": "侵入者は、XDG 自動起動エントリを追加または変更することで、ログイン時にユーザーのデスクトップ環境がロードされる際に、悪意のあるプログラムやコマンドを実行する可能性があります。XDG 自動起動エントリは、XDG 準拠の Linux システムで使用できます。XDG 自動起動エントリは、デスクトップ エントリ ファイル (`.desktop`) を使用して、ユーザーのログイン時にデスクトップ環境を設定します。これらの設定ファイルは、ユーザーログイン時に起動するアプリケーションを決定し、特定のファイルタイプを開くための関連アプリケーションを定義し、リムーバブルメディアを開くために使用するアプリケーションを定義します(引用: Free Desktop Application Autostart Feb 2006)(Citation: Free Desktop Entry Keys)\n\n攻撃者はこの機能を悪用し、`.desktop`設定ファイルの`Exec`ディレクティブに悪意のあるバイナリやコマンドへのパスを追加することで、永続性を確立する可能性がある。ユーザーのログイン時にデスクトップ環境がロードされると、XDG の自動起動ディレクトリにある `.desktop` ファイルが自動的に実行されます。システム全体の Autostart エントリは `/etc/xdg/autostart` ディレクトリにあり、ユーザーのエントリは `~/.config/autostart` ディレクトリにあります。\n\n攻撃者は、このテクニックを[Masquerading](https://attack.mitre.org/techniques/T1036)と組み合わせて、悪意のあるAutostartエントリーを正当なプログラムに紛れ込ませる可能性がある(引用: Red Canary Netwire Linux 2022)。"
                },
                {
                    "id": "T1547.003",
                    "name_eng": "Time Providers",
                    "name_jp": "時間プロバイダー",
                    "description_eng": "Adversaries may abuse time providers to execute DLLs when the system boots. The Windows Time service (W32Time) enables time synchronization across and within domains.(Citation: Microsoft W32Time Feb 2018) W32Time time providers are responsible for retrieving time stamps from hardware/network resources and outputting these values to other network clients.(Citation: Microsoft TimeProvider)\n\nTime providers are implemented as dynamic-link libraries (DLLs) that are registered in the subkeys of `HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\`.(Citation: Microsoft TimeProvider) The time provider manager, directed by the service control manager, loads and starts time providers listed and enabled under this key at system startup and/or whenever parameters are changed.(Citation: Microsoft TimeProvider)\n\nAdversaries may abuse this architecture to establish persistence, specifically by creating a new arbitrarily named subkey  pointing to a malicious DLL in the `DllName` value. Administrator privileges are required for time provider registration, though execution will run in context of the Local Service account.(Citation: Github W32Time Oct 2017)",
                    "description_jp": "攻撃者はタイムプロバイダーを悪用して、システム起動時にDLLを実行する可能性がある。Windows Timeサービス(W32Time)は、ドメイン間やドメイン内での時刻同期を可能にする。(引用: Microsoft W32Time Feb 2018) W32Time タイムプロバイダは、ハードウェア/ネットワークリソースからタイムスタンプを取得し、その値を他のネットワーククライアントに出力する役割を担っています。(引用: Microsoft TimeProvider)\n\nタイムプロバイダは、ダイナミックリンクライブラリ(DLL)として実装され、`HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\`のサブキーに登録される。(引用: Microsoft TimeProvider) タイムプロバイダマネージャは、サービスコントロールマネージャによって指示され、システム起動時やパラメータが変更されるたびに、このキーの下にリストされ有効になっているタイムプロバイダをロードして起動する。(引用: Microsoft TimeProvider)\n\n特に、`DllName` 値に悪意のあるDLLを指す、任意に命名された新しいサブキーを作成することである。タイムプロバイダの登録には管理者権限が必要であるが、実行はローカルサービスアカウントのコンテキストで実行される。(引用: Github W32Time Oct 2017)"
                },
                {
                    "id": "T1547.002",
                    "name_eng": "Authentication Package",
                    "name_jp": "認証パッケージ",
                    "description_eng": "Adversaries may abuse authentication packages to execute DLLs when the system boots. Windows authentication package DLLs are loaded by the Local Security Authority (LSA) process at system start. They provide support for multiple logon processes and multiple security protocols to the operating system.(Citation: MSDN Authentication Packages)\n\nAdversaries can use the autostart mechanism provided by LSA authentication packages for persistence by placing a reference to a binary in the Windows Registry location <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\</code> with the key value of <code>\"Authentication Packages\"=&lt;target binary&gt;</code>. The binary will then be executed by the system when the authentication packages are loaded.",
                    "description_jp": "攻撃者は認証パッケージを悪用し、システム起動時に DLL を実行する可能性がある。Windowsの認証パッケージDLLは、システム起動時にLSA（Local Security Authority）プロセスによってロードされる。これらのDLLは、複数のログオンプロセスと複数のセキュリティプロトコルをオペレーティングシステムに提供する。(引用：MSDN Authentication Packages)\n\n攻撃者は、<code>\"Authentication Packages\"=&lt;target binary&gt;</code>のキー値を持つバイナリへの参照をWindowsレジストリの場所<code>HKLMSYSTEMCurntionControlLsa</code>に置くことで、LSA認証パッケージによって提供される自動開始メカニズムを永続化のために使用することができる。認証パッケージがロードされると、このバイナリがシステムによって実行される。"
                },
                {
                    "id": "T1547.010",
                    "name_eng": "Port Monitors",
                    "name_jp": "ポートモニター",
                    "description_eng": "Adversaries may use port monitors to run an adversary supplied DLL during system boot for persistence or privilege escalation. A port monitor can be set through the <code>AddMonitor</code> API call to set a DLL to be loaded at startup.(Citation: AddMonitor) This DLL can be located in <code>C:\\Windows\\System32</code> and will be loaded and run by the print spooler service, `spoolsv.exe`, under SYSTEM level permissions on boot.(Citation: Bloxham) \n\nAlternatively, an arbitrary DLL can be loaded if permissions allow writing a fully-qualified pathname for that DLL to the `Driver` value of an existing or new arbitrarily named subkey of <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors</code>. The Registry key contains entries for the following:\n\n* Local Port\n* Standard TCP/IP Port\n* USB Monitor\n* WSD Port",
                    "description_jp": "敵はポートモニターを使用して、システムブート中に敵が提供するDLLを実行し、永続化や権限昇格を行う可能性がある。 ポート・モニターは、<code>AddMonitor</code> APIコールによって設定することができ、起動時にロードされるDLLを設定する。(引用: AddMonitor) このDLLは <code>C:\\Windows\\System32</code> にあり、起動時にSYSTEMレベルの権限でプリントスプーラサービスの `spoolsv.exe` によってロードされ実行されます。(引用: Bloxham) \n\nまた、<code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors</code>の既存または新規の任意の名前のサブキーの `Driver`値に、そのDLLの完全修飾パス名を書き込むことが許可されていれば、任意のDLLをロードすることができる。 レジストリ・キーには、以下のエントリが含まれている。:\n\n* Local Port\n* Standard TCP/IP Port\n* USB Monitor\n* WSD Port"
                }
            ]
        },
        {
            "id": "T1053",
            "name_eng": "Scheduled Task/Job",
            "name_jp": "スケジュールされたタスク/ジョブ",
            "description_eng": "Adversaries may abuse task scheduling functionality to facilitate initial or recurring execution of malicious code. Utilities exist within all major operating systems to schedule programs or scripts to be executed at a specified date and time. A task can also be scheduled on a remote system, provided the proper authentication is met (ex: RPC and file and printer sharing in Windows environments). Scheduling a task on a remote system typically may require being a member of an admin or otherwise privileged group on the remote system.(Citation: TechNet Task Scheduler Security)\n\nAdversaries may use task scheduling to execute programs at system startup or on a scheduled basis for persistence. These mechanisms can also be abused to run a process under the context of a specified account (such as one with elevated permissions/privileges). Similar to [System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218), adversaries have also abused task scheduling to potentially mask one-time execution under a trusted system process.(Citation: ProofPoint Serpent)",
            "description_jp": "攻撃者は、タスク・スケジューリング機能を悪用して、悪意のあるコードの初期実行や反復実行を容易にする可能性がある。 すべての主要なオペレーティング・システムには、指定した日時に実行されるプログラムやスクリプトをスケジュールするユーティリティが存在する。 適切な認証が行われれば、タスクはリモートシステム上でもスケジューリングできる。 (例: RPC and file and printer sharing in Windows environments). リモートシステム上のタスクをスケジューリングするには、通常、リモートシステム上の管理者またはその他の特権を持つグループのメンバーであることが必要な場合がある。(引用: TechNet Task Scheduler Security)\n\n攻撃者は、タスクスケジューリングを使って、システム起動時や、永続化のためにスケジュールされたベースでプログラムを実行するかもしれない。 これらのメカニズムは、指定されたアカウント（昇格したパーミッション/特権を持つアカウントなど）のコンテキスト下でプロセスを実行するために悪用することもできる。 [System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218)と同様に、敵対者はタスクスケジューリングを悪用して、信頼されたシステムプロセスの下で1回限りの実行を隠蔽する可能性もある。(引用: ProofPoint Serpent)",
            "subtechniques": [
                {
                    "id": "T1053.003",
                    "name_eng": "Cron",
                    "name_jp": "クロン",
                    "description_eng": "Adversaries may abuse the <code>cron</code> utility to perform task scheduling for initial or recurring execution of malicious code.(Citation: 20 macOS Common Tools and Techniques) The <code>cron</code> utility is a time-based job scheduler for Unix-like operating systems.  The <code> crontab</code> file contains the schedule of cron entries to be run and the specified times for execution. Any <code>crontab</code> files are stored in operating system-specific file paths.\n\nAn adversary may use <code>cron</code> in Linux or Unix environments to execute programs at system startup or on a scheduled basis for [Persistence](https://attack.mitre.org/tactics/TA0003). In ESXi environments, cron jobs must be created directly via the crontab file (e.g., `/var/spool/cron/crontabs/root`).(Citation: CloudSEK ESXiArgs 2023)",
                    "description_jp": "攻撃者は<code>cron</code>ユーティリティを悪用して、悪意のあるコードの初回実行または定期的な実行のためのタスクスケジューリングを行う可能性があります。(引用: 20 macOS Common Tools and Techniques) <code>cron</code>ユーティリティは、Unixライクなオペレーティングシステム向けの時刻ベースのジョブスケジューラです。<code>crontab</code>ファイルには、実行されるcronエントリのスケジュールと指定された実行時刻が含まれています。すべての<code>crontab</code>ファイルは、オペレーティングシステム固有のファイルパスに保存されます。\n\n攻撃者は、LinuxまたはUnix環境で<code>cron</code>を使用して、システムの起動時または[永続化](https://attack.mitre.org/tactics/TA0003)のためのスケジュールに基づいてプログラムを実行する可能性があります。ESXi環境では、cronジョブはcrontabファイル（例: `/var/spool/cron/crontabs/root`）を介して直接作成する必要があります。(引用: CloudSEK ESXiArgs 2023)"
                },
                {
                    "id": "T1053.005",
                    "name_eng": "Scheduled Task",
                    "name_jp": "予定タスク",
                    "description_eng": "Adversaries may abuse the Windows Task Scheduler to perform task scheduling for initial or recurring execution of malicious code. There are multiple ways to access the Task Scheduler in Windows. The [schtasks](https://attack.mitre.org/software/S0111) utility can be run directly on the command line, or the Task Scheduler can be opened through the GUI within the Administrator Tools section of the Control Panel.(Citation: Stack Overflow) In some cases, adversaries have used a .NET wrapper for the Windows Task Scheduler, and alternatively, adversaries have used the Windows netapi32 library and [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) (WMI) to create a scheduled task. Adversaries may also utilize the Powershell Cmdlet `Invoke-CimMethod`, which leverages WMI class `PS_ScheduledTask` to create a scheduled task via an XML path.(Citation: Red Canary - Atomic Red Team)\n\nAn adversary may use Windows Task Scheduler to execute programs at system startup or on a scheduled basis for persistence. The Windows Task Scheduler can also be abused to conduct remote Execution as part of Lateral Movement and/or to run a process under the context of a specified account (such as SYSTEM). Similar to [System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218), adversaries have also abused the Windows Task Scheduler to potentially mask one-time execution under signed/trusted system processes.(Citation: ProofPoint Serpent)\n\nAdversaries may also create \"hidden\" scheduled tasks (i.e. [Hide Artifacts](https://attack.mitre.org/techniques/T1564)) that may not be visible to defender tools and manual queries used to enumerate tasks. Specifically, an adversary may hide a task from `schtasks /query` and the Task Scheduler by deleting the associated Security Descriptor (SD) registry value (where deletion of this value must be completed using SYSTEM permissions).(Citation: SigmaHQ)(Citation: Tarrask scheduled task) Adversaries may also employ alternate methods to hide tasks, such as altering the metadata (e.g., `Index` value) within associated registry keys.(Citation: Defending Against Scheduled Task Attacks in Windows Environments)",
                    "description_jp": "攻撃者はWindowsタスクスケジューラを悪用し、悪意のあるコードの初回実行または定期的な実行のためのタスクスケジューリングを行う可能性があります。Windowsのタスクスケジューラにアクセスする方法は複数あります。[schtasks](https://attack.mitre.org/software/S0111)ユーティリティはコマンドラインから直接実行することも、コントロールパネルの管理ツールセクション内のGUIからタスクスケジューラを開くこともできます。(引用: Stack Overflow) 場合によっては、攻撃者はWindowsタスクスケジューラ用の.NETラッパーを使用したり、あるいはWindows netapi32ライブラリや[Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) (WMI)を使用してスケジュールタスクを作成したりします。攻撃者はまた、XMLパス経由でスケジュールタスクを作成するためにWMIクラス`PS_ScheduledTask`を活用するPowershell Cmdlet `Invoke-CimMethod`を利用することもあります。(引用: Red Canary - Atomic Red Team)\n\n攻撃者は、Windowsタスクスケジューラを使用して、システムの起動時または永続化のためにスケジュールに基づいてプログラムを実行する可能性があります。Windowsタスクスケジューラは、横方向の移動の一部としてリモート実行を行ったり、指定されたアカウント(SYSTEMなど)のコンテキストでプロセスを実行したりするために悪用される可能性もあります。[System Binary Proxy Execution](https://attack.mitre.org/techniques/T1218)と同様に、攻撃者はWindowsタスクスケジューラを悪用して、署名/信頼されたシステムプロセスの下で1回限りの実行を潜在的にマスクすることもあります。(引用: ProofPoint Serpent)\n\n攻撃者はまた、「隠し」スケジュールタスク（すなわち[アーティファクトの隠蔽](https://attack.mitre.org/techniques/T1564)）を作成することもあり、これは防御側のツールやタスクを列挙するために使用される手動クエリには表示されない可能性があります。具体的には、攻撃者は関連するセキュリティ記述子（SD）レジストリ値を削除することにより（この値の削除はSYSTEM権限を使用して完了する必要があります）、`schtasks /query`およびタスクスケジューラからタスクを隠すことができます。(引用: SigmaHQ)(引用: Tarrask scheduled task) 攻撃者はまた、関連するレジストリキー内のメタデータ（例: `Index`値）を変更するなど、タスクを隠すための代替方法を採用することもあります。(引用: Defending Against Scheduled Task Attacks in Windows Environments)"
                },
                {
                    "id": "T1053.006",
                    "name_eng": "Systemd Timers",
                    "name_jp": "Systemd タイマー",
                    "description_eng": "Adversaries may abuse systemd timers to perform task scheduling for initial or recurring execution of malicious code. Systemd timers are unit files with file extension <code>.timer</code> that control services. Timers can be set to run on a calendar event or after a time span relative to a starting point. They can be used as an alternative to [Cron](https://attack.mitre.org/techniques/T1053/003) in Linux environments.(Citation: archlinux Systemd Timers Aug 2020) Systemd timers may be activated remotely via the <code>systemctl</code> command line utility, which operates over [SSH](https://attack.mitre.org/techniques/T1021/004).(Citation: Systemd Remote Control)\n\nEach <code>.timer</code> file must have a corresponding <code>.service</code> file with the same name, e.g., <code>example.timer</code> and <code>example.service</code>. <code>.service</code> files are [Systemd Service](https://attack.mitre.org/techniques/T1543/002) unit files that are managed by the systemd system and service manager.(Citation: Linux man-pages: systemd January 2014) Privileged timers are written to <code>/etc/systemd/system/</code> and <code>/usr/lib/systemd/system</code> while user level are written to <code>~/.config/systemd/user/</code>.\n\nAn adversary may use systemd timers to execute malicious code at system startup or on a scheduled basis for persistence.(Citation: Arch Linux Package Systemd Compromise BleepingComputer 10JUL2018)(Citation: gist Arch package compromise 10JUL2018)(Citation: acroread package compromised Arch Linux Mail 8JUL2018) Timers installed using privileged paths may be used to maintain root level persistence. Adversaries may also install user level timers to achieve user level persistence.(Citation: Falcon Sandbox smp: 28553b3a9d)",
                    "description_jp": "攻撃者は systemd タイマーを悪用して、悪意のあるコードを初期または繰り返し実行するためのタスクスケジューリングを行う可能性があります。Systemd タイマーは <code>.timer</code> という拡張子を持つユニットファイルで、サービスを制御します。タイマーはカレンダーのイベントや、開始点からの相対的な時間経過後に実行されるように設定できます。Linux 環境では、[Cron](https://attack.mitre.org/techniques/T1053/003) の代替として使うことができます。(引用: archlinux Systemd Timers Aug 2020) Systemd タイマーは、[SSH](https://attack.mitre.org/techniques/T1021/004) 経由で動作する <code>systemctl</code> コマンドラインユーティリティを使ってリモートで起動することができます。(引用: Systemd Remote Control)\n\n各 <code>.timer</code> ファイルには、対応する同じ名前の <code>.service</code> ファイルが必要です。例えば、<code>example.timer</code> と <code>example.service</code> のようになります。<code>.service</code>ファイルは[Systemd Service](https://attack.mitre.org/techniques/T1543/002)ユニットファイルで、systemdシステムとサービスマネージャーによって管理されます。(引用: Linux man-pages: systemd January 2014) 特権タイマーは<code>/etc/systemd/system/</code>と<code>/usr/lib/systemd/system</code>に、ユーザーレベルは<code>~/.config/systemd/user/</code>に書き込まれます。\n\n敵対者は systemd タイマーを使ってシステム起動時やスケジュールベースで悪意のあるコードを実行し、永続化する可能性があります。(引用: Arch Linux Package Systemd Compromise BleepingComputer 10JUL2018)(Citation: gist Arch package compromise 10JUL2018)(Citation: acroread package compromised Arch Linux Mail 8JUL2018) 特権パスを使ってインストールされたタイマーはルートレベルの永続化を維持するために使われるかもしれません。攻撃者はまた、ユーザーレベルの持続性を達成するためにユーザーレベルのタイマーをインストールする可能性があります。(引用: Falcon Sandbox smp: 28553b3a9d)"
                },
                {
                    "id": "T1053.007",
                    "name_eng": "Container Orchestration Job",
                    "name_jp": "コンテナ・オーケストレーションジョブ",
                    "description_eng": "Adversaries may abuse task scheduling functionality provided by container orchestration tools such as Kubernetes to schedule deployment of containers configured to execute malicious code. Container orchestration jobs run these automated tasks at a specific date and time, similar to cron jobs on a Linux system. Deployments of this type can also be configured to maintain a quantity of containers over time, automating the process of maintaining persistence within a cluster.\n\nIn Kubernetes, a CronJob may be used to schedule a Job that runs one or more containers to perform specific tasks.(Citation: Kubernetes Jobs)(Citation: Kubernetes CronJob) An adversary therefore may utilize a CronJob to schedule deployment of a Job that executes malicious code in various nodes within a cluster.(Citation: Threat Matrix for Kubernetes)",
                    "description_jp": "攻撃者は、Kubernetesなどのコンテナオーケストレーションツールが提供するタスクスケジューリング機能を悪用して、悪意のあるコードを実行するように設定されたコンテナのデプロイをスケジュールする可能性があります。コンテナオーケストレーションジョブは、Linuxシステムのcronジョブと同様に、特定の日時にこれらの自動タスクを実行します。この種のデプロイは、長期にわたってコンテナの量を維持するように構成することもでき、クラスタ内の永続性を維持するプロセスを自動化することができます。\n\nKubernetesでは、CronJobは、特定のタスクを実行するために1つまたは複数のコンテナを実行するJobをスケジュールするために使用されることがあります。(引用: Kubernetes Jobs)(引用: Kubernetes CronJob) したがって、敵対者は、クラスタ内のさまざまなノードで悪意のあるコードを実行するJobのデプロイをスケジュールするためにCronJobを利用する可能性があります。(引用: Threat Matrix for Kubernetes)"
                },
                {
                    "id": "T1053.002",
                    "name_eng": "At",
                    "name_jp": "At",
                    "description_eng": "Adversaries may abuse the [at](https://attack.mitre.org/software/S0110) utility to perform task scheduling for initial or recurring execution of malicious code. The [at](https://attack.mitre.org/software/S0110) utility exists as an executable within Windows, Linux, and macOS for scheduling tasks at a specified time and date. Although deprecated in favor of [Scheduled Task](https://attack.mitre.org/techniques/T1053/005)'s [schtasks](https://attack.mitre.org/software/S0111) in Windows environments, using [at](https://attack.mitre.org/software/S0110) requires that the Task Scheduler service be running, and the user to be logged on as a member of the local Administrators group. In addition to explicitly running the `at` command, adversaries may also schedule a task with [at](https://attack.mitre.org/software/S0110) by directly leveraging the [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) `Win32_ScheduledJob` WMI class.(Citation: Malicious Life by Cybereason)\n\nOn Linux and macOS, [at](https://attack.mitre.org/software/S0110) may be invoked by the superuser as well as any users added to the <code>at.allow</code> file. If the <code>at.allow</code> file does not exist, the <code>at.deny</code> file is checked. Every username not listed in <code>at.deny</code> is allowed to invoke [at](https://attack.mitre.org/software/S0110). If the <code>at.deny</code> exists and is empty, global use of [at](https://attack.mitre.org/software/S0110) is permitted. If neither file exists (which is often the baseline) only the superuser is allowed to use [at](https://attack.mitre.org/software/S0110).(Citation: Linux at)\n\nAdversaries may use [at](https://attack.mitre.org/software/S0110) to execute programs at system startup or on a scheduled basis for [Persistence](https://attack.mitre.org/tactics/TA0003). [at](https://attack.mitre.org/software/S0110) can also be abused to conduct remote [Execution](https://attack.mitre.org/tactics/TA0002) as part of [Lateral Movement](https://attack.mitre.org/tactics/TA0008) and/or to run a process under the context of a specified account (such as SYSTEM).\n\nIn Linux environments, adversaries may also abuse [at](https://attack.mitre.org/software/S0110) to break out of restricted environments by using a task to spawn an interactive system shell or to run system commands. Similarly, [at](https://attack.mitre.org/software/S0110) may also be used for [Privilege Escalation](https://attack.mitre.org/tactics/TA0004) if the binary is allowed to run as superuser via <code>sudo</code>.(Citation: GTFObins at)",
                    "description_jp": "攻撃者は[at](https://attack.mitre.org/software/S0110)ユーティリティを悪用して、悪意のあるコードの初回実行または定期的な実行のためのタスクスケジューリングを行う可能性があります。[at](https://attack.mitre.org/software/S0110)ユーティリティは、指定された日時にタスクをスケジューリングするためにWindows、Linux、およびmacOS内に実行可能ファイルとして存在します。Windows環境では[Scheduled Task](https://attack.mitre.org/techniques/T1053/005)の[schtasks](https://attack.mitre.org/software/S0111)が推奨され非推奨となっていますが、[at](https://attack.mitre.org/software/S0110)を使用するには、タスクスケジューラサービスが実行されており、ユーザーがローカルのAdministratorsグループのメンバーとしてログオンしている必要があります。`at`コマンドを明示的に実行するのに加えて、攻撃者は[Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047)の`Win32_ScheduledJob` WMIクラスを直接利用して[at](https://attack.mitre.org/software/S0110)でタスクをスケジュールすることもできます。(引用: Malicious Life by Cybereason)\n\nLinuxおよびmacOSでは、[at](https://attack.mitre.org/software/S0110)はスーパーユーザー、および`at.allow`ファイルに追加された任意のユーザーによって呼び出される可能性があります。`at.allow`ファイルが存在しない場合は、`at.deny`ファイルがチェックされます。`at.deny`にリストされていないすべてのユーザー名は[at](https://attack.mitre.org/software/S0110)を呼び出すことが許可されます。`at.deny`が存在し空である場合は、[at](https://attack.mitre.org/software/S0110)のグローバルな使用が許可されます。どちらのファイルも存在しない場合（これがベースラインであることが多い）、スーパーユーザーのみが[at](https://attack.mitre.org/software/S0110)を使用できます。(引用: Linux at)\n\n攻撃者は[at](https://attack.mitre.org/software/S0110)を使用して、システムの起動時または[永続化](https://attack.mitre.org/tactics/TA0003)のためのスケジュールに基づいてプログラムを実行する可能性があります。[at](https://attack.mitre.org/software/S0110)はまた、[横方向の移動](https://attack.mitre.org/tactics/TA0008)の一部としてリモート[実行](https://attack.mitre.org/tactics/TA0002)を行ったり、指定されたアカウント（SYSTEMなど）のコンテキストでプロセスを実行したりするために悪用される可能性もあります。\n\nLinux環境では、攻撃者はまた、タスクを使用して対話型システムシェルを生成したりシステムコマンドを実行したりすることで、制限された環境から抜け出すために[at](https://attack.mitre.org/software/S0110)を悪用する可能性があります。同様に、バイナリが`sudo`経由でスーパーユーザーとして実行されることが許可されている場合、[at](https://attack.mitre.org/software/S0110)は[権限昇格](https://attack.mitre.org/tactics/TA0004)にも使用される可能性があります。(引用: GTFObins at)"
                }
            ]
        },
        {
            "id": "T1055",
            "name_eng": "Process Injection",
            "name_jp": "プロセス・インジェクション",
            "description_eng": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. \n\nThere are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. \n\nMore sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.",
            "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、プロセスにコードを注入する可能性があります。プロセスインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースにアクセスでき、場合によっては権限が昇格される可能性があります。プロセスインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。\n\nプロセスにコードを注入する方法は多数あり、その多くは正当な機能を悪用しています。これらの実装は主要なOSすべてに存在しますが、通常はプラットフォーム固有です。\n\nより高度なサンプルでは、モジュールをセグメント化し、検出をさらに回避するために複数のプロセスインジェクションを実行し、通信チャネルとして名前付きパイプやその他のプロセス間通信（IPC）メカニズムを利用する場合があります。",
            "subtechniques": [
                {
                    "id": "T1055.013",
                    "name_eng": "Process Doppelgänging",
                    "name_jp": "プロセス ダブルスレッド",
                    "description_eng": "Adversaries may inject malicious code into process via process doppelgänging in order to evade process-based defenses as well as possibly elevate privileges. Process doppelgänging is a method of executing arbitrary code in the address space of a separate live process. \n\nWindows Transactional NTFS (TxF) was introduced in Vista as a method to perform safe file operations. (Citation: Microsoft TxF) To ensure data integrity, TxF enables only one transacted handle to write to a file at a given time. Until the write handle transaction is terminated, all other handles are isolated from the writer and may only read the committed version of the file that existed at the time the handle was opened. (Citation: Microsoft Basic TxF Concepts) To avoid corruption, TxF performs an automatic rollback if the system or application fails during a write transaction. (Citation: Microsoft Where to use TxF)\n\nAlthough deprecated, the TxF application programming interface (API) is still enabled as of Windows 10. (Citation: BlackHat Process Doppelgänging Dec 2017)\n\nAdversaries may abuse TxF to a perform a file-less variation of [Process Injection](https://attack.mitre.org/techniques/T1055). Similar to [Process Hollowing](https://attack.mitre.org/techniques/T1055/012), process doppelgänging involves replacing the memory of a legitimate process, enabling the veiled execution of malicious code that may evade defenses and detection. Process doppelgänging's use of TxF also avoids the use of highly-monitored API functions such as <code>NtUnmapViewOfSection</code>, <code>VirtualProtectEx</code>, and <code>SetThreadContext</code>. (Citation: BlackHat Process Doppelgänging Dec 2017)\n\nProcess Doppelgänging is implemented in 4 steps (Citation: BlackHat Process Doppelgänging Dec 2017):\n\n* Transact – Create a TxF transaction using a legitimate executable then overwrite the file with malicious code. These changes will be isolated and only visible within the context of the transaction.\n* Load – Create a shared section of memory and load the malicious executable.\n* Rollback – Undo changes to original executable, effectively removing malicious code from the file system.\n* Animate – Create a process from the tainted section of memory and initiate execution.\n\nThis behavior will likely not result in elevated privileges since the injected process was spawned from (and thus inherits the security context) of the injecting process. However, execution via process doppelgänging may evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、プロセスドッペルゲンギングを介してプロセスに悪意のあるコードを注入する可能性があります。プロセスドッペルゲンギングは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nWindows Transactional NTFS (TxF) は、安全なファイル操作を実行する手法としてVistaで導入されました。(引用: Microsoft TxF) データ整合性を確保するため、TxFは特定の時点でファイルに書き込むことができるトランザクションハンドルを1つだけにします。書き込みハンドルトランザクションが終了するまで、他のすべてのハンドルは書き込み元から分離され、ハンドルが開かれた時点で存在したファイルのコミット済みバージョンのみを読み取ることができます。(引用: Microsoft Basic TxF Concepts) 破損を避けるため、書き込みトランザクション中にシステムまたはアプリケーションに障害が発生した場合、TxFは自動ロールバックを実行します。(引用: Microsoft Where to use TxF)\n\n非推奨ですが、TxFアプリケーションプログラミングインターフェイス（API）はWindows 10の時点でも有効です。(引用: BlackHat Process Doppelgänging Dec 2017)\n\n攻撃者はTxFを悪用して、[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)のファイルレスバリエーションを実行する可能性があります。[プロセスハロウイング](https://attack.mitre.org/techniques/T1055/012)と同様に、プロセスドッペルゲンギングは正当なプロセスのメモリを置き換え、防御や検出を回避する可能性のある悪意のあるコードの隠蔽された実行を可能にします。プロセスドッペルゲンギングによるTxFの使用は、`NtUnmapViewOfSection`、`VirtualProtectEx`、`SetThreadContext`などの監視の厳しいAPI関数の使用も回避します。(引用: BlackHat Process Doppelgänging Dec 2017)\n\nプロセスドッペルゲンギングは4つのステップで実装されます(引用: BlackHat Process Doppelgänging Dec 2017):\n\n* トランザクト – 正当な実行可能ファイルを使用してTxFトランザクションを作成し、その後、ファイルを悪意のあるコードで上書きします。これらの変更は分離され、トランザクションのコンテキスト内でのみ表示されます。\n* ロード – メモリの共有セクションを作成し、悪意のある実行可能ファイルをロードします。\n* ロールバック – 元の実行可能ファイルへの変更を元に戻し、ファイルシステムから悪意のあるコードを効果的に削除します。\n* アニメート – 汚染されたメモリセクションからプロセスを作成し、実行を開始します。\n\n注入されたプロセスは注入元のプロセスから生成された（したがってセキュリティコンテキストを継承する）ため、この動作によって権限が昇格される可能性は低いでしょう。ただし、プロセスドッペルゲンギングによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性があります。"
                },
                {
                    "id": "T1055.012",
                    "name_eng": "Process Hollowing",
                    "name_jp": "プロセス空洞化",
                    "description_eng": "Adversaries may inject malicious code into suspended and hollowed processes in order to evade process-based defenses. Process hollowing is a method of executing arbitrary code in the address space of a separate live process.  \n\nProcess hollowing is commonly performed by creating a process in a suspended state then unmapping/hollowing its memory, which can then be replaced with malicious code. A victim process can be created with native Windows API calls such as <code>CreateProcess</code>, which includes a flag to suspend the processes primary thread. At this point the process can be unmapped using APIs calls such as <code>ZwUnmapViewOfSection</code> or <code>NtUnmapViewOfSection</code>  before being written to, realigned to the injected code, and resumed via <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, then <code>ResumeThread</code> respectively.(Citation: Leitch Hollowing)(Citation: Elastic Process Injection July 2017)\n\nThis is very similar to [Thread Local Storage](https://attack.mitre.org/techniques/T1055/005) but creates a new process rather than targeting an existing process. This behavior will likely not result in elevated privileges since the injected process was spawned from (and thus inherits the security context) of the injecting process. However, execution via process hollowing may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避するために、中断され空洞化されたプロセスに悪意のあるコードを注入する可能性があります。プロセスハロウイングは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nプロセスハロウイングは通常、プロセスを中断状態で作成し、そのメモリをアンマップ/空洞化し、その後悪意のあるコードに置き換えることによって実行されます。被害者プロセスは、プロセスのプライマリスレッドを中断するフラグを含む`CreateProcess`などのネイティブWindows API呼び出しで作成できます。この時点で、プロセスは`ZwUnmapViewOfSection`や`NtUnmapViewOfSection`などのAPI呼び出しを使用してアンマップされた後、書き込まれ、注入されたコードに再配置され、それぞれ`VirtualAllocEx`、`WriteProcessMemory`、`SetThreadContext`、そして`ResumeThread`を介して再開されます。(引用: Leitch Hollowing)(引用: Elastic Process Injection July 2017)\n\nこれは[スレッドローカルストレージ](https://attack.mitre.org/techniques/T1055/005)と非常によく似ていますが、既存のプロセスをターゲットにするのではなく、新しいプロセスを作成します。注入されたプロセスは注入元のプロセスから生成された（したがってセキュリティコンテキストを継承する）ため、この動作によって権限が昇格される可能性は低いでしょう。ただし、プロセスハロウイングによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.009",
                    "name_eng": "Proc Memory",
                    "name_jp": "プロックメモリ",
                    "description_eng": "Adversaries may inject malicious code into processes via the /proc filesystem in order to evade process-based defenses as well as possibly elevate privileges. Proc memory injection is a method of executing arbitrary code in the address space of a separate live process. \n\nProc memory injection involves enumerating the memory of a process via the /proc filesystem (<code>/proc/[pid]</code>) then crafting a return-oriented programming (ROP) payload with available gadgets/instructions. Each running process has its own directory, which includes memory mappings. Proc memory injection is commonly performed by overwriting the target processes’ stack using memory mappings provided by the /proc filesystem. This information can be used to enumerate offsets (including the stack) and gadgets (or instructions within the program that can be used to build a malicious payload) otherwise hidden by process memory protections such as address space layout randomization (ASLR). Once enumerated, the target processes’ memory map within <code>/proc/[pid]/maps</code> can be overwritten using dd.(Citation: Uninformed Needle)(Citation: GDS Linux Injection)(Citation: DD Man) \n\nOther techniques such as [Dynamic Linker Hijacking](https://attack.mitre.org/techniques/T1574/006) may be used to populate a target process with more available gadgets. Similar to [Process Hollowing](https://attack.mitre.org/techniques/T1055/012), proc memory injection may target child processes (such as a backgrounded copy of sleep).(Citation: GDS Linux Injection) \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via proc memory injection may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、/procファイルシステムを介してプロセスに悪意のあるコードを注入する可能性があります。Procメモリインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nProcメモリインジェクションは、/procファイルシステム（`<code>/proc/[pid]</code>`）を介してプロセスのメモリを列挙し、利用可能なガジェット/命令でリターン指向プログラミング（ROP）ペイロードを作成することを含みます。実行中の各プロセスには、メモリマッピングを含む独自のディレクトリがあります。Procメモリインジェクションは、通常、/procファイルシステムによって提供されるメモリマッピングを使用してターゲットプロセスのスタックを上書きすることによって実行されます。この情報は、アドレス空間配置のランダム化（ASLR）などのプロセスメモリ保護によって隠されているオフセット（スタックを含む）やガジェット（悪意のあるペイロードを構築するために使用できるプログラム内の命令）を列挙するために使用できます。列挙されると、`<code>/proc/[pid]/maps</code>`内のターゲットプロセスのメモリマップはddを使用して上書きできます。(引用: Uninformed Needle)(引用: GDS Linux Injection)(引用: DD Man)\n\n[ダイナミックリンカーハイジャック](https://attack.mitre.org/techniques/T1574/006)などの他のテクニックを使用して、ターゲットプロセスにより多くの利用可能なガジェットを投入することができます。[プロセスハロウイング](https://attack.mitre.org/techniques/T1055/012)と同様に、procメモリインジェクションは子プロセス（バックグラウンドで実行されているsleepのコピーなど）をターゲットにする場合があります。(引用: GDS Linux Injection)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。procメモリインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.015",
                    "name_eng": "ListPlanting",
                    "name_jp": "リストプランティング",
                    "description_eng": "Adversaries may abuse list-view controls to inject malicious code into hijacked processes in order to evade process-based defenses as well as possibly elevate privileges. ListPlanting is a method of executing arbitrary code in the address space of a separate live process.(Citation: Hexacorn Listplanting) Code executed via ListPlanting may also evade detection from security products since the execution is masked under a legitimate process.\n\nList-view controls are user interface windows used to display collections of items.(Citation: Microsoft List View Controls) Information about an application's list-view settings are stored within the process' memory in a <code>SysListView32</code> control.\n\nListPlanting (a form of message-passing \"shatter attack\") may be performed by copying code into the virtual address space of a process that uses a list-view control then using that code as a custom callback for sorting the listed items.(Citation: Modexp Windows Process Injection) Adversaries must first copy code into the target process’ memory space, which can be performed various ways including by directly obtaining a handle to the <code>SysListView32</code> child of the victim process window (via Windows API calls such as <code>FindWindow</code> and/or <code>EnumWindows</code>) or other [Process Injection](https://attack.mitre.org/techniques/T1055) methods.\n\nSome variations of ListPlanting may allocate memory in the target process but then use window messages to copy the payload, to avoid the use of the highly monitored <code>WriteProcessMemory</code> function. For example, an adversary can use the <code>PostMessage</code> and/or <code>SendMessage</code> API functions to send <code>LVM_SETITEMPOSITION</code> and <code>LVM_GETITEMPOSITION</code> messages, effectively copying a payload 2 bytes at a time to the allocated memory.(Citation: ESET InvisiMole June 2020) \n\nFinally, the payload is triggered by sending the <code>LVM_SORTITEMS</code> message to the <code>SysListView32</code> child of the process window, with the payload within the newly allocated buffer passed and executed as the <code>ListView_SortItems</code> callback.",
                    "description_jp": "攻撃者は、リストビューコントロールを悪用して、乗っ取ったプロセスに悪意のあるコードを注入し、プロセスベースの防御を回避したり、権限を昇格させたりする可能性があります。ListPlantingは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。(引用: Hexacorn Listplanting) ListPlanting経由で実行されるコードは、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。\n\nリストビューコントロールは、アイテムのコレクションを表示するために使用されるユーザーインターフェイスウィンドウです。(引用: Microsoft List View Controls) アプリケーションのリストビュー設定に関する情報は、プロセスのメモリ内の<code>SysListView32</code>コントロールに保存されます。\n\nListPlanting（メッセージパッシング「シャッター攻撃」の一形態）は、リストビューコントロールを使用するプロセスの仮想アドレス空間にコードをコピーし、そのコードをリストされたアイテムのソート用のカスタムコールバックとして使用することによって実行される場合があります。(引用: Modexp Windows Process Injection) 攻撃者はまず、ターゲットプロセスのメモリス空間にコードをコピーする必要があります。これは、被害者プロセスウィンドウの<code>SysListView32</code>の子へのハンドルを直接取得する（<code>FindWindow</code>や<code>EnumWindows</code>などのWindows API呼び出しを介して）か、他の[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)メソッドを含むさまざまな方法で実行できます。\n\nListPlantingのいくつかのバリエーションでは、ターゲットプロセスにメモリを割り当てた後、ウィンドウメッセージを使用してペイロードをコピーし、監視の厳しい<code>WriteProcessMemory</code>関数の使用を回避する場合があります。例えば、攻撃者は<code>PostMessage</code>や<code>SendMessage</code> API関数を使用して<code>LVM_SETITEMPOSITION</code>および<code>LVM_GETITEMPOSITION</code>メッセージを送信し、ペイロードを一度に2バイトずつ割り当てられたメモリに効果的にコピーすることができます。(引用: ESET InvisiMole June 2020)\n\n最後に、ペイロードは、プロセスウィンドウの<code>SysListView32</code>の子に<code>LVM_SORTITEMS</code>メッセージを送信することによってトリガーされ、新しく割り当てられたバッファ内のペイロードが<code>ListView_SortItems</code>コールバックとして渡されて実行されます。"
                },
                {
                    "id": "T1055.014",
                    "name_eng": "VDSO Hijacking",
                    "name_jp": "VDSOハイジャック",
                    "description_eng": "Adversaries may inject malicious code into processes via VDSO hijacking in order to evade process-based defenses as well as possibly elevate privileges. Virtual dynamic shared object (vdso) hijacking is a method of executing arbitrary code in the address space of a separate live process. \n\nVDSO hijacking involves redirecting calls to dynamically linked shared libraries. Memory protections may prevent writing executable code to a process via [Ptrace System Calls](https://attack.mitre.org/techniques/T1055/008). However, an adversary may hijack the syscall interface code stubs mapped into a process from the vdso shared object to execute syscalls to open and map a malicious shared object. This code can then be invoked by redirecting the execution flow of the process via patched memory address references stored in a process' global offset table (which store absolute addresses of mapped library functions).(Citation: ELF Injection May 2009)(Citation: Backtrace VDSO)(Citation: VDSO Aug 2005)(Citation: Syscall 2014)\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via VDSO hijacking may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、VDSOハイジャックを介してプロセスに悪意のあるコードを注入する可能性があります。仮想動的共有オブジェクト（vdso）ハイジャックは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nVDSOハイジャックは、動的にリンクされた共有ライブラリへの呼び出しをリダイレクトすることを含みます。メモリ保護により、[Ptraceシステムコール](https://attack.mitre.org/techniques/T1055/008)を介してプロセスに実行可能コードを書き込むことが妨げられる場合があります。ただし、攻撃者はvdso共有オブジェクトからプロセスにマップされたsyscallインターフェイスコードスタブをハイジャックして、悪意のある共有オブジェクトを開いてマップするためのsyscallを実行する可能性があります。このコードは、プロセスのグローバルオフセットテーブル（マップされたライブラリ関数の絶対アドレスを格納）に格納されているパッチ適用済みのメモリアドレス参照を介してプロセスの実行フローをリダイレクトすることによって呼び出すことができます。(引用: ELF Injection May 2009)(引用: Backtrace VDSO)(引用: VDSO Aug 2005)(引用: Syscall 2014)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。VDSOハイジャックによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.005",
                    "name_eng": "Thread Local Storage",
                    "name_jp": "スレッドローカルストレージ",
                    "description_eng": "Adversaries may inject malicious code into processes via thread local storage (TLS) callbacks in order to evade process-based defenses as well as possibly elevate privileges. TLS callback injection is a method of executing arbitrary code in the address space of a separate live process. \n\nTLS callback injection involves manipulating pointers inside a portable executable (PE) to redirect a process to malicious code before reaching the code's legitimate entry point. TLS callbacks are normally used by the OS to setup and/or cleanup data used by threads. Manipulating TLS callbacks may be performed by allocating and writing to specific offsets within a process’ memory space using other [Process Injection](https://attack.mitre.org/techniques/T1055) techniques such as [Process Hollowing](https://attack.mitre.org/techniques/T1055/012).(Citation: FireEye TLS Nov 2017)\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via TLS callback injection may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、スレッドローカルストレージ（TLS）コールバックを介してプロセスに悪意のあるコードを注入する可能性があります。TLSコールバックインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nTLSコールバックインジェクションは、ポータブル実行可能ファイル（PE）内のポインタを操作して、コードの正当なエントリポイントに到達する前にプロセスを悪意のあるコードにリダイレクトすることを含みます。TLSコールバックは通常、スレッドが使用するデータのセットアップやクリーンアップのためにOSによって使用されます。TLSコールバックの操作は、[プロセスハロウイング](https://attack.mitre.org/techniques/T1055/012)などの他の[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)テクニックを使用して、プロセスのメモリス空間内の特定のオフセットに割り当てて書き込むことによって実行される場合があります。(引用: FireEye TLS Nov 2017)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。TLSコールバックインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.011",
                    "name_eng": "Extra Window Memory Injection",
                    "name_jp": "ウィンドウ・メモリ・インジェクション",
                    "description_eng": "Adversaries may inject malicious code into process via Extra Window Memory (EWM) in order to evade process-based defenses as well as possibly elevate privileges. EWM injection is a method of executing arbitrary code in the address space of a separate live process. \n\nBefore creating a window, graphical Windows-based processes must prescribe to or register a windows class, which stipulate appearance and behavior (via windows procedures, which are functions that handle input/output of data).(Citation: Microsoft Window Classes) Registration of new windows classes can include a request for up to 40 bytes of EWM to be appended to the allocated memory of each instance of that class. This EWM is intended to store data specific to that window and has specific application programming interface (API) functions to set and get its value. (Citation: Microsoft GetWindowLong function) (Citation: Microsoft SetWindowLong function)\n\nAlthough small, the EWM is large enough to store a 32-bit pointer and is often used to point to a windows procedure. Malware may possibly utilize this memory location in part of an attack chain that includes writing code to shared sections of the process’s memory, placing a pointer to the code in EWM, then invoking execution by returning execution control to the address in the process’s EWM.\n\nExecution granted through EWM injection may allow access to both the target process's memory and possibly elevated privileges. Writing payloads to shared sections also avoids the use of highly monitored API calls such as <code>WriteProcessMemory</code> and <code>CreateRemoteThread</code>.(Citation: Elastic Process Injection July 2017) More sophisticated malware samples may also potentially bypass protection mechanisms such as data execution prevention (DEP) by triggering a combination of windows procedures and other system functions that will rewrite the malicious payload inside an executable portion of the target process.  (Citation: MalwareTech Power Loader Aug 2013) (Citation: WeLiveSecurity Gapz and Redyms Mar 2013)\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via EWM injection may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、追加ウィンドウメモリ（EWM）を介してプロセスに悪意のあるコードを注入する可能性があります。EWMインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nウィンドウを作成する前に、グラフィカルなWindowsベースのプロセスは、外観と動作を規定するウィンドウクラスを規定または登録する必要があります（データの入出力を処理する関数であるウィンドウプロシージャを介して）。(引用: Microsoft Window Classes) 新しいウィンドウクラスの登録には、そのクラスの各インスタンスの割り当て済みメモリに追加される最大40バイトのEWMのリクエストを含めることができます。このEWMは、そのウィンドウに固有のデータを格納することを目的としており、その値を設定および取得するための特定のアプリケーションプログラミングインターフェイス（API）関数を持っています。(引用: Microsoft GetWindowLong function)(引用: Microsoft SetWindowLong function)\n\n小さいながらも、EWMは32ビットポインタを格納するのに十分な大きさであり、ウィンドウプロシージャを指すためによく使用されます。マルウェアは、プロセスのメモリの共有セクションにコードを書き込み、EWMにコードへのポインタを配置し、プロセスのEWM内のアドレスに実行制御を返すことによって実行を呼び出すことを含む攻撃チェーンの一部として、このメモリロケーションを利用する可能性があります。\n\nEWMインジェクションを介して付与された実行は、ターゲットプロセスのメモリと、場合によっては昇格された権限の両方へのアクセスを許可する可能性があります。共有セクションへのペイロードの書き込みは、<code>WriteProcessMemory</code>や<code>CreateRemoteThread</code>などの監視の厳しいAPI呼び出しの使用も回避します。(引用: Elastic Process Injection July 2017) より高度なマルウェアサンプルは、ターゲットプロセスの実行可能部分内に悪意のあるペイロードを書き換えるウィンドウプロシージャと他のシステム関数の組み合わせをトリガーすることによって、データ実行防止（DEP）などの保護メカニズムをバイパスする可能性もあります。(引用: MalwareTech Power Loader Aug 2013)(引用: WeLiveSecurity Gapz and Redyms Mar 2013)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。EWMインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.001",
                    "name_eng": "Dynamic-link Library Injection",
                    "name_jp": "ダイナミックリンク・ライブラリー・インジェクション",
                    "description_eng": "Adversaries may inject dynamic-link libraries (DLLs) into processes in order to evade process-based defenses as well as possibly elevate privileges. DLL injection is a method of executing arbitrary code in the address space of a separate live process.  \n\nDLL injection is commonly performed by writing the path to a DLL in the virtual address space of the target process before loading the DLL by invoking a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> (which calls the <code>LoadLibrary</code> API responsible for loading the DLL). (Citation: Elastic Process Injection July 2017) \n\nVariations of this method such as reflective DLL injection (writing a self-mapping DLL into a process) and memory module (map DLL when writing into process) overcome the address relocation issue as well as the additional APIs to invoke execution (since these methods load and execute the files in memory by manually preforming the function of <code>LoadLibrary</code>).(Citation: Elastic HuntingNMemory June 2017)(Citation: Elastic Process Injection July 2017) \n\nAnother variation of this method, often referred to as Module Stomping/Overloading or DLL Hollowing, may be leveraged to conceal injected code within a process. This method involves loading a legitimate DLL into a remote process then manually overwriting the module's <code>AddressOfEntryPoint</code> before starting a new thread in the target process.(Citation: Module Stomping for Shellcode Injection) This variation allows attackers to hide malicious injected code by potentially backing its execution with a legitimate DLL file on disk.(Citation: Hiding Malicious Code with Module Stomping) \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via DLL injection may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、ダイナミックリンクライブラリ（DLL）をプロセスに注入する可能性があります。DLLインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nDLLインジェクションは一般的に、新しいスレッドを呼び出してDLLをロードする前に、ターゲットプロセスの仮想アドレス空間にDLLへのパスを書き込むことによって実行されます。書き込みは、<code>VirtualAllocEx</code>や<code>WriteProcessMemory</code>などのネイティブWindows API呼び出しで実行でき、その後<code>CreateRemoteThread</code>（DLLのロードを担当する<code>LoadLibrary</code> APIを呼び出す）で呼び出されます。(引用: Elastic Process Injection July 2017)\n\nリフレクティブDLLインジェクション（自己マッピングDLLをプロセスに書き込む）やメモリモジュール（プロセスへの書き込み時にDLLをマップする）などのこのメソッドのバリエーションは、アドレス再配置の問題や実行を呼び出すための追加のAPIを克服します（これらのメソッドは<code>LoadLibrary</code>の機能を手動で実行することによってメモリ内のファイルをロードして実行するため）。(引用: Elastic HuntingNMemory June 2017)(引用: Elastic Process Injection July 2017)\n\nモジュールストンピング/オーバーロードまたはDLLハロウイングとしばしば呼ばれるこのメソッドの別のバリエーションは、プロセス内に注入されたコードを隠蔽するために活用される可能性があります。このメソッドは、正当なDLLをリモートプロセスにロードし、ターゲットプロセスで新しいスレッドを開始する前にモジュールの<code>AddressOfEntryPoint</code>を手動で上書きすることを含みます。(引用: Module Stomping for Shellcode Injection) このバリエーションにより、攻撃者はディスク上の正当なDLLファイルで実行を潜在的にバックアップすることにより、悪意のある注入コードを隠すことができます。(引用: Hiding Malicious Code with Module Stomping)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。DLLインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.003",
                    "name_eng": "Thread Execution Hijacking",
                    "name_jp": "スレッド実行ハイジャック",
                    "description_eng": "Adversaries may inject malicious code into hijacked processes in order to evade process-based defenses as well as possibly elevate privileges. Thread Execution Hijacking is a method of executing arbitrary code in the address space of a separate live process. \n\nThread Execution Hijacking is commonly performed by suspending an existing process then unmapping/hollowing its memory, which can then be replaced with malicious code or the path to a DLL. A handle to an existing victim process is first created with native Windows API calls such as <code>OpenThread</code>. At this point the process can be suspended then written to, realigned to the injected code, and resumed via <code>SuspendThread </code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, then <code>ResumeThread</code> respectively.(Citation: Elastic Process Injection July 2017)\n\nThis is very similar to [Process Hollowing](https://attack.mitre.org/techniques/T1055/012) but targets an existing process rather than creating a process in a suspended state.  \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via Thread Execution Hijacking may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、乗っ取ったプロセスに悪意のあるコードを注入する可能性があります。スレッド実行ハイジャックは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nスレッド実行ハイジャックは、通常、既存のプロセスを中断し、そのメモリをアンマップ/空洞化した後、悪意のあるコードまたはDLLへのパスに置き換えることによって実行されます。既存の被害者プロセスへのハンドルは、まず<code>OpenThread</code>などのネイティブWindows API呼び出しで作成されます。この時点で、プロセスは中断された後、書き込まれ、注入されたコードに再配置され、それぞれ<code>SuspendThread </code>、<code>VirtualAllocEx</code>、<code>WriteProcessMemory</code>、<code>SetThreadContext</code>、そして<code>ResumeThread</code>を介して再開されます。(引用: Elastic Process Injection July 2017)\n\nこれは[プロセスハロウイング](https://attack.mitre.org/techniques/T1055/012)と非常によく似ていますが、中断状態でプロセスを作成するのではなく、既存のプロセスをターゲットにします。\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。スレッド実行ハイジャックによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.008",
                    "name_eng": "Ptrace System Calls",
                    "name_jp": "Ptraceシステムコール",
                    "description_eng": "Adversaries may inject malicious code into processes via ptrace (process trace) system calls in order to evade process-based defenses as well as possibly elevate privileges. Ptrace system call injection is a method of executing arbitrary code in the address space of a separate live process. \n\nPtrace system call injection involves attaching to and modifying a running process. The ptrace system call enables a debugging process to observe and control another process (and each individual thread), including changing memory and register values.(Citation: PTRACE man) Ptrace system call injection is commonly performed by writing arbitrary code into a running process (ex: <code>malloc</code>) then invoking that memory with <code>PTRACE_SETREGS</code> to set the register containing the next instruction to execute. Ptrace system call injection can also be done with <code>PTRACE_POKETEXT</code>/<code>PTRACE_POKEDATA</code>, which copy data to a specific address in the target processes’ memory (ex: the current address of the next instruction). (Citation: PTRACE man)(Citation: Medium Ptrace JUL 2018) \n\nPtrace system call injection may not be possible targeting processes that are non-child processes and/or have higher-privileges.(Citation: BH Linux Inject) \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via ptrace system call injection may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、ptrace（プロセストレース）システムコールを介してプロセスに悪意のあるコードを注入する可能性があります。Ptraceシステムコールインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nPtraceシステムコールインジェクションは、実行中のプロセスにアタッチして変更することを含みます。ptraceシステムコールにより、デバッグプロセスは、メモリやレジスタ値の変更を含む、別のプロセス（および個々のスレッド）を監視および制御できます。(引用: PTRACE man) Ptraceシステムコールインジェクションは、通常、実行中のプロセスに任意のコード（例: <code>malloc</code>）を書き込み、次にそのメモリを<code>PTRACE_SETREGS</code>で呼び出して、次に実行する命令を含むレジスタを設定することによって実行されます。Ptraceシステムコールインジェクションは、<code>PTRACE_POKETEXT</code>/<code>PTRACE_POKEDATA</code>（ターゲットプロセスのメモリ内の特定のアドレス（例: 次の命令の現在のアドレス）にデータをコピーする）でも実行できます。(引用: PTRACE man)(引用: Medium Ptrace JUL 2018)\n\n非子プロセスやより高い権限を持つプロセスをターゲットとする場合、Ptraceシステムコールインジェクションは不可能である可能性があります。(引用: BH Linux Inject)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。ptraceシステムコールインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.004",
                    "name_eng": "Asynchronous Procedure Call",
                    "name_jp": "非同期手続き呼び出し",
                    "description_eng": "Adversaries may inject malicious code into processes via the asynchronous procedure call (APC) queue in order to evade process-based defenses as well as possibly elevate privileges. APC injection is a method of executing arbitrary code in the address space of a separate live process. \n\nAPC injection is commonly performed by attaching malicious code to the APC Queue (Citation: Microsoft APC) of a process's thread. Queued APC functions are executed when the thread enters an alterable state.(Citation: Microsoft APC) A handle to an existing victim process is first created with native Windows API calls such as <code>OpenThread</code>. At this point <code>QueueUserAPC</code> can be used to invoke a function (such as <code>LoadLibrayA</code> pointing to a malicious DLL). \n\nA variation of APC injection, dubbed \"Early Bird injection\", involves creating a suspended process in which malicious code can be written and executed before the process' entry point (and potentially subsequent anti-malware hooks) via an APC. (Citation: CyberBit Early Bird Apr 2018) AtomBombing (Citation: ENSIL AtomBombing Oct 2016) is another variation that utilizes APCs to invoke malicious code previously written to the global atom table.(Citation: Microsoft Atom Table)\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via APC injection may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、非同期プロシージャコール（APC）キューを介してプロセスに悪意のあるコードを注入する可能性があります。APCインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nAPCインジェクションは、一般的に、プロセスのスレッドのAPCキュー（引用: Microsoft APC）に悪意のあるコードをアタッチすることによって実行されます。キューに入れられたAPC関数は、スレッドが変更可能な状態に入ったときに実行されます。(引用: Microsoft APC) 既存の被害者プロセスへのハンドルは、まず<code>OpenThread</code>などのネイティブWindows API呼び出しで作成されます。この時点で、<code>QueueUserAPC</code>を使用して関数（悪意のあるDLLを指す<code>LoadLibrayA</code>など）を呼び出すことができます。\n\n「アーリーバードインジェクション」と呼ばれるAPCインジェクションの変形は、プロセスのエントリポイント（および潜在的な後続のマルウェア対策フック）の前にAPCを介して悪意のあるコードを書き込んで実行できる中断プロセスを作成することを含みます。(引用: CyberBit Early Bird Apr 2018) AtomBombing（引用: ENSIL AtomBombing Oct 2016）は、以前にグローバルアトムテーブルに書き込まれた悪意のあるコードを呼び出すためにAPCを利用する別の変形です。(引用: Microsoft Atom Table)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。APCインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                },
                {
                    "id": "T1055.002",
                    "name_eng": "Portable Executable Injection",
                    "name_jp": "ポータブル実行可能インジェクション",
                    "description_eng": "Adversaries may inject portable executables (PE) into processes in order to evade process-based defenses as well as possibly elevate privileges. PE injection is a method of executing arbitrary code in the address space of a separate live process. \n\nPE injection is commonly performed by copying code (perhaps without a file on disk) into the virtual address space of the target process before invoking it via a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> or additional code (ex: shellcode). The displacement of the injected code does introduce the additional requirement for functionality to remap memory references. (Citation: Elastic Process Injection July 2017) \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via PE injection may also evade detection from security products since the execution is masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスベースの防御を回避し、場合によっては権限を昇格させるために、ポータブル実行可能ファイル（PE）をプロセスに注入する可能性があります。PEインジェクションは、別のライブプロセスのアドレス空間で任意のコードを実行する手法です。\n\nPEインジェクションは、一般的に、新しいスレッドを介して呼び出す前に、コード（ディスク上のファイルなしの場合もある）をターゲットプロセスの仮想アドレス空間にコピーすることによって実行されます。書き込みは、<code>VirtualAllocEx</code>や<code>WriteProcessMemory</code>などのネイティブWindows API呼び出しで実行でき、その後<code>CreateRemoteThread</code>または追加のコード（例: シェルコード）で呼び出されます。注入されたコードの変位は、メモリ参照を再マップする機能に対する追加の要件を導入します。(引用: Elastic Process Injection July 2017)\n\n別のプロセスのコンテキストでコードを実行すると、そのプロセスのメモリ、システム/ネットワークリソースへのアクセスが可能になり、場合によっては権限が昇格される可能性があります。PEインジェクションによる実行は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品による検出を回避する可能性もあります。"
                }
            ]
        },
        {
            "id": "T1611",
            "name_eng": "Escape to Host",
            "name_jp": "ホストへのエスケープ",
            "description_eng": "Adversaries may break out of a container or virtualized environment to gain access to the underlying host. This can allow an adversary access to other containerized or virtualized resources from the host level or to the host itself. In principle, containerized / virtualized resources should provide a clear separation of application functionality and be isolated from the host environment.(Citation: Docker Overview)\n\nThere are multiple ways an adversary may escape from a container to a host environment. Examples include creating a container configured to mount the host’s filesystem using the bind parameter, which allows the adversary to drop payloads and execute control utilities such as cron on the host; utilizing a privileged container to run commands or load a malicious kernel module on the underlying host; or abusing system calls such as `unshare` and `keyctl` to escalate privileges and steal secrets.(Citation: Docker Bind Mounts)(Citation: Trend Micro Privileged Container)(Citation: Intezer Doki July 20)(Citation: Container Escape)(Citation: Crowdstrike Kubernetes Container Escape)(Citation: Keyctl-unmask)\n\nAdditionally, an adversary may be able to exploit a compromised container with a mounted container management socket, such as `docker.sock`, to break out of the container via a [Container Administration Command](https://attack.mitre.org/techniques/T1609).(Citation: Container Escape) Adversaries may also escape via [Exploitation for Privilege Escalation](https://attack.mitre.org/techniques/T1068), such as exploiting vulnerabilities in global symbolic links in order to access the root directory of a host machine.(Citation: Windows Server Containers Are Open)\n\nIn ESXi environments, an adversary may exploit a vulnerability in order to escape from a virtual machine into the hypervisor.(Citation: Broadcom VMSA-2025-004)\n\nGaining access to the host may provide the adversary with the opportunity to achieve follow-on objectives, such as establishing persistence, moving laterally within the environment, accessing other containers or virtual machines running on the host, or setting up a command and control channel on the host.",
            "description_jp": "攻撃者は、コンテナまたは仮想化環境から抜け出して、基盤となるホストへのアクセスを取得する可能性があります。これにより、攻撃者はホストレベルから他のコンテナ化または仮想化されたリソース、あるいはホスト自体にアクセスできるようになります。原則として、コンテナ化/仮想化されたリソースは、アプリケーション機能の明確な分離を提供し、ホスト環境から分離されている必要があります。(引用: Docker Overview)\n\n攻撃者がコンテナからホスト環境にエスケープする方法は複数あります。例としては、バインドパラメータを使用してホストのファイルシステムをマウントするように設定されたコンテナを作成し、これにより攻撃者がペイロードをドロップし、ホスト上でcronなどの制御ユーティリティを実行できるようにすることが含まれます。特権コンテナを利用して、基盤となるホスト上でコマンドを実行したり、悪意のあるカーネルモジュールをロードしたりします。あるいは、`unshare`や`keyctl`などのシステムコールを悪用して権限を昇格させ、秘密を盗みます。(引用: Docker Bind Mounts)(引用: Trend Micro Privileged Container)(引用: Intezer Doki July 20)(引用: Container Escape)(引用: Crowdstrike Kubernetes Container Escape)(引用: Keyctl-unmask)\n\nさらに、攻撃者は、`docker.sock`などのマウントされたコンテナ管理ソケットを持つ侵害されたコンテナを悪用して、[コンテナ管理コマンド](https://attack.mitre.org/techniques/T1609)を介してコンテナから抜け出すことができる場合があります。(引用: Container Escape) 攻撃者はまた、ホストマシンのルートディレクトリにアクセスするためにグローバルシンボリックリンクの脆弱性を悪用するなど、[権限昇格のための悪用](https://attack.mitre.org/techniques/T1068)を介してエスケープする可能性もあります。(引用: Windows Server Containers Are Open)\n\nESXi環境では、攻撃者は脆弱性を悪用して仮想マシンからハイパーバイザにエスケープする可能性があります。(引用: Broadcom VMSA-2025-004)\n\nホストへのアクセスを取得すると、攻撃者は、永続性の確立、環境内での横方向の移動、ホスト上で実行されている他のコンテナや仮想マシンへのアクセス、ホスト上でのコマンドアンドコントロールチャネルの設定など、追跡目標を達成する機会を得る可能性があります。",
            "subtechniques": []
        },
        {
            "id": "T1548",
            "name_eng": "Abuse Elevation Control Mechanism",
            "name_jp": "昇格制御メカニズムの悪用",
            "description_eng": "Adversaries may circumvent mechanisms designed to control elevate privileges to gain higher-level permissions. Most modern systems contain native elevation control mechanisms that are intended to limit privileges that a user can perform on a machine. Authorization has to be granted to specific users in order to perform tasks that can be considered of higher risk.(Citation: TechNet How UAC Works)(Citation: sudo man page 2018) An adversary can perform several methods to take advantage of built-in control mechanisms in order to escalate privileges on a system.(Citation: OSX Keydnap malware)(Citation: Fortinet Fareit)",
            "description_jp": "攻撃者は、より高いレベルの権限を得るために、権限昇格を制御するように設計されたメカニズムを回避する可能性があります。ほとんどの最新システムには、ユーザーがマシン上で実行できる権限を制限することを目的としたネイティブの昇格制御メカニズムが含まれています。より高いリスクと見なされる可能性のあるタスクを実行するためには、特定のユーザーに承認を与える必要があります。(引用: TechNet How UAC Works)(引用: sudo man page 2018) 攻撃者は、システム上で権限を昇格させるために、組み込みの制御メカニズムを利用するいくつかの方法を実行できます。(引用: OSX Keydnap malware)(引用: Fortinet Fareit)",
            "subtechniques": [
                {
                    "id": "T1548.001",
                    "name_eng": "Setuid and Setgid",
                    "name_jp": "SetuidおよびSetgid",
                    "description_eng": "An adversary may abuse configurations where an application has the setuid or setgid bits set in order to get code running in a different (and possibly more privileged) user’s context. On Linux or macOS, when the setuid or setgid bits are set for an application binary, the application will run with the privileges of the owning user or group respectively.(Citation: setuid man page) Normally an application is run in the current user’s context, regardless of which user or group owns the application. However, there are instances where programs need to be executed in an elevated context to function properly, but the user running them may not have the specific required privileges.\n\nInstead of creating an entry in the sudoers file, which must be done by root, any user can specify the setuid or setgid flag to be set for their own applications (i.e. [Linux and Mac File and Directory Permissions Modification](https://attack.mitre.org/techniques/T1222/002)). The <code>chmod</code> command can set these bits with bitmasking, <code>chmod 4777 [file]</code> or via shorthand naming, <code>chmod u+s [file]</code>. This will enable the setuid bit. To enable the setgid bit, <code>chmod 2775</code> and <code>chmod g+s</code> can be used.\n\nAdversaries can use this mechanism on their own malware to make sure they're able to execute in elevated contexts in the future.(Citation: OSX Keydnap malware) This abuse is often part of a \"shell escape\" or other actions to bypass an execution environment with restricted permissions.\n\nAlternatively, adversaries may choose to find and target vulnerable binaries with the setuid or setgid bits already enabled (i.e. [File and Directory Discovery](https://attack.mitre.org/techniques/T1083)). The setuid and setguid bits are indicated with an \"s\" instead of an \"x\" when viewing a file's attributes via <code>ls -l</code>. The <code>find</code> command can also be used to search for such files. For example, <code>find / -perm +4000 2>/dev/null</code> can be used to find files with setuid set and <code>find / -perm +2000 2>/dev/null</code> may be used for setgid. Binaries that have these bits set may then be abused by adversaries.(Citation: GTFOBins Suid)",
                    "description_jp": "攻撃者は、アプリケーションにsetuidまたはsetgidビットが設定されている構成を悪用して、異なる（そして場合によってはより特権的な）ユーザーのコンテキストでコードを実行させることができます。LinuxまたはmacOSでは、アプリケーションバイナリにsetuidまたはsetgidビットが設定されている場合、アプリケーションはそれぞれ所有ユーザーまたはグループの権限で実行されます。(引用: setuid man page) 通常、アプリケーションは、どのユーザーまたはグループがアプリケーションを所有しているかに関係なく、現在のユーザーのコンテキストで実行されます。ただし、プログラムが正しく機能するために昇格されたコンテキストで実行する必要があるが、それらを実行しているユーザーが必要な特定の権限を持っていない場合があります。\n\nrootによって実行する必要があるsudoersファイルにエントリを作成する代わりに、任意のユーザーが自分のアプリケーションにsetuidまたはsetgidフラグを設定するように指定できます（つまり、[LinuxおよびMacのファイルとディレクトリのアクセス許可の変更](https://attack.mitre.org/techniques/T1222/002)）。<code>chmod</code>コマンドは、ビットマスキング（<code>chmod 4777 [file]</code>）または略記名（<code>chmod u+s [file]</code>）を使用してこれらのビットを設定できます。これにより、setuidビットが有効になります。setgidビットを有効にするには、<code>chmod 2775</code>および<code>chmod g+s</code>を使用できます。\n\n攻撃者は、将来昇格されたコンテキストで実行できるようにするために、このメカニズムを独自のマルウェアで使用できます。(引用: OSX Keydnap malware) この悪用は、しばしば「シェルエスケープ」または制限された権限を持つ実行環境をバイパスするためのその他のアクションの一部です。\n\nあるいは、攻撃者は、setuidまたはsetgidビットが既に有効になっている脆弱なバイナリを見つけてターゲットにすることを選択する場合があります（つまり、[ファイルとディレクトリの発見](https://attack.mitre.org/techniques/T1083)）。setuidおよびsetgidビットは、<code>ls -l</code>を介してファイルの属性を表示するときに「x」の代わりに「s」で示されます。<code>find</code>コマンドを使用してそのようなファイルを検索することもできます。例えば、<code>find / -perm +4000 2>/dev/null</code>を使用してsetuidが設定されたファイルを見つけることができ、<code>find / -perm +2000 2>/dev/null</code>をsetgidに使用できます。これらのビットが設定されているバイナリは、攻撃者によって悪用される可能性があります。(引用: GTFOBins Suid)"
                },
                {
                    "id": "T1548.005",
                    "name_eng": "Temporary Elevated Cloud Access",
                    "name_jp": "一時的なクラウドアクセス権限昇格",
                    "description_eng": "Adversaries may abuse permission configurations that allow them to gain temporarily elevated access to cloud resources. Many cloud environments allow administrators to grant user or service accounts permission to request just-in-time access to roles, impersonate other accounts, pass roles onto resources and services, or otherwise gain short-term access to a set of privileges that may be distinct from their own. \n\nJust-in-time access is a mechanism for granting additional roles to cloud accounts in a granular, temporary manner. This allows accounts to operate with only the permissions they need on a daily basis, and to request additional permissions as necessary. Sometimes just-in-time access requests are configured to require manual approval, while other times the desired permissions are automatically granted.(Citation: Azure Just in Time Access 2023)\n\nAccount impersonation allows user or service accounts to temporarily act with the permissions of another account. For example, in GCP users with the `iam.serviceAccountTokenCreator` role can create temporary access tokens or sign arbitrary payloads with the permissions of a service account, while service accounts with domain-wide delegation permission are permitted to impersonate Google Workspace accounts.(Citation: Google Cloud Service Account Authentication Roles)(Citation: Hunters Domain Wide Delegation Google Workspace 2023)(Citation: Google Cloud Just in Time Access 2023)(Citation: Palo Alto Unit 42 Google Workspace Domain Wide Delegation 2023) In Exchange Online, the `ApplicationImpersonation` role allows a service account to use the permissions associated with specified user accounts.(Citation: Microsoft Impersonation and EWS in Exchange) \n\nMany cloud environments also include mechanisms for users to pass roles to resources that allow them to perform tasks and authenticate to other services. While the user that creates the resource does not directly assume the role they pass to it, they may still be able to take advantage of the role's access -- for example, by configuring the resource to perform certain actions with the permissions it has been granted. In AWS, users with the `PassRole` permission can allow a service they create to assume a given role, while in GCP, users with the `iam.serviceAccountUser` role can attach a service account to a resource.(Citation: AWS PassRole)(Citation: Google Cloud Service Account Authentication Roles)\n\nWhile users require specific role assignments in order to use any of these features, cloud administrators may misconfigure permissions. This could result in escalation paths that allow adversaries to gain access to resources beyond what was originally intended.(Citation: Rhino Google Cloud Privilege Escalation)(Citation: Rhino Security Labs AWS Privilege Escalation)\n\n**Note:** this technique is distinct from [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003), which involves assigning permanent roles to accounts rather than abusing existing permissions structures to gain temporarily elevated access to resources. However, adversaries that compromise a sufficiently privileged account may grant another account they control [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003) that would allow them to also abuse these features. This may also allow for greater stealth than would be had by directly using the highly privileged account, especially when logs do not clarify when role impersonation is taking place.(Citation: CrowdStrike StellarParticle January 2022)",
                    "description_jp": "攻撃者は、一時的に昇格されたクラウドリソースへのアクセスを可能にする権限設定を悪用する可能性があります。多くのクラウド環境では、管理者はユーザーアカウントまたはサービスアカウントに対し、ロールへのジャストインタイムアクセスを要求したり、他のアカウントになりすましたり、リソースやサービスにロールを渡したり、あるいは自身の権限とは異なる可能性のある一連の権限への短期的なアクセスを許可することができます。\n\nジャストインタイムアクセスは、クラウドアカウントに追加のロールをきめ細かく一時的に付与するためのメカニズムです。これにより、アカウントは日常的に必要な権限のみで運用し、必要に応じて追加の権限を要求できます。ジャストインタイムアクセス要求は、手動承認が必要なように設定されることもあれば、目的の権限が自動的に付与されることもあります。(引用: Azure Just in Time Access 2023)\n\nアカウントの偽装により、ユーザーアカウントまたはサービスアカウントは、一時的に別のアカウントの権限で行動できます。例えば、GCPでは`iam.serviceAccountTokenCreator`ロールを持つユーザーは、サービスアカウントの権限で一時的なアクセストークンを作成したり、任意のペイロードに署名したりできます。一方、ドメイン全体の委任権限を持つサービスアカウントは、Google Workspaceアカウントになりすますことが許可されています。(引用: Google Cloud Service Account Authentication Roles)(引用: Hunters Domain Wide Delegation Google Workspace 2023)(引用: Google Cloud Just in Time Access 2023)(引用: Palo Alto Unit 42 Google Workspace Domain Wide Delegation 2023) Exchange Onlineでは、`ApplicationImpersonation`ロールにより、サービスアカウントは指定されたユーザーアカウントに関連付けられた権限を使用できます。(引用: Microsoft Impersonation and EWS in Exchange)\n\n多くのクラウド環境には、ユーザーがリソースにロールを渡してタスクを実行したり、他のサービスに認証したりすることを可能にするメカニズムも含まれています。リソースを作成するユーザーは、それに渡すロールを直接引き継ぐわけではありませんが、付与された権限で特定のアクションを実行するようにリソースを設定するなどして、ロールのアクセスを利用できる場合があります。AWSでは、`PassRole`権限を持つユーザーは、作成したサービスに特定のロールを引き継がせることができます。一方、GCPでは、`iam.serviceAccountUser`ロールを持つユーザーは、サービスアカウントをリソースにアタッチできます。(引用: AWS PassRole)(引用: Google Cloud Service Account Authentication Roles)\n\nユーザーがこれらの機能のいずれかを使用するには特定のロール割り当てが必要ですが、クラウド管理者は権限を誤って設定する可能性があります。これにより、攻撃者が元々意図されていた範囲を超えてリソースにアクセスできるようになる昇格パスが生じる可能性があります。(引用: Rhino Google Cloud Privilege Escalation)(引用: Rhino Security Labs AWS Privilege Escalation)\n\n**注:** このテクニックは、アカウントに永続的なロールを割り当てるのではなく、既存の権限構造を悪用してリソースへの一時的に昇格されたアクセスを得ることを伴う[追加のクラウドロール](https://attack.mitre.org/techniques/T1098/003)とは異なります。ただし、十分に特権のあるアカウントを侵害した攻撃者は、制御下にある別のアカウントに、これらの機能も悪用できる[追加のクラウドロール](https://attack.mitre.org/techniques/T1098/003)を付与する可能性があります。これは、特にログでロールの偽装が行われているタイミングが明確でない場合、特権の高いアカウントを直接使用するよりもステルス性が高まる可能性があります。(引用: CrowdStrike StellarParticle January 2022)"
                },
                {
                    "id": "T1548.002",
                    "name_eng": "Bypass User Account Control",
                    "name_jp": "ユーザーアカウント制御のバイパス",
                    "description_eng": "Adversaries may bypass UAC mechanisms to elevate process privileges on system. Windows User Account Control (UAC) allows a program to elevate its privileges (tracked as integrity levels ranging from low to high) to perform a task under administrator-level permissions, possibly by prompting the user for confirmation. The impact to the user ranges from denying the operation under high enforcement to allowing the user to perform the action if they are in the local administrators group and click through the prompt or allowing them to enter an administrator password to complete the action.(Citation: TechNet How UAC Works)\n\nIf the UAC protection level of a computer is set to anything but the highest level, certain Windows programs can elevate privileges or execute some elevated [Component Object Model](https://attack.mitre.org/techniques/T1559/001) objects without prompting the user through the UAC notification box.(Citation: TechNet Inside UAC)(Citation: MSDN COM Elevation) An example of this is use of [Rundll32](https://attack.mitre.org/techniques/T1218/011) to load a specifically crafted DLL which loads an auto-elevated [Component Object Model](https://attack.mitre.org/techniques/T1559/001) object and performs a file operation in a protected directory which would typically require elevated access. Malicious software may also be injected into a trusted process to gain elevated privileges without prompting a user.(Citation: Davidson Windows)\n\nMany methods have been discovered to bypass UAC. The Github readme page for UACME contains an extensive list of methods(Citation: Github UACMe) that have been discovered and implemented, but may not be a comprehensive list of bypasses. Additional bypass methods are regularly discovered and some used in the wild, such as:\n\n* <code>eventvwr.exe</code> can auto-elevate and execute a specified binary or script.(Citation: enigma0x3 Fileless UAC Bypass)(Citation: Fortinet Fareit)\n\nAnother bypass is possible through some lateral movement techniques if credentials for an account with administrator privileges are known, since UAC is a single system security mechanism, and the privilege or integrity of a process running on one system will be unknown on remote systems and default to high integrity.(Citation: SANS UAC Bypass)",
                    "description_jp": "攻撃者はUACメカニズムをバイパスして、システム上のプロセス権限を昇格させる可能性があります。Windowsユーザーアカウント制御（UAC）は、プログラムがその権限（低から高までの整合性レベルとして追跡される）を昇格させて、管理者レベルの権限でタスクを実行できるようにするもので、場合によってはユーザーに確認を求めることがあります。ユーザーへの影響は、高強制下での操作の拒否から、ローカル管理者グループに属していてプロンプトをクリックした場合の操作の許可、または管理者パスワードを入力して操作を完了させることまで及びます。(引用: TechNet How UAC Works)\n\nコンピュータのUAC保護レベルが最高レベル以外に設定されている場合、特定のWindowsプログラムは、UAC通知ボックスを介してユーザーにプロンプトを表示することなく、権限を昇格させたり、一部の昇格された[コンポーネントオブジェクトモデル](https://attack.mitre.org/techniques/T1559/001)オブジェクトを実行したりできます。(引用: TechNet Inside UAC)(引用: MSDN COM Elevation) この例としては、[Rundll32](https://attack.mitre.org/techniques/T1218/011)を使用して、自動昇格された[コンポーネントオブジェクトモデル](https://attack.mitre.org/techniques/T1559/001)オブジェクトをロードし、通常は昇格されたアクセスが必要となる保護されたディレクトリでファイル操作を実行する、特別に細工されたDLLをロードすることが挙げられます。悪意のあるソフトウェアが信頼されたプロセスに注入され、ユーザーにプロンプトを表示することなく昇格された権限を取得することもあります。(引用: Davidson Windows)\n\nUACをバイパスする多くの方法が発見されています。UACMEのGithub readmeページには、発見され実装されたメソッドの広範なリストが含まれていますが(引用: Github UACMe)、バイパスの包括的なリストではない可能性があります。追加のバイパス方法は定期的に発見されており、次のようなものが実際に使用されています。\n\n* <code>eventvwr.exe</code>は自動昇格し、指定されたバイナリまたはスクリプトを実行できます。(引用: enigma0x3 Fileless UAC Bypass)(引用: Fortinet Fareit)\n\n管理者権限を持つアカウントの資格情報がわかっている場合、UACは単一システムのセキュリティメカニズムであり、あるシステムで実行されているプロセスの権限や整合性はリモートシステムでは不明であり、デフォルトで高整合性となるため、一部の横方向の移動テクニックを介して別のバイパスが可能です。(引用: SANS UAC Bypass)"
                },
                {
                    "id": "T1548.004",
                    "name_eng": "Elevated Execution with Prompt",
                    "name_jp": "プロンプトによる昇格実行",
                    "description_eng": "Adversaries may leverage the <code>AuthorizationExecuteWithPrivileges</code> API to escalate privileges by prompting the user for credentials.(Citation: AppleDocs AuthorizationExecuteWithPrivileges) The purpose of this API is to give application developers an easy way to perform operations with root privileges, such as for application installation or updating. This API does not validate that the program requesting root privileges comes from a reputable source or has been maliciously modified. \n\nAlthough this API is deprecated, it still fully functions in the latest releases of macOS. When calling this API, the user will be prompted to enter their credentials but no checks on the origin or integrity of the program are made. The program calling the API may also load world writable files which can be modified to perform malicious behavior with elevated privileges.\n\nAdversaries may abuse <code>AuthorizationExecuteWithPrivileges</code> to obtain root privileges in order to install malicious software on victims and install persistence mechanisms.(Citation: Death by 1000 installers; it's all broken!)(Citation: Carbon Black Shlayer Feb 2019)(Citation: OSX Coldroot RAT) This technique may be combined with [Masquerading](https://attack.mitre.org/techniques/T1036) to trick the user into granting escalated privileges to malicious code.(Citation: Death by 1000 installers; it's all broken!)(Citation: Carbon Black Shlayer Feb 2019) This technique has also been shown to work by modifying legitimate programs present on the machine that make use of this API.(Citation: Death by 1000 installers; it's all broken!)",
                    "description_jp": "攻撃者は<code>AuthorizationExecuteWithPrivileges</code> APIを利用して、ユーザーに資格情報を要求することで権限を昇格させる可能性があります。(引用: AppleDocs AuthorizationExecuteWithPrivileges) このAPIの目的は、アプリケーション開発者がアプリケーションのインストールや更新など、ルート権限で操作を簡単に行えるようにすることです。このAPIは、ルート権限を要求するプログラムが信頼できるソースからのものであるか、または悪意を持って変更されていないかを検証しません。\n\nこのAPIは非推奨ですが、macOSの最新リリースでも完全に機能します。このAPIを呼び出すと、ユーザーは資格情報の入力を求められますが、プログラムの出所や整合性に関するチェックは行われません。APIを呼び出すプログラムは、昇格された権限で悪意のある動作を実行するように変更できる、グローバルに書き込み可能なファイルをロードすることもあります。\n\n攻撃者は<code>AuthorizationExecuteWithPrivileges</code>を悪用してルート権限を取得し、被害者に悪意のあるソフトウェアをインストールしたり、永続化メカニズムをインストールしたりする可能性があります。(引用: Death by 1000 installers; it's all broken!)(引用: Carbon Black Shlayer Feb 2019)(引用: OSX Coldroot RAT) このテクニックは、ユーザーを騙して悪意のあるコードに昇格された権限を付与させるために[マスカレード](https://attack.mitre.org/techniques/T1036)と組み合わせることができます。(引用: Death by 1000 installers; it's all broken!)(引用: Carbon Black Shlayer Feb 2019) このテクニックは、このAPIを利用するマシン上に存在する正当なプログラムを変更することでも機能することが示されています。(引用: Death by 1000 installers; it's all broken!)"
                },
                {
                    "id": "T1548.003",
                    "name_eng": "Sudo and Sudo Caching",
                    "name_jp": "SudoおよびSudoキャッシング",
                    "description_eng": "Adversaries may perform sudo caching and/or use the sudoers file to elevate privileges. Adversaries may do this to execute commands as other users or spawn processes with higher privileges.\n\nWithin Linux and MacOS systems, sudo (sometimes referred to as \"superuser do\") allows users to perform commands from terminals with elevated privileges and to control who can perform these commands on the system. The <code>sudo</code> command \"allows a system administrator to delegate authority to give certain users (or groups of users) the ability to run some (or all) commands as root or another user while providing an audit trail of the commands and their arguments.\"(Citation: sudo man page 2018) Since sudo was made for the system administrator, it has some useful configuration features such as a <code>timestamp_timeout</code>, which is the amount of time in minutes between instances of <code>sudo</code> before it will re-prompt for a password. This is because <code>sudo</code> has the ability to cache credentials for a period of time. Sudo creates (or touches) a file at <code>/var/db/sudo</code> with a timestamp of when sudo was last run to determine this timeout. Additionally, there is a <code>tty_tickets</code> variable that treats each new tty (terminal session) in isolation. This means that, for example, the sudo timeout of one tty will not affect another tty (you will have to type the password again).\n\nThe sudoers file, <code>/etc/sudoers</code>, describes which users can run which commands and from which terminals. This also describes which commands users can run as other users or groups. This provides the principle of least privilege such that users are running in their lowest possible permissions for most of the time and only elevate to other users or permissions as needed, typically by prompting for a password. However, the sudoers file can also specify when to not prompt users for passwords with a line like <code>user1 ALL=(ALL) NOPASSWD: ALL</code>.(Citation: OSX.Dok Malware) Elevated privileges are required to edit this file though.\n\nAdversaries can also abuse poor configurations of these mechanisms to escalate privileges without needing the user's password. For example, <code>/var/db/sudo</code>'s timestamp can be monitored to see if it falls within the <code>timestamp_timeout</code> range. If it does, then malware can execute sudo commands without needing to supply the user's password. Additional, if <code>tty_tickets</code> is disabled, adversaries can do this from any tty for that user.\n\nIn the wild, malware has disabled <code>tty_tickets</code> to potentially make scripting easier by issuing <code>echo \\'Defaults !tty_tickets\\' >> /etc/sudoers</code>.(Citation: cybereason osx proton) In order for this change to be reflected, the malware also issued <code>killall Terminal</code>. As of macOS Sierra, the sudoers file has <code>tty_tickets</code> enabled by default.",
                    "description_jp": "攻撃者はsudoキャッシングを実行したり、sudoersファイルを使用して権限を昇格させたりする可能性があります。攻撃者はこれを利用して、他のユーザーとしてコマンドを実行したり、より高い権限でプロセスを起動したりする可能性があります。\n\nLinuxおよびMacOSシステム内では、sudo（「スーパーユーザー実行」とも呼ばれる）により、ユーザーは昇格された権限でターミナルからコマンドを実行し、システム上でこれらのコマンドを実行できるユーザーを制御できます。<code>sudo</code>コマンドは、「システム管理者が、特定のユーザー（またはユーザーグループ）に、コマンドとその引数の監査証跡を提供しながら、ルートまたは別のユーザーとして一部（またはすべて）のコマンドを実行する権限を与えることを許可します。」(引用: sudo man page 2018) sudoはシステム管理者向けに作成されたため、<code>timestamp_timeout</code>などの便利な構成機能があります。これは、パスワードの再入力を求める前に<code>sudo</code>のインスタンス間で経過する時間（分単位）です。これは、<code>sudo</code>が一定期間資格情報をキャッシュする機能を持っているためです。Sudoは、このタイムアウトを決定するために、最後にsudoが実行されたときのタイムスタンプを持つファイルを<code>/var/db/sudo</code>に作成（またはタッチ）します。さらに、各新しいtty（ターミナルセッション）を個別に扱う<code>tty_tickets</code>変数があります。これは、たとえば、あるttyのsudoタイムアウトが別のttyに影響しないことを意味します（再度パスワードを入力する必要があります）。\n\n<code>/etc/sudoers</code>ファイルは、どのユーザーがどのコマンドをどのターミナルから実行できるかを記述します。また、ユーザーが他のユーザーまたはグループとして実行できるコマンドも記述します。これにより、ユーザーはほとんどの場合、可能な限り低い権限で実行し、必要に応じて他のユーザーまたは権限に昇格する（通常はパスワードの入力を求める）という最小権限の原則が提供されます。ただし、sudoersファイルは、<code>user1 ALL=(ALL) NOPASSWD: ALL</code>のような行でユーザーにパスワードの入力を求めないように指定することもできます。(引用: OSX.Dok Malware) ただし、このファイルを編集するには昇格された権限が必要です。\n\n攻撃者はまた、これらのメカニズムの不適切な構成を悪用して、ユーザーのパスワードを必要とせずに権限を昇格させる可能性があります。例えば、<code>/var/db/sudo</code>のタイムスタンプを監視して、<code>timestamp_timeout</code>の範囲内にあるかどうかを確認できます。もしそうであれば、マルウェアはユーザーのパスワードを入力する必要なくsudoコマンドを実行できます。さらに、<code>tty_tickets</code>が無効になっている場合、攻撃者はそのユーザーの任意のttyからこれを実行できます。\n\n実際に、マルウェアはスクリプト作成を容易にするために、<code>echo \\'Defaults !tty_tickets\\' >> /etc/sudoers</code>を発行して<code>tty_tickets</code>を無効にしています。(引用: cybereason osx proton) この変更を反映させるために、マルウェアは<code>killall Terminal</code>も発行しました。macOS Sierra以降、sudoersファイルではデフォルトで<code>tty_tickets</code>が有効になっています。"
                },
                {
                    "id": "T1548.006",
                    "name_eng": "TCC Manipulation",
                    "name_jp": "TCC操作",
                    "description_eng": "Adversaries can manipulate or abuse the Transparency, Consent, & Control (TCC) service or database to grant malicious executables elevated permissions. TCC is a Privacy & Security macOS control mechanism used to determine if the running process has permission to access the data or services protected by TCC, such as screen sharing, camera, microphone, or Full Disk Access (FDA).\n\nWhen an application requests to access data or a service protected by TCC, the TCC daemon (`tccd`) checks the TCC database, located at `/Library/Application Support/com.apple.TCC/TCC.db` (and `~/` equivalent), and an overwrites file (if connected to an MDM) for existing permissions. If permissions do not exist, then the user is prompted to grant permission. Once permissions are granted, the database stores the application's permissions and will not prompt the user again unless reset. For example, when a web browser requests permissions to the user's webcam, once granted the web browser may not explicitly prompt the user again.(Citation: welivesecurity TCC)\n\nAdversaries may access restricted data or services protected by TCC through abusing applications previously granted permissions through [Process Injection](https://attack.mitre.org/techniques/T1055) or executing a malicious binary using another application. For example, adversaries can use Finder, a macOS native app with FDA permissions, to execute a malicious [AppleScript](https://attack.mitre.org/techniques/T1059/002). When executing under the Finder App, the malicious [AppleScript](https://attack.mitre.org/techniques/T1059/002) inherits access to all files on the system without requiring a user prompt. When System Integrity Protection (SIP) is disabled, TCC protections are also disabled. For a system without SIP enabled, adversaries can manipulate the TCC database to add permissions to their malicious executable through loading an adversary controlled TCC database using environment variables and [Launchctl](https://attack.mitre.org/techniques/T1569/001).(Citation: TCC macOS bypass)(Citation: TCC Database)",
                    "description_jp": "攻撃者は、透過性、同意、制御（TCC）サービスまたはデータベースを操作または悪用して、悪意のある実行可能ファイルに昇格された権限を付与する可能性があります。TCCは、実行中のプロセスが画面共有、カメラ、マイク、またはフルディスクアクセス（FDA）など、TCCによって保護されているデータまたはサービスにアクセスする権限を持っているかどうかを判断するために使用されるPrivacy & Security macOS制御メカニズムです。\n\nアプリケーションがTCCによって保護されているデータまたはサービスへのアクセスを要求すると、TCCデーモン（`tccd`）は、`/Library/Application Support/com.apple.TCC/TCC.db`（および`~/`同等物）にあるTCCデータベースと、既存の権限についての上書きファイル（MDMに接続されている場合）を確認します。権限が存在しない場合は、ユーザーに権限の付与を求めるプロンプトが表示されます。権限が付与されると、データベースはアプリケーションの権限を保存し、リセットされない限りユーザーに再度プロンプトを表示しません。例えば、WebブラウザがユーザーのWebカメラへの権限を要求した場合、一度付与されるとWebブラウザはユーザーに明示的に再度プロンプトを表示しない場合があります。(引用: welivesecurity TCC)\n\n攻撃者は、以前に[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)を介して権限が付与されたアプリケーションを悪用したり、別のアプリケーションを使用して悪意のあるバイナリを実行したりすることで、TCCによって保護されている制限されたデータまたはサービスにアクセスする可能性があります。例えば、攻撃者はFDA権限を持つmacOSネイティブアプリであるFinderを使用して、悪意のある[AppleScript](https://attack.mitre.org/techniques/T1059/002)を実行できます。Finderアプリで実行すると、悪意のある[AppleScript](https://attack.mitre.org/techniques/T1059/002)はユーザープロンプトを必要とせずにシステム上のすべてのファイルへのアクセスを継承します。システム整合性保護（SIP）が無効になっている場合、TCC保護も無効になります。SIPが無効になっているシステムの場合、攻撃者は環境変数と[Launchctl](https://attack.mitre.org/techniques/T1569/001)を使用して攻撃者が制御するTCCデータベースをロードすることにより、TCCデータベースを操作して悪意のある実行可能ファイルに権限を追加できます。(引用: TCC macOS bypass)(引用: TCC Database)"
                }
            ]
        },
        {
            "id": "T1098",
            "name_eng": "Account Manipulation",
            "name_jp": "アカウント操作",
            "description_eng": "Adversaries may manipulate accounts to maintain and/or elevate access to victim systems. Account manipulation may consist of any action that preserves or modifies adversary access to a compromised account, such as modifying credentials or permission groups.(Citation: FireEye SMOKEDHAM June 2021) These actions could also include account activity designed to subvert security policies, such as performing iterative password updates to bypass password duration policies and preserve the life of compromised credentials. \n\nIn order to create or manipulate accounts, the adversary must already have sufficient permissions on systems or the domain. However, account manipulation may also lead to privilege escalation where modifications grant access to additional roles, permissions, or higher-privileged [Valid Accounts](https://attack.mitre.org/techniques/T1078).",
            "description_jp": "攻撃者は、被害者システムへのアクセスを維持および/または昇格させるためにアカウントを操作する可能性があります。アカウント操作は、資格情報や権限グループの変更など、侵害されたアカウントへの攻撃者のアクセスを維持または変更するあらゆるアクションで構成される可能性があります。(引用: FireEye SMOKEDHAM June 2021) これらのアクションには、パスワード期間ポリシーをバイパスして侵害された資格情報の寿命を維持するために反復的なパスワード更新を実行するなど、セキュリティポリシーを破壊するように設計されたアカウントアクティビティも含まれる可能性があります。\n\nアカウントを作成または操作するためには、攻撃者はシステムまたはドメインに対する十分な権限を既に持っている必要があります。ただし、アカウント操作は、変更によって追加の役割、権限、またはより権限の高い[有効なアカウント](https://attack.mitre.org/techniques/T1078)へのアクセスが付与される特権昇格につながる可能性もあります。",
            "subtechniques": [
                {
                    "id": "T1098.001",
                    "name_eng": "Additional Cloud Credentials",
                    "name_jp": "追加のクラウド認証情報",
                    "description_eng": "Adversaries may add adversary-controlled credentials to a cloud account to maintain persistent access to victim accounts and instances within the environment.\n\nFor example, adversaries may add credentials for Service Principals and Applications in addition to existing legitimate credentials in Azure / Entra ID.(Citation: Microsoft SolarWinds Customer Guidance)(Citation: Blue Cloud of Death)(Citation: Blue Cloud of Death Video) These credentials include both x509 keys and passwords.(Citation: Microsoft SolarWinds Customer Guidance) With sufficient permissions, there are a variety of ways to add credentials including the Azure Portal, Azure command line interface, and Azure or Az PowerShell modules.(Citation: Demystifying Azure AD Service Principals)\n\nIn infrastructure-as-a-service (IaaS) environments, after gaining access through [Cloud Accounts](https://attack.mitre.org/techniques/T1078/004), adversaries may generate or import their own SSH keys using either the <code>CreateKeyPair</code> or <code>ImportKeyPair</code> API in AWS or the <code>gcloud compute os-login ssh-keys add</code> command in GCP.(Citation: GCP SSH Key Add) This allows persistent access to instances within the cloud environment without further usage of the compromised cloud accounts.(Citation: Expel IO Evil in AWS)(Citation: Expel Behind the Scenes)\n\nAdversaries may also use the <code>CreateAccessKey</code> API in AWS or the <code>gcloud iam service-accounts keys create</code> command in GCP to add access keys to an account. Alternatively, they may use the <code>CreateLoginProfile</code> API in AWS to add a password that can be used to log into the AWS Management Console for [Cloud Service Dashboard](https://attack.mitre.org/techniques/T1538).(Citation: Permiso Scattered Spider 2023)(Citation: Lacework AI Resource Hijacking 2024) If the target account has different permissions from the requesting account, the adversary may also be able to escalate their privileges in the environment (i.e. [Cloud Accounts](https://attack.mitre.org/techniques/T1078/004)).(Citation: Rhino Security Labs AWS Privilege Escalation)(Citation: Sysdig ScarletEel 2.0) For example, in Entra ID environments, an adversary with the Application Administrator role can add a new set of credentials to their application's service principal. In doing so the adversary would be able to access the service principal’s roles and permissions, which may be different from those of the Application Administrator.(Citation: SpecterOps Azure Privilege Escalation) \n\nIn AWS environments, adversaries with the appropriate permissions may also use the `sts:GetFederationToken` API call to create a temporary set of credentials to [Forge Web Credentials](https://attack.mitre.org/techniques/T1606) tied to the permissions of the original user account. These temporary credentials may remain valid for the duration of their lifetime even if the original account’s API credentials are deactivated.\n(Citation: Crowdstrike AWS User Federation Persistence)\n\nIn Entra ID environments with the app password feature enabled, adversaries may be able to add an app password to a user account.(Citation: Mandiant APT42 Operations 2024) As app passwords are intended to be used with legacy devices that do not support multi-factor authentication (MFA), adding an app password can allow an adversary to bypass MFA requirements. Additionally, app passwords may remain valid even if the user’s primary password is reset.(Citation: Microsoft Entra ID App Passwords)",
                    "description_jp": "攻撃者は、環境内の被害者アカウントおよびインスタンスへの永続的なアクセスを維持するために、攻撃者が制御する資格情報をクラウドアカウントに追加する可能性があります。\n\n例えば、攻撃者は、Azure / Entra IDの既存の正当な資格情報に加えて、サービスプリンシパルおよびアプリケーションの資格情報を追加する可能性があります。(引用: Microsoft SolarWinds Customer Guidance)(引用: Blue Cloud of Death)(引用: Blue Cloud of Death Video) これらの資格情報には、x509キーとパスワードの両方が含まれます。(引用: Microsoft SolarWinds Customer Guidance) 十分な権限があれば、Azureポータル、Azureコマンドラインインターフェイス、AzureまたはAz PowerShellモジュールなど、資格情報を追加するさまざまな方法があります。(引用: Demystifying Azure AD Service Principals)\n\nInfrastructure-as-a-Service（IaaS）環境では、[クラウドアカウント](https://attack.mitre.org/techniques/T1078/004)を通じてアクセスを取得した後、攻撃者はAWSの<code>CreateKeyPair</code>または<code>ImportKeyPair</code> API、あるいはGCPの<code>gcloud compute os-login ssh-keys add</code>コマンドを使用して独自のSSHキーを生成またはインポートする可能性があります。(引用: GCP SSH Key Add) これにより、侵害されたクラウドアカウントをさらに使用することなく、クラウド環境内のインスタンスへの永続的なアクセスが可能になります。(引用: Expel IO Evil in AWS)(引用: Expel Behind the Scenes)\n\n攻撃者はまた、AWSの<code>CreateAccessKey</code> APIまたはGCPの<code>gcloud iam service-accounts keys create</code>コマンドを使用してアカウントにアクセスキーを追加することもあります。あるいは、AWSの<code>CreateLoginProfile</code> APIを使用して、[クラウドサービスダッシュボード](https://attack.mitre.org/techniques/T1538)用のAWS管理コンソールへのログインに使用できるパスワードを追加することもあります。(引用: Permiso Scattered Spider 2023)(引用: Lacework AI Resource Hijacking 2024) ターゲットアカウントが要求元アカウントと異なる権限を持っている場合、攻撃者は環境内で権限を昇格させることもできる可能性があります（つまり、[クラウドアカウント](https://attack.mitre.org/techniques/T1078/004)）。(引用: Rhino Security Labs AWS Privilege Escalation)(引用: Sysdig ScarletEel 2.0) 例えば、Entra ID環境では、アプリケーション管理者ロールを持つ攻撃者は、自分のアプリケーションのサービスプリンシパルに新しい資格情報のセットを追加できます。そうすることで、攻撃者はサービスプリンシパルのロールと権限にアクセスできるようになり、これらはアプリケーション管理者のものとは異なる可能性があります。(引用: SpecterOps Azure Privilege Escalation)\n\nAWS環境では、適切な権限を持つ攻撃者は、`sts:GetFederationToken` API呼び出しを使用して、元のユーザーアカウントの権限に関連付けられた[Web認証情報の偽造](https://attack.mitre.org/techniques/T1606)のための一時的な資格情報セットを作成することもできます。これらの一時的な資格情報は、元のアカウントのAPI資格情報が無効化された場合でも、その有効期間中は有効なままです。\n(引用: Crowdstrike AWS User Federation Persistence)\n\nアプリパスワード機能が有効になっているEntra ID環境では、攻撃者はユーザーアカウントにアプリパスワードを追加できる可能性があります。(引用: Mandiant APT42 Operations 2024) アプリパスワードは多要素認証（MFA）をサポートしていないレガシーデバイスで使用することを目的としているため、アプリパスワードを追加すると、攻撃者はMFA要件をバイパスできるようになります。さらに、アプリパスワードは、ユーザーのプライマリパスワードがリセットされた場合でも有効なままです。(引用: Microsoft Entra ID App Passwords)"
                },
                {
                    "id": "T1098.002",
                    "name_eng": "Additional Email Delegate Permissions",
                    "name_jp": "追加のメール委任権限",
                    "description_eng": "Adversaries may grant additional permission levels to maintain persistent access to an adversary-controlled email account. \n\nFor example, the <code>Add-MailboxPermission</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001) cmdlet, available in on-premises Exchange and in the cloud-based service Office 365, adds permissions to a mailbox.(Citation: Microsoft - Add-MailboxPermission)(Citation: FireEye APT35 2018)(Citation: Crowdstrike Hiding in Plain Sight 2018) In Google Workspace, delegation can be enabled via the Google Admin console and users can delegate accounts via their Gmail settings.(Citation: Gmail Delegation)(Citation: Google Ensuring Your Information is Safe) \n\nAdversaries may also assign mailbox folder permissions through individual folder permissions or roles. In Office 365 environments, adversaries may assign the Default or Anonymous user permissions or roles to the Top of Information Store (root), Inbox, or other mailbox folders. By assigning one or both user permissions to a folder, the adversary can utilize any other account in the tenant to maintain persistence to the target user’s mail folders.(Citation: Mandiant Defend UNC2452 White Paper)\n\nThis may be used in persistent threat incidents as well as BEC (Business Email Compromise) incidents where an adversary can add [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003) to the accounts they wish to compromise. This may further enable use of additional techniques for gaining access to systems. For example, compromised business accounts are often used to send messages to other accounts in the network of the target business while creating inbox rules (ex: [Internal Spearphishing](https://attack.mitre.org/techniques/T1534)), so the messages evade spam/phishing detection mechanisms.(Citation: Bienstock, D. - Defending O365 - 2019)",
                    "description_jp": "攻撃者は、攻撃者が制御する電子メールアカウントへの永続的なアクセスを維持するために、追加の許可レベルを付与する可能性があります。\n\n例えば、オンプレミスのExchangeおよびクラウドベースのサービスOffice 365で利用可能な<code>Add-MailboxPermission</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001)コマンドレットは、メールボックスに権限を追加します。(引用: Microsoft - Add-MailboxPermission)(引用: FireEye APT35 2018)(引用: Crowdstrike Hiding in Plain Sight 2018) Google Workspaceでは、Google管理コンソール経由で委任を有効にでき、ユーザーはGmail設定経由でアカウントを委任できます。(引用: Gmail Delegation)(引用: Google Ensuring Your Information is Safe)\n\n攻撃者はまた、個々のフォルダ権限または役割を通じてメールボックスフォルダの権限を割り当てる可能性があります。Office 365環境では、攻撃者は情報ストアのトップ（ルート）、受信トレイ、またはその他のメールボックスフォルダにデフォルトまたは匿名ユーザーの権限または役割を割り当てる可能性があります。フォルダに1つまたは両方のユーザー権限を割り当てることにより、攻撃者はテナント内の他のアカウントを利用して、ターゲットユーザーのメールフォルダへの永続性を維持できます。(引用: Mandiant Defend UNC2452 White Paper)\n\nこれは、攻撃者が侵害したいアカウントに[追加のクラウドロール](https://attack.mitre.org/techniques/T1098/003)を追加できる永続的な脅威インシデントやBEC（ビジネスメール詐欺）インシデントで使用される可能性があります。これにより、システムへのアクセスを取得するための追加のテクニックの使用がさらに可能になる場合があります。例えば、侵害されたビジネスアカウントは、受信トレイのルールを作成しながら（例：[内部スピアフィッシング](https://attack.mitre.org/techniques/T1534)）、ターゲットビジネスのネットワーク内の他のアカウントにメッセージを送信するためによく使用され、メッセージがスパム/フィッシング検出メカニズムを回避できるようにします。(引用: Bienstock, D. - Defending O365 - 2019)"
                },
                {
                    "id": "T1098.003",
                    "name_eng": "Additional Cloud Roles",
                    "name_jp": "追加のクラウドロール",
                    "description_eng": "An adversary may add additional roles or permissions to an adversary-controlled cloud account to maintain persistent access to a tenant. For example, adversaries may update IAM policies in cloud-based environments or add a new global administrator in Office 365 environments.(Citation: AWS IAM Policies and Permissions)(Citation: Google Cloud IAM Policies)(Citation: Microsoft Support O365 Add Another Admin, October 2019)(Citation: Microsoft O365 Admin Roles) With sufficient permissions, a compromised account can gain almost unlimited access to data and settings (including the ability to reset the passwords of other admins).(Citation: Expel AWS Attacker)\n(Citation: Microsoft O365 Admin Roles) \n\nThis account modification may immediately follow [Create Account](https://attack.mitre.org/techniques/T1136) or other malicious account activity. Adversaries may also modify existing [Valid Accounts](https://attack.mitre.org/techniques/T1078) that they have compromised. This could lead to privilege escalation, particularly if the roles added allow for lateral movement to additional accounts.\n\nFor example, in AWS environments, an adversary with appropriate permissions may be able to use the <code>CreatePolicyVersion</code> API to define a new version of an IAM policy or the <code>AttachUserPolicy</code> API to attach an IAM policy with additional or distinct permissions to a compromised user account.(Citation: Rhino Security Labs AWS Privilege Escalation)\n\nIn some cases, adversaries may add roles to adversary-controlled accounts outside the victim cloud tenant. This allows these external accounts to perform actions inside the victim tenant without requiring the adversary to [Create Account](https://attack.mitre.org/techniques/T1136) or modify a victim-owned account.(Citation: Invictus IR DangerDev 2024)",
                    "description_jp": "攻撃者は、テナントへの永続的なアクセスを維持するために、攻撃者が制御するクラウドアカウントに追加のロールや権限を追加する可能性があります。例えば、攻撃者はクラウドベースの環境でIAMポリシーを更新したり、Office 365環境で新しいグローバル管理者を追加したりする可能性があります。(引用: AWS IAM Policies and Permissions)(Citation: Google Cloud IAM Policies)(Citation: Microsoft Support O365 Add Another Admin, October 2019)(Citation: Microsoft O365 Admin Roles) 十分な権限があれば、侵害されたアカウントはデータや設定にほぼ無制限にアクセスできるようになります(他の管理者のパスワードをリセットする機能を含む)。(引用: Expel AWS Attacker)\n(引用：Microsoft O365管理者の役割)\n\nこのアカウント変更は、[アカウントの作成](https://attack.mitre.org/techniques/T1136)または他の悪意のあるアカウント活動の直後に行われる可能性があります。攻撃者は、侵害した既存の[有効なアカウント](https://attack.mitre.org/techniques/T1078)を変更することもあります。これは、特に追加されたロールが追加のアカウントへの横方向の移動を許可している場合、特権の昇格につながる可能性があります。\n\n例えば、AWS 環境では、適切な権限を持つ敵は、<code>CreatePolicyVersion</code> API を使用して IAM ポリシーの新しいバージョンを定義したり、<code>AttachUserPolicy</code> API を使用して、侵害されたユーザーアカウントに追加または別の権限を持つ IAM ポリシーをアタッチすることができます。(引用: Rhino Security Labs AWS Privilege Escalation)\n\n場合によっては、敵対者は被害者のクラウドテナントの外部で敵対者が管理するアカウントにロールを追加することがあります。これにより、これらの外部アカウントは、敵対者が[アカウントの作成](https://attack.mitre.org/techniques/T1136)または被害者が所有するアカウントを変更することなく、被害者テナント内でアクションを実行できるようになります(引用: Invictus IR DangerDev 2024)。"
                },
                {
                    "id": "T1098.005",
                    "name_eng": "Device Registration",
                    "name_jp": "デバイス登録",
                    "description_eng": "Adversaries may register a device to an adversary-controlled account. Devices may be registered in a multifactor authentication (MFA) system, which handles authentication to the network, or in a device management system, which handles device access and compliance.\n\nMFA systems, such as Duo or Okta, allow users to associate devices with their accounts in order to complete MFA requirements. An adversary that compromises a user’s credentials may enroll a new device in order to bypass initial MFA requirements and gain persistent access to a network.(Citation: CISA MFA PrintNightmare)(Citation: DarkReading FireEye SolarWinds) In some cases, the MFA self-enrollment process may require only a username and password to enroll the account's first device or to enroll a device to an inactive account. (Citation: Mandiant APT29 Microsoft 365 2022)\n\nSimilarly, an adversary with existing access to a network may register a device to Entra ID and/or its device management system, Microsoft Intune, in order to access sensitive data or resources while bypassing conditional access policies.(Citation: AADInternals - Device Registration)(Citation: AADInternals - Conditional Access Bypass)(Citation: Microsoft DEV-0537) \n\nDevices registered in Entra ID may be able to conduct [Internal Spearphishing](https://attack.mitre.org/techniques/T1534) campaigns via intra-organizational emails, which are less likely to be treated as suspicious by the email client.(Citation: Microsoft - Device Registration) Additionally, an adversary may be able to perform a [Service Exhaustion Flood](https://attack.mitre.org/techniques/T1499/002) on an Entra ID tenant by registering a large number of devices.(Citation: AADInternals - BPRT)",
                    "description_jp": "攻撃者は、攻撃者が制御するアカウントにデバイスを登録する可能性があります。デバイスは、ネットワークへの認証を処理する多要素認証（MFA）システム、またはデバイスアクセスとコンプライアンスを処理するデバイス管理システムに登録される場合があります。\n\nMFAシステム（DuoやOktaなど）では、ユーザーはMFA要件を完了するために自分のアカウントにデバイスを関連付けることができます。ユーザーの資格情報を侵害した攻撃者は、最初のMFA要件をバイパスしてネットワークへの永続的なアクセスを取得するために新しいデバイスを登録する可能性があります。(引用: CISA MFA PrintNightmare)(引用: DarkReading FireEye SolarWinds) 場合によっては、MFA自己登録プロセスでは、アカウントの最初のデバイスを登録するため、または非アクティブなアカウントにデバイスを登録するために、ユーザー名とパスワードのみが必要になることがあります。(引用: Mandiant APT29 Microsoft 365 2022)\n\n同様に、ネットワークへの既存のアクセス権を持つ攻撃者は、条件付きアクセスポリシーをバイパスしながら機密データやリソースにアクセスするために、Entra IDおよび/またはそのデバイス管理システムであるMicrosoft Intuneにデバイスを登録する可能性があります。(引用: AADInternals - Device Registration)(引用: AADInternals - Conditional Access Bypass)(引用: Microsoft DEV-0537)\n\nEntra IDに登録されたデバイスは、組織内メールを介して[内部スピアフィッシング](https://attack.mitre.org/techniques/T1534)キャンペーンを実行できる可能性があり、これはメールクライアントによって疑わしいものとして扱われる可能性が低くなります。(引用: Microsoft - Device Registration) さらに、攻撃者は多数のデバイスを登録することにより、Entra IDテナントに対して[サービス枯渇攻撃](https://attack.mitre.org/techniques/T1499/002)を実行できる可能性があります。(引用: AADInternals - BPRT)"
                },
                {
                    "id": "T1098.006",
                    "name_eng": "Additional Container Cluster Roles",
                    "name_jp": "追加のコンテナクラスターロール",
                    "description_eng": "An adversary may add additional roles or permissions to an adversary-controlled user or service account to maintain persistent access to a container orchestration system. For example, an adversary with sufficient permissions may create a RoleBinding or a ClusterRoleBinding to bind a Role or ClusterRole to a Kubernetes account.(Citation: Kubernetes RBAC)(Citation: Aquasec Kubernetes Attack 2023) Where attribute-based access control (ABAC) is in use, an adversary with sufficient permissions may modify a Kubernetes ABAC policy to give the target account additional permissions.(Citation: Kuberentes ABAC)\n \nThis account modification may immediately follow [Create Account](https://attack.mitre.org/techniques/T1136) or other malicious account activity. Adversaries may also modify existing [Valid Accounts](https://attack.mitre.org/techniques/T1078) that they have compromised.  \n\nNote that where container orchestration systems are deployed in cloud environments, as with Google Kubernetes Engine, Amazon Elastic Kubernetes Service, and Azure Kubernetes Service, cloud-based  role-based access control (RBAC) assignments or ABAC policies can often be used in place of or in addition to local permission assignments.(Citation: Google Cloud Kubernetes IAM)(Citation: AWS EKS IAM Roles for Service Accounts)(Citation: Microsoft Azure Kubernetes Service Service Accounts) In these cases, this technique may be used in conjunction with [Additional Cloud Roles](https://attack.mitre.org/techniques/T1098/003).",
                    "description_jp": "攻撃者は、コンテナオーケストレーションシステムへの永続的なアクセスを維持するために、攻撃者が制御するユーザーまたはサービスアカウントに追加のロールまたはパーミッションを追加することができます。たとえば、十分なパーミッションを持つ攻撃者は、RoleBindingまたはClusterRoleBindingを作成して、KubernetesアカウントにRoleまたはClusterRoleをバインドすることができます。(引用: Kubernetes RBAC)(引用: Aquasec Kubernetes Attack 2023) 属性ベースのアクセス制御(ABAC)が使用されている場合、十分なパーミッションを持つ攻撃者は、Kubernetes ABACポリシーを変更して、ターゲットアカウントに追加のパーミッションを与えることができます。(引用: Kuberentes ABAC)\n \nこのアカウント修正は、[アカウントの作成](https://attack.mitre.org/techniques/T1136)またはその他の悪意のあるアカウント活動の直後に行われる可能性があります。攻撃者は、侵害した既存の[有効なアカウント](https://attack.mitre.org/techniques/T1078)を修正することもあります。\n\nGoogle Kubernetes Engine、Amazon Elastic Kubernetes Service、Azure Kubernetes Serviceのように、コンテナオーケストレーションシステムがクラウド環境にデプロイされている場合、クラウドベースのロールベースアクセス制御（RBAC）割り当てまたはABACポリシーが、ローカルの権限割り当ての代わりに、またはそれに加えて、しばしば使用できることに注意してください。(引用: Google Cloud Kubernetes IAM)(Citation: AWS EKS IAM Roles for Service Accounts)(Citation: Microsoft Azure Kubernetes Service Service Accounts) これらの場合、このテクニックは[追加のクラウドロール](https://attack.mitre.org/techniques/T1098/003)と組み合わせて使用することができます。"
                },
                {
                    "id": "T1098.004",
                    "name_eng": "SSH Authorized Keys",
                    "name_jp": "SSH認証キー",
                    "description_eng": "Adversaries may modify the SSH <code>authorized_keys</code> file to maintain persistence on a victim host. Linux distributions, macOS, and ESXi hypervisors commonly use key-based authentication to secure the authentication process of SSH sessions for remote management. The <code>authorized_keys</code> file in SSH specifies the SSH keys that can be used for logging into the user account for which the file is configured. This file is usually found in the user's home directory under <code>&lt;user-home&gt;/.ssh/authorized_keys</code> (or, on ESXi, `/etc/ssh/keys-<username>/authorized_keys`).(Citation: SSH Authorized Keys) Users may edit the system’s SSH config file to modify the directives `PubkeyAuthentication` and `RSAAuthentication` to the value `yes` to ensure public key and RSA authentication are enabled, as well as modify the directive `PermitRootLogin` to the value `yes` to enable root authentication via SSH.(Citation: Broadcom ESXi SSH) The SSH config file is usually located under <code>/etc/ssh/sshd_config</code>.\n\nAdversaries may modify SSH <code>authorized_keys</code> files directly with scripts or shell commands to add their own adversary-supplied public keys. In cloud environments, adversaries may be able to modify the SSH authorized_keys file of a particular virtual machine via the command line interface or rest API. For example, by using the Google Cloud CLI’s “add-metadata” command an adversary may add SSH keys to a user account.(Citation: Google Cloud Add Metadata)(Citation: Google Cloud Privilege Escalation) Similarly, in Azure, an adversary may update the authorized_keys file of a virtual machine via a PATCH request to the API.(Citation: Azure Update Virtual Machines) This ensures that an adversary possessing the corresponding private key may log in as an existing user via SSH.(Citation: Venafi SSH Key Abuse)(Citation: Cybereason Linux Exim Worm) It may also lead to privilege escalation where the virtual machine or instance has distinct permissions from the requesting user.\n\nWhere authorized_keys files are modified via cloud APIs or command line interfaces, an adversary may achieve privilege escalation on the target virtual machine if they add a key to a higher-privileged user. \n\nSSH keys can also be added to accounts on network devices, such as with the `ip ssh pubkey-chain` [Network Device CLI](https://attack.mitre.org/techniques/T1059/008) command.(Citation: cisco_ip_ssh_pubkey_ch_cmd)",
                    "description_jp": "攻撃者は SSH <code>authorized_keys</code> ファイルを変更し、被害者ホスト上で永続性を維持する可能性があります。Linuxディストリビューション、macOS、およびESXiハイパーバイザーは、リモート管理のためのSSHセッションの認証プロセスを保護するために、一般的に鍵ベースの認証を使用します。SSHの<code>authorized_keys</code>ファイルは、そのファイルが設定されているユーザーアカウントへのログインに使用できるSSHキーを指定します。このファイルは通常、<code>&lt;user-home&gt;/.ssh/authorized_keys</code>（または、ESXi では `/etc/ssh/keys-&lt;username&gt;/authorized_keys`）の下のユーザーのホームディレクトリにあります。(引用: SSH Authorized Keys) ユーザーはシステムの SSH 設定ファイルを編集して、ディレクティブ `PubkeyAuthentication` と `RSAAuthentication` を値 `yes` に変更し、公開鍵と RSA 認証が有効になっていることを確認します。また、ディレクティブ `PermitRootLogin` を値 `yes` に変更し、SSH による root 認証を有効にします。(Citation: Broadcom ESXi SSH) SSH 設定ファイルは通常 <code>/etc/ssh/sshd_config</code> の下にあります。\n\n敵はスクリプトやシェル・コマンドを使ってSSHの<code>authorized_keys</code>ファイルを直接修正し、敵が提供する公開鍵を追加することができる。クラウド環境では、敵はコマンドラインインターフェースやレストAPIを使って、特定の仮想マシンのSSH authorized_keysファイルを変更できるかもしれません。例えば、Google Cloud CLIの \"add-metadata \"コマンドを使用することで、敵対者はユーザーアカウントにSSH鍵を追加することができる（引用：Google Cloud Add Metadata）（引用：Google Cloud Privilege Escalation）同様に、Azureでは、敵対者はAPIへのPATCHリクエストによって仮想マシンのauthorized_keysファイルを更新することができる。(引用：Azure Update Virtual Machines) これにより、対応する秘密鍵を所有する敵対者は、SSH経由で既存のユーザーとしてログインすることができます。(引用：Venafi SSH Key Abuse) (引用：Cybereason Linux Exim Worm) また、仮想マシンまたはインスタンスが要求ユーザーとは異なる権限を持っている場合、権限の昇格につながる可能性があります。\n\nauthorized_keysファイルがクラウドAPIやコマンドラインインターフェースを介して変更される場合、敵対者は、より高い特権ユーザーにキーを追加すると、ターゲットの仮想マシン上で特権昇格を達成する可能性があります。\n\nSSH 鍵は、`ip ssh pubkey-chain` [ネットワークデバイスCLI](https://attack.mitre.org/techniques/T1059/008)コマンドなどで、ネットワークデバイス上のアカウントに追加することもできる。(引用: cisco_ip_ssh_pubkey_ch_cmd)"
                },
                {
                    "id": "T1098.007",
                    "name_eng": "Additional Local or Domain Groups",
                    "name_jp": "追加のローカルまたはドメイングループ",
                    "description_eng": "An adversary may add additional local or domain groups to an adversary-controlled account to maintain persistent access to a system or domain.\n\nOn Windows, accounts may use the `net localgroup` and `net group` commands to add existing users to local and domain groups.(Citation: Microsoft Net Localgroup)(Citation: Microsoft Net Group) On Linux, adversaries may use the `usermod` command for the same purpose.(Citation: Linux Usermod)\n\nFor example, accounts may be added to the local administrators group on Windows devices to maintain elevated privileges. They may also be added to the Remote Desktop Users group, which allows them to leverage [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) to log into the endpoints in the future.(Citation: Microsoft RDP Logons) On Linux, accounts may be added to the sudoers group, allowing them to persistently leverage [Sudo and Sudo Caching](https://attack.mitre.org/techniques/T1548/003) for elevated privileges. \n\nIn Windows environments, machine accounts may also be added to domain groups. This allows the local SYSTEM account to gain privileges on the domain.(Citation: RootDSE AD Detection 2022)",
                    "description_jp": "敵対者は、システムやドメインへの永続的なアクセスを維持するために、敵対者が管理するアカウントにローカルグループやドメイングループを追加するかもしれない。\n\nWindowsでは、アカウントは`net localgroup`コマンドと`net group`コマンドを使って、既存のユーザーをローカルグループやドメイングループに追加することができる(引用: Microsoft Net Localgroup)(引用: Microsoft Net Group) Linuxでは、敵対者は同じ目的で`usermod`コマンドを使うことができる(引用: Linux Usermod)\n\n例えば、Windowsデバイスのローカル管理者グループにアカウントを追加して、昇格した特権を維持することができる。また、将来エンドポイントにログインするために[リモートデスクトッププロトコル](https://attack.mitre.org/techniques/T1021/001)を利用できるように、Remote Desktop Usersグループに追加することもできる。(引用: Microsoft RDP Logons) Linuxでは、昇格した特権のために[SudoおよびSudoキャッシング](https://attack.mitre.org/techniques/T1548/003)を持続的に利用できるように、sudoersグループにアカウントを追加することができる。\n\nWindows環境では、マシンアカウントをドメイングループに追加することもできる。これにより、ローカルのSYSTEMアカウントがドメイン上で特権を得ることができる(引用：RootDSE AD Detection 2022)。"
                }
            ]
        },
        {
            "id": "T1574",
            "name_eng": "Hijack Execution Flow",
            "name_jp": "実行フローのハイジャック",
            "description_eng": "Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution.\n\nThere are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.",
            "description_jp": "攻撃者は、オペレーティングシステムがプログラムを実行する方法をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。実行フローのハイジャックは、ハイジャックされた実行が時間とともに再発する可能性があるため、永続化を目的とすることができます。攻撃者はまた、アプリケーション制御やその他の実行制限など、権限を昇格させたり防御を回避したりするためにこれらのメカニズムを使用する可能性があります。\n\n攻撃者が実行フローをハイジャックする方法は多数あり、オペレーティングシステムが実行するプログラムを特定する方法を操作することなどが含まれます。プログラムが使用するライブラリをオペレーティングシステムが特定する方法も傍受される可能性があります。ファイルディレクトリや、Windowsの場合はレジストリなど、オペレーティングシステムがプログラム/リソースを探す場所も、悪意のあるペイロードを含むように汚染される可能性があります。",
            "subtechniques": [
                {
                    "id": "T1574.010",
                    "name_eng": "Services File Permissions Weakness",
                    "name_jp": "サービスファイルパーミッションの脆弱性",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the binaries used by services. Adversaries may use flaws in the permissions of Windows services to replace the binary that is executed upon service start. These service processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.\n\nAdversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.",
                    "description_jp": "攻撃者は、サービスによって使用されるバイナリをハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。攻撃者は、Windowsサービスのアクセス許可の欠陥を使用して、サービス開始時に実行されるバイナリを置き換える可能性があります。これらのサービスプロセスは、その機能の一部として、または他のアクションを実行するために、特定のバイナリを自動的に実行する場合があります。ターゲットバイナリを含むファイルシステムディレクトリのアクセス許可、またはバイナリ自体のアクセス許可が不適切に設定されている場合、ターゲットバイナリはユーザーレベルのアクセス許可を使用して別のバイナリで上書きされ、元のプロセスによって実行される可能性があります。元のプロセスとスレッドがより高いアクセス許可レベルで実行されている場合、置き換えられたバイナリもSYSTEMを含むより高いレベルのアクセス許可で実行されます。\n\n攻撃者は、より高いアクセス許可レベルでコードを実行する手段として、正当なバイナリを悪意のあるバイナリに置き換えるためにこのテクニックを使用する可能性があります。実行中のプロセスが特定の時間に実行されるように設定されている場合、または特定のイベント（システムの起動など）中に実行されるように設定されている場合、このテクニックは永続化にも使用できます。"
                },
                {
                    "id": "T1574.013",
                    "name_eng": "KernelCallbackTable",
                    "name_jp": "KernelCallbackTable",
                    "description_eng": "Adversaries may abuse the <code>KernelCallbackTable</code> of a process to hijack its execution flow in order to run their own payloads.(Citation: Lazarus APT January 2022)(Citation: FinFisher exposed ) The <code>KernelCallbackTable</code> can be found in the Process Environment Block (PEB) and is initialized to an array of graphic functions available to a GUI process once <code>user32.dll</code> is loaded.(Citation: Windows Process Injection KernelCallbackTable)\n\nAn adversary may hijack the execution flow of a process using the <code>KernelCallbackTable</code> by replacing an original callback function with a malicious payload. Modifying callback functions can be achieved in various ways involving related behaviors such as [Reflective Code Loading](https://attack.mitre.org/techniques/T1620) or [Process Injection](https://attack.mitre.org/techniques/T1055) into another process.\n\nA pointer to the memory address of the <code>KernelCallbackTable</code> can be obtained by locating the PEB (ex: via a call to the <code>NtQueryInformationProcess()</code> [Native API](https://attack.mitre.org/techniques/T1106) function).(Citation: NtQueryInformationProcess) Once the pointer is located, the <code>KernelCallbackTable</code> can be duplicated, and a function in the table (e.g., <code>fnCOPYDATA</code>) set to the address of a malicious payload (ex: via <code>WriteProcessMemory()</code>). The PEB is then updated with the new address of the table. Once the tampered function is invoked, the malicious payload will be triggered.(Citation: Lazarus APT January 2022)\n\nThe tampered function is typically invoked using a Windows message. After the process is hijacked and malicious code is executed, the <code>KernelCallbackTable</code> may also be restored to its original state by the rest of the malicious payload.(Citation: Lazarus APT January 2022) Use of the <code>KernelCallbackTable</code> to hijack execution flow may evade detection from security products since the execution can be masked under a legitimate process.",
                    "description_jp": "攻撃者は、プロセスの<code>KernelCallbackTable</code>を悪用してその実行フローをハイジャックし、独自のペイロードを実行する可能性があります。(引用: Lazarus APT January 2022)(引用: FinFisher exposed ) <code>KernelCallbackTable</code>はプロセス環境ブロック（PEB）にあり、<code>user32.dll</code>がロードされるとGUIプロセスで利用可能なグラフィック関数の配列に初期化されます。(引用: Windows Process Injection KernelCallbackTable)\n\n攻撃者は、元のコールバック関数を悪意のあるペイロードに置き換えることにより、<code>KernelCallbackTable</code>を使用してプロセスの実行フローをハイジャックする可能性があります。コールバック関数の変更は、別のプロセスへの[リフレクティブコードローディング](https://attack.mitre.org/techniques/T1620)や[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)など、関連する動作を含むさまざまな方法で実現できます。\n\n<code>KernelCallbackTable</code>のメモリアドレスへのポインタは、PEBを特定することによって取得できます（例：<code>NtQueryInformationProcess()</code> [ネイティブAPI](https://attack.mitre.org/techniques/T1106)関数の呼び出しを介して）。(引用: NtQueryInformationProcess) ポインタが見つかると、<code>KernelCallbackTable</code>を複製し、テーブル内の関数（例：<code>fnCOPYDATA</code>）を悪意のあるペイロードのアドレスに設定できます（例：<code>WriteProcessMemory()</code>を介して）。その後、PEBはテーブルの新しいアドレスで更新されます。改ざんされた関数が呼び出されると、悪意のあるペイロードがトリガーされます。(引用: Lazarus APT January 2022)\n\n改ざんされた関数は通常、Windowsメッセージを使用して呼び出されます。プロセスがハイジャックされ、悪意のあるコードが実行された後、<code>KernelCallbackTable</code>は悪意のあるペイロードの残りの部分によって元の状態に復元される場合もあります。(引用: Lazarus APT January 2022) 実行が正当なプロセスの下でマスクされるため、<code>KernelCallbackTable</code>を使用して実行フローをハイジャックすると、セキュリティ製品による検出を回避できる場合があります。"
                },
                {
                    "id": "T1574.007",
                    "name_eng": "Path Interception by PATH Environment Variable",
                    "name_jp": "PATH環境変数によるパスインターセプション",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking environment variables used to load libraries. The PATH environment variable contains a list of directories (User and System) that the OS searches sequentially through in search of the binary that was called from a script or the command line. \n\nAdversaries can place a malicious program in an earlier entry in the list of directories stored in the PATH environment variable, resulting in the operating system executing the malicious binary rather than the legitimate binary when it searches sequentially through that PATH listing.\n\nFor example, on Windows if an adversary places a malicious program named \"net.exe\" in `C:\\example path`, which by default precedes `C:\\Windows\\system32\\net.exe` in the PATH environment variable, when \"net\" is executed from the command-line the `C:\\example path` will be called instead of the system's legitimate executable at `C:\\Windows\\system32\\net.exe`. Some methods of executing a program rely on the PATH environment variable to determine the locations that are searched when the path for the program is not given, such as executing programs from a [Command and Scripting Interpreter](https://attack.mitre.org/techniques/T1059).(Citation: ExpressVPN PATH env Windows 2021)\n\nAdversaries may also directly modify the $PATH variable specifying the directories to be searched.  An adversary can modify the `$PATH` variable to point to a directory they have write access. When a program using the $PATH variable is called, the OS searches the specified directory and executes the malicious binary. On macOS, this can also be performed through modifying the $HOME variable. These variables can be modified using the command-line, launchctl, [Unix Shell Configuration Modification](https://attack.mitre.org/techniques/T1546/004), or modifying the `/etc/paths.d` folder contents.(Citation: uptycs Fake POC linux malware 2023)(Citation: nixCraft macOS PATH variables)(Citation: Elastic Rules macOS launchctl 2022)",
                    "description_jp": "攻撃者は、ライブラリのロードに使用される環境変数をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。PATH環境変数には、スクリプトまたはコマンドラインから呼び出されたバイナリを検索するためにOSが順次検索するディレクトリ（ユーザーおよびシステム）のリストが含まれています。\n\n攻撃者は、PATH環境変数に格納されているディレクトリのリストの前のエントリに悪意のあるプログラムを配置することで、OSがそのPATHリストを順次検索するときに、正当なバイナリではなく悪意のあるバイナリを実行するように仕向けることができます。\n\n例えば、Windowsで攻撃者が「net.exe」という名前の悪意のあるプログラムを`C:\\example path`に配置し、これがデフォルトでPATH環境変数の`C:\\Windows\\system32\\net.exe`より前にある場合、コマンドラインから「net」が実行されると、システムの正当な実行可能ファイルである`C:\\Windows\\system32\\net.exe`の代わりに`C:\\example path`が呼び出されます。プログラムを実行する一部のメソッドは、プログラムのパスが指定されていない場合に検索される場所を決定するためにPATH環境変数に依存します。例えば、[コマンドおよびスクリプトインタープリター](https://attack.mitre.org/techniques/T1059)からプログラムを実行する場合などです。(引用: ExpressVPN PATH env Windows 2021)\n\n攻撃者はまた、検索対象のディレクトリを指定する$PATH変数を直接変更することもあります。攻撃者は、書き込みアクセス権を持つディレクトリを指すように`$PATH`変数を変更できます。$PATH変数を使用するプログラムが呼び出されると、OSは指定されたディレクトリを検索し、悪意のあるバイナリを実行します。macOSでは、これは$HOME変数を変更することによっても実行できます。これらの変数は、コマンドライン、launchctl、[Unixシェル構成の変更](https://attack.mitre.org/techniques/T1546/004)、または`/etc/paths.d`フォルダの内容を変更することによって変更できます。(引用: uptycs Fake POC linux malware 2023)(引用: nixCraft macOS PATH variables)(引用: Elastic Rules macOS launchctl 2022)"
                },
                {
                    "id": "T1574.005",
                    "name_eng": "Executable Installer File Permissions Weakness",
                    "name_jp": "実行可能インストーラーファイルのアクセス許可の脆弱性",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the binaries used by an installer. These processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself, are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.\n\nAnother variation of this technique can be performed by taking advantage of a weakness that is common in executable, self-extracting installers. During the installation process, it is common for installers to use a subdirectory within the <code>%TEMP%</code> directory to unpack binaries such as DLLs, EXEs, or other payloads. When installers create subdirectories and files they often do not set appropriate permissions to restrict write access, which allows for execution of untrusted code placed in the subdirectories or overwriting of binaries used in the installation process. This behavior is related to and may take advantage of [DLL](https://attack.mitre.org/techniques/T1574/001) search order hijacking.\n\nAdversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. Some installers may also require elevated privileges that will result in privilege escalation when executing adversary controlled code. This behavior is related to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002). Several examples of this weakness in existing common installers have been reported to software vendors.(Citation: mozilla_sec_adv_2012)  (Citation: Executable Installers are Vulnerable) If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.",
                    "description_jp": "攻撃者は、インストーラーによって使用されるバイナリをハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。これらのプロセスは、その機能の一部として、または他のアクションを実行するために、特定のバイナリを自動的に実行する場合があります。ターゲットバイナリを含むファイルシステムディレクトリのアクセス許可、またはバイナリ自体のアクセス許可が不適切に設定されている場合、ターゲットバイナリはユーザーレベルのアクセス許可を使用して別のバイナリで上書きされ、元のプロセスによって実行される可能性があります。元のプロセスとスレッドがより高いアクセス許可レベルで実行されている場合、置き換えられたバイナリもSYSTEMを含むより高いレベルのアクセス許可で実行されます。\n\nこのテクニックの別のバリエーションは、実行可能ファイル形式の自己解凍インストーラーに共通する脆弱性を利用することによって実行できます。インストールプロセス中、インストーラーがDLL、EXE、またはその他のペイロードなどのバイナリを展開するために<code>%TEMP%</code>ディレクトリ内のサブディレクトリを使用するのが一般的です。インストーラーがサブディレクトリとファイルを作成するとき、書き込みアクセスを制限するための適切なアクセス許可をしばしば設定しないため、サブディレクトリに配置された信頼できないコードの実行や、インストールプロセスで使用されるバイナリの上書きが可能になります。この動作は[DLL](https://attack.mitre.org/techniques/T1574/001)検索順序ハイジャックに関連しており、これを利用する可能性があります。\n\n攻撃者はこのテクニックを使用して、より高い権限レベルでコードを実行する手段として、正当なバイナリを悪意のあるバイナリに置き換える可能性があります。一部のインストーラーは、攻撃者が制御するコードを実行する際に権限昇格をもたらす昇格された権限を必要とする場合もあります。この動作は[ユーザーアカウント制御のバイパス](https://attack.mitre.org/techniques/T1548/002)に関連しています。既存の一般的なインストーラーにおけるこの脆弱性のいくつかの例がソフトウェアベンダーに報告されています。(引用: mozilla_sec_adv_2012) (引用: Executable Installers are Vulnerable) 実行中のプロセスが特定の時間に実行されるように設定されている場合、または特定のイベント（システムの起動など）中に実行されるように設定されている場合、このテクニックは永続化にも使用できます。"
                },
                {
                    "id": "T1574.009",
                    "name_eng": "Path Interception by Unquoted Path",
                    "name_jp": "引用符なしパスによるパスインターセプション",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking vulnerable file path references. Adversaries can take advantage of paths that lack surrounding quotations by placing an executable in a higher level directory within the path, so that Windows will choose the adversary's executable to launch.\n\nService paths (Citation: Microsoft CurrentControlSet Services) and shortcut paths may also be vulnerable to path interception if the path has one or more spaces and is not surrounded by quotation marks (e.g., <code>C:\\unsafe path with space\\program.exe</code> vs. <code>\"C:\\safe path with space\\program.exe\"</code>). (Citation: Help eliminate unquoted path) (stored in Windows Registry keys) An adversary can place an executable in a higher level directory of the path, and Windows will resolve that executable instead of the intended executable. For example, if the path in a shortcut is <code>C:\\program files\\myapp.exe</code>, an adversary may create a program at <code>C:\\program.exe</code> that will be run instead of the intended program. (Citation: Windows Unquoted Services) (Citation: Windows Privilege Escalation Guide)\n\nThis technique can be used for persistence if executables are called on a regular basis, as well as privilege escalation if intercepted executables are started by a higher privileged process.",
                    "description_jp": "攻撃者は、脆弱なファイルパス参照をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。攻撃者は、パス内の上位ディレクトリに実行可能ファイルを配置することにより、周囲に引用符がないパスを利用して、Windowsが攻撃者の実行可能ファイルを選択して起動するように仕向けることができます。\n\nサービスパス（引用: Microsoft CurrentControlSet Services）およびショートカットパスも、パスに1つ以上のスペースがあり、引用符で囲まれていない場合（例：<code>C:\\unsafe path with space\\program.exe</code> 対 <code>\"C:\\safe path with space\\program.exe\"</code>）、パスインターセプションに対して脆弱である可能性があります。(引用: Help eliminate unquoted path)（Windowsレジストリキーに格納）攻撃者はパスの上位ディレクトリに実行可能ファイルを配置でき、Windowsは意図した実行可能ファイルの代わりにその実行可能ファイルを解決します。例えば、ショートカットのパスが<code>C:\\program files\\myapp.exe</code>である場合、攻撃者は<code>C:\\program.exe</code>にプログラムを作成し、意図したプログラムの代わりに実行させることができます。(引用: Windows Unquoted Services) (引用: Windows Privilege Escalation Guide)\n\nこのテクニックは、実行可能ファイルが定期的に呼び出される場合に永続性のために使用でき、また、傍受された実行可能ファイルがより高い権限を持つプロセスによって開始される場合には権限昇格のために使用できます。"
                },
                {
                    "id": "T1574.004",
                    "name_eng": "Dylib Hijacking",
                    "name_jp": "Dylibハイジャック",
                    "description_eng": "Adversaries may execute their own payloads by placing a malicious dynamic library (dylib) with an expected name in a path a victim application searches at runtime. The dynamic loader will try to find the dylibs based on the sequential order of the search paths. Paths to dylibs may be prefixed with <code>@rpath</code>, which allows developers to use relative paths to specify an array of search paths used at runtime based on the location of the executable.  Additionally, if weak linking is used, such as the <code>LC_LOAD_WEAK_DYLIB</code> function, an application will still execute even if an expected dylib is not present. Weak linking enables developers to run an application on multiple macOS versions as new APIs are added.\n\nAdversaries may gain execution by inserting malicious dylibs with the name of the missing dylib in the identified path.(Citation: Wardle Dylib Hijack Vulnerable Apps)(Citation: Wardle Dylib Hijacking OSX 2015)(Citation: Github EmpireProject HijackScanner)(Citation: Github EmpireProject CreateHijacker Dylib) Dylibs are loaded into an application's address space allowing the malicious dylib to inherit the application's privilege level and resources. Based on the application, this could result in privilege escalation and uninhibited network access. This method may also evade detection from security products since the execution is masked under a legitimate process.(Citation: Writing Bad Malware for OSX)(Citation: wardle artofmalware volume1)(Citation: MalwareUnicorn macOS Dylib Injection MachO)",
                    "description_jp": "攻撃者は、被害者のアプリケーションが実行時に検索するパスに、予想される名前の悪意のあるダイナミック・ライブラリ（dylib）を配置することで、独自のペイロードを実行する可能性があります。ダイナミック・ローダーは、検索パスの順序に基づいて、dylib を見つけようとします。ディリブへのパスの先頭には <code>@rpath</code> を付けることができ、開発者は相対パスを使用して実行可能ファイルの場所に基づいて実行時に使用される検索パスの配列を指定することができます。 さらに、<code>LC_LOAD_WEAK_DYLIB</code> 関数のような弱いリンクが使用されている場合、期待される dylib が存在しなくてもアプリケーションは実行されます。弱いリンクによって、開発者は新しいAPIが追加されたときに、複数のmacOSバージョンでアプリケーションを実行することができます。\n\n攻撃者は、特定されたパスに欠落している dylib の名前を持つ悪意のある dylib を挿入することで、実行を獲得する可能性があります（引用：Wardle Dylib Hijack Vulnerable Apps）（引用：Wardle Dylib Hijacking OSX 2015）（引用：Github EmpireProject HijackScanner）（引用：Github EmpireProject CreateHijacker Dylib） dylib はアプリケーションのアドレス空間にロードされ、悪意のある dylib がアプリケーションの特権レベルとリソースを継承できるようになります。アプリケーションによっては、特権の昇格や無制限のネットワークアクセスを引き起こす可能性があります。この方法は、実行が正当なプロセスの下でマスクされるため、セキュリティ製品からの検出を回避することもできます。(引用：Writing Bad Malware for OSX)(Citation: wardle artofmalware volume1)(Citation: MalwareUnicorn macOS Dylib Injection MachO)"
                },
                {
                    "id": "T1574.006",
                    "name_eng": "Dynamic Linker Hijacking",
                    "name_jp": "ダイナミックリンカーハイジャック",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from various environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS.(Citation: TheEvilBit DYLD_INSERT_LIBRARIES)(Citation: Timac DYLD_INSERT_LIBRARIES)(Citation: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) Each platform's linker uses an extensive list of environment variables at different points in execution. These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions in the original library.(Citation: Baeldung LD_PRELOAD)\n\nHijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. On Linux, adversaries may set <code>LD_PRELOAD</code> to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. For example, adversaries have used `LD_PRELOAD` to inject a malicious library into every descendant process of the `sshd` daemon, resulting in execution under a legitimate process. When the executing sub-process calls the `execve` function, for example, the malicious library’s `execve` function is executed rather than the system function `execve` contained in the system library on disk. This allows adversaries to [Hide Artifacts](https://attack.mitre.org/techniques/T1564) from detection, as hooking system functions such as `execve` and `readdir` enables malware to scrub its own artifacts from the results of commands such as `ls`, `ldd`, `iptables`, and `dmesg`.(Citation: ESET Ebury Oct 2017)(Citation: Intezer Symbiote 2022)(Citation: Elastic Security Labs Pumakit 2024)\n\nHijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges.",
                    "description_jp": "攻撃者は、ダイナミックリンカーが共有ライブラリをロードするために使用する環境変数をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。プログラムの実行準備段階で、ダイナミックリンカーは、Linux の <code>LD_PRELOAD</code> や macOS の <code>DYLD_INSERT_LIBRARIES</code> など、さまざまな環境変数やファイルから共有ライブラリの指定された絶対パスをロードします。(引用: TheEvilBit DYLD_INSERT_LIBRARIES)(引用: Timac DYLD_INSERT_LIBRARIES)(引用: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) 環境変数で指定されたライブラリは、同じ関数名のシステムライブラリよりも優先して最初にロードされます。(引用: Man LD.SO)(引用: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) 各プラットフォームのリンカーは、実行のさまざまな時点で環境変数の広範なリストを使用します。これらの変数は、開発者が再コンパイルすることなくバイナリをデバッグしたり、マップされたシンボルの競合を解除したり、元のライブラリにカスタム関数を実装したりするために、しばしば使用される(引用: Baeldung LD_PRELOAD)\n\nダイナミック・リンカー変数をハイジャックすると、被害者プロセスのメモリ、システム/ネットワーク・リソースへのアクセスが許可され、特権が昇格する可能性があります。Linux では、敵対者は <code>LD_PRELOAD</code> を設定して、被害者プログラムによって要求された正当なライブラリの名前と一致する悪意のあるライブラリを指すようにし、被害者プログラムの実行時にオペレーティングシステムに敵対者の悪意のあるコードをロードさせる可能性があります。例えば、敵は <code>LD_PRELOAD</code> を使って <code>sshd</code> デーモンのすべての子孫プロセスに悪意のあるライブラリを注入し、結果として正規のプロセスで実行させる。実行中のサブプロセスが <code>execve</code> 関数を呼び出すと、ディスク上のシステムライブラリに含まれるシステム関数 <code>execve</code> ではなく、悪意のあるライブラリの <code>execve</code> 関数が実行される。<code>execve</code>や<code>readdir</code>などのシステム関数をフックすることで、マルウェアが<code>ls</code>、<code>ldd</code>、<code>iptables</code>、<code>dmesg</code>などのコマンドの結果から自身のアーティファクトをスクラブすることが可能になるため、敵対者は検出から[アーティファクトを隠す](https://attack.mitre.org/techniques/T1564)ことができる(引用：ESET Ebury Oct 2017)(引用：Intezer Symbiote 2022)(引用：Elastic Security Labs Pumakit 2024)\n\n動的リンカー変数をハイジャックすることで、被害者プロセスのメモリ、システム/ネットワークリソースへのアクセスが許可され、特権が昇格する可能性があります。"
                },
                {
                    "id": "T1574.014",
                    "name_eng": "AppDomainManager",
                    "name_jp": "AppDomainManager",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking how the .NET `AppDomainManager` loads assemblies. The .NET framework uses the `AppDomainManager` class to create and manage one or more isolated runtime environments (called application domains) inside a process to host the execution of .NET applications. Assemblies (`.exe` or `.dll` binaries compiled to run as .NET code) may be loaded into an application domain as executable code.(Citation: Microsoft App Domains) \n\nKnown as \"AppDomainManager injection,\" adversaries may execute arbitrary code by hijacking how .NET applications load assemblies. For example, malware may create a custom application domain inside a target process to load and execute an arbitrary assembly. Alternatively, configuration files (`.config`) or process environment variables that define .NET runtime settings may be tampered with to instruct otherwise benign .NET applications to load a malicious assembly (identified by name) into the target process.(Citation: PenTestLabs AppDomainManagerInject)(Citation: PwC Yellow Liderc)(Citation: Rapid7 AppDomain Manager Injection)",
                    "description_jp": "攻撃者は、.NET の `AppDomainManager` がアセンブリをロードする方法をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。.NETフレームワークは、`AppDomainManager`クラスを使用して、.NETアプリケーションの実行をホストするプロセス内に1つ以上の隔離された実行環境（アプリケーションドメインと呼ばれる）を作成し、管理します。アセンブリ（.NETコードとして実行するためにコンパイルされた`.exe`または`.dll`バイナリ）は、実行可能コードとしてアプリケーションドメインにロードすることができる（引用：Microsoft App Domains）。\n\n「AppDomainManagerインジェクション」として知られるこの攻撃は、.NETアプリケーションがアセンブリをロードする方法をハイジャックすることで、任意のコードを実行する可能性があります。例えば、マルウェアはターゲットプロセス内にカスタムアプリケーションドメインを作成し、任意のアセンブリをロードして実行します。あるいは、.NET ランタイム設定を定義する設定ファイル (`.config`) やプロセス環境変数が改ざんされ、悪意のあるアセンブリ (名前で識別される) をターゲットプロセスにロードするよう、良性の .NET アプリケーションに指示することもあります。(引用: PenTestLabs AppDomainManagerInject)(引用: PwC Yellow Liderc)(引用: Rapid7 AppDomain Manager Injection)"
                },
                {
                    "id": "T1574.001",
                    "name_eng": "DLL",
                    "name_jp": "DLL",
                    "description_eng": "Adversaries may abuse dynamic-link library files (DLLs) in order to achieve persistence, escalate privileges, and evade defenses. DLLs are libraries that contain code and data that can be simultaneously utilized by multiple programs. While DLLs are not malicious by nature, they can be abused through mechanisms such as side-loading, hijacking search order, and phantom DLL hijacking.(Citation: unit 42)\n\nSpecific ways DLLs are abused by adversaries include:\n\n### DLL Sideloading\nAdversaries may execute their own malicious payloads by side-loading DLLs. Side-loading involves hijacking which DLL a program loads by planting and then invoking a legitimate application that executes their payload(s).\n\nSide-loading positions both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.\n\nAdversaries may also side-load other packages, such as BPLs (Borland Package Library).(Citation: kroll bpl)\n\n### DLL Search Order Hijacking\nAdversaries may execute their own malicious payloads by hijacking the search order that Windows uses to load DLLs. This search order is a sequence of special and standard search locations that a program checks when loading a DLL. An adversary can plant a trojan DLL in a directory that will be prioritized by the DLL search order over the location of a legitimate library. This will cause Windows to load the malicious DLL when it is called for by the victim program.(Citation: unit 42)\n\n### DLL Redirection\nAdversaries may directly modify the search order via DLL redirection, which after being enabled (in the Registry or via the creation of a redirection file) may cause a program to load a DLL from a different location.(Citation: Microsoft redirection)(Citation: Microsoft - manifests/assembly)\n\n### Phantom DLL Hijacking\nAdversaries may leverage phantom DLL hijacking by targeting references to non-existent DLL files. They may be able to load their own malicious DLL by planting it with the correct name in the location of the missing module.(Citation: Hexacorn DLL Hijacking)(Citation: Hijack DLLs CrowdStrike)\n\n### DLL Substitution\nAdversaries may target existing, valid DLL files and substitute them with their own malicious DLLs, planting them with the same name and in the same location as the valid DLL file.(Citation: Wietze Beukema DLL Hijacking)\n\nPrograms that fall victim to DLL hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace, evading defenses.\n\nRemote DLL hijacking can occur when a program sets its current directory to a remote location, such as a Web share, before loading a DLL.(Citation: dll pre load owasp)(Citation: microsoft remote preloading)\n\nIf a valid DLL is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation.",
                    "description_jp": "攻撃者は、永続性を実現し、特権を昇格させ、防御を回避するために、ダイナミック・リンク・ライブラリ・ファイル（DLL）を悪用する可能性がある。DLLは、複数のプログラムで同時に利用できるコードとデータを含むライブラリである。DLLは本来悪意のあるものではないが、サイドローディング、検索順序の乗っ取り、ファントムDLLハイジャックなどのメカニズムによって悪用される可能性がある(引用：unit 42)。\n\nDLLが敵対者によって悪用される具体的な方法には、次のようなものがある：\n\n### DLL サイドローディング\nDLLのサイドローディング 敵は、DLLをサイドローディングすることで、独自の悪意のあるペイロードを実行する可能性があります。サイドローディングは、プログラムがロードする DLL を植え付け、ペイロードを実行する正規のアプリケーションを起動することで、DLL を乗っ取ることを意味します。\n\nサイドローディングは、被害者アプリケーションと悪意のあるペイロードの両方を、互いに隣り合わせに配置します。攻撃者はサイドローディングを、正規の、信頼された、潜在的に昇格されたシステムまたはソフトウェアプロセスの下で実行するアクションを隠す手段として使用している可能性が高いです。ペイロードのサイドローディングに使用される良性の実行ファイルは、配信中や実行中にフラグが立てられない可能性があります。敵対的なペイロードは、信頼されたプロセスのメモリにロードされるまで、暗号化/パックされるか、または他の方法で難読化される可能性もあります。\n\n攻撃者は、BPL (Borland Package Library) などの他のパッケージをサイドロードすることもあります(引用: kroll bpl)。\n\n### DLL 検索順序のハイジャック\n攻撃者は、Windows が DLL をロードする際に使用する検索順序をハイジャックすることで、独自の悪質なペイロードを実行する可能性があります。この検索順序は、DLL をロードする際にプログラムがチェックする、特別な検索場所と標準的な検索場所のシーケンスです。敵対者は、DLLの検索順序によって正当なライブラリの場所よりも優先されるディレクトリに、トロイの木馬のDLLを仕込むことができる。これにより、被害者プログラムによって悪意のあるDLLが呼び出されると、Windowsはそれをロードするようになる(引用：unit 42)。\n\n### DLL リダイレクト\nDLLリダイレクトは、有効化された後（レジストリまたはリダイレクトファイルの作成により）、プログラムに別の場所からDLLをロードさせる可能性があります。 引用：Microsoft リダイレクト）（引用：Microsoft - manifests/assembly\n\n### ファントム DLL ハイジャック\n攻撃者は、存在しない DLL ファイルへの参照を標的とすることで、ファントム DLL ハイジャックを利用する可能性があります。彼らは、存在しないモジュールの場所に正しい名前で悪意のある DLL を仕込むことで、独自の悪意のある DLL をロードできる可能性があります(引用: Hexacorn DLL ハイジャック)(引用: Hijack DLLs CrowdStrike)\n\n### DLL の置換\n攻撃者は、既存の有効な DLL ファイルを標的にし、有効な DLL ファイルと同じ名前と同じ場所に、自分自身の悪意のある DLL を植え付けることで、DLL を置き換える可能性があります(引用: Wietze Beukema DLL ハイジャック)。\n\nDLLハイジャックの被害に遭ったプログラムは、悪意のあるDLLが正規のDLLも読み込むように設定されているため、防御を回避して正常に動作しているように見えることがある。\n\nリモートDLLハイジャックは、DLLをロードする前にプログラムがカレントディレクトリをWeb共有などのリモートの場所に設定することで発生する可能性がある(引用：DLL pre load owasp)(引用：Microsoft remote preloading)\n\n有効なDLLがより高い特権レベルで実行されるように設定されている場合、ロードされる敵に制御されたDLLもより高いレベルで実行される。この場合、このテクニックは特権の昇格に使われる可能性がある。"
                },
                {
                    "id": "T1574.008",
                    "name_eng": "Path Interception by Search Order Hijacking",
                    "name_jp": "検索順ハイジャックによるパスインターセプション",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the search order used to load other programs. Because some programs do not call other programs using the full path, adversaries may place their own file in the directory where the calling program is located, causing the operating system to launch their malicious software at the request of the calling program.\n\nSearch order hijacking occurs when an adversary abuses the order in which Windows searches for programs that are not given a path. Unlike [DLL](https://attack.mitre.org/techniques/T1574/001) search order hijacking, the search order differs depending on the method that is used to execute the program. (Citation: Microsoft CreateProcess) (Citation: Windows NT Command Shell) (Citation: Microsoft WinExec) However, it is common for Windows to search in the directory of the initiating program before searching through the Windows system directory. An adversary who finds a program vulnerable to search order hijacking (i.e., a program that does not specify the path to an executable) may take advantage of this vulnerability by creating a program named after the improperly specified program and placing it within the initiating program's directory.\n\nFor example, \"example.exe\" runs \"cmd.exe\" with the command-line argument <code>net user</code>. An adversary may place a program called \"net.exe\" within the same directory as example.exe, \"net.exe\" will be run instead of the Windows system utility net. In addition, if an adversary places a program called \"net.com\" in the same directory as \"net.exe\", then <code>cmd.exe /C net user</code> will execute \"net.com\" instead of \"net.exe\" due to the order of executable extensions defined under PATHEXT. (Citation: Microsoft Environment Property)\n\nSearch order hijacking is also a common practice for hijacking DLL loads and is covered in [DLL](https://attack.mitre.org/techniques/T1574/001).",
                    "description_jp": "攻撃者は、他のプログラムのロードに使用される検索順序をハイジャックすることで、独自の悪意のあるペイロードを実行する可能性があります。プログラムによってはフルパスで他のプログラムを呼び出さないものもあるため、敵は呼び出し元のプログラムがあるディレクトリに自分のファイルを置き、呼び出し元のプログラムの要求に応じてオペレーティングシステムが悪意のあるソフトウェアを起動するように仕向ける可能性があります。\n\n検索順序のハイジャックは、敵対者がWindowsがパスを与えられていないプログラムを検索する順序を悪用することで発生する。[DLL](https://attack.mitre.org/techniques/T1574/001)の検索順ハイジャックとは異なり、検索順はプログラムの実行に使用されるメソッドによって異なります。(引用: Microsoft CreateProcess) (引用: Windows NT Command Shell) (引用: Microsoft WinExec) しかし、WindowsはWindowsシステムディレクトリを検索する前に、開始プログラムのディレクトリを検索するのが一般的である。検索順序のハイジャックに対して脆弱なプログラム（すなわち、実行可能ファイルへのパスを指定しないプログラム）を見つけた敵対者は、不適切に指定されたプログラムにちなんだ名前のプログラムを作成し、それを開始プログラムのディレクトリ内に配置することによって、この脆弱性を利用することができる。\n\n例えば、「example.exe」はコマンドライン引数<code>net user</code>で「cmd.exe」を実行します。攻撃者がexample.exeと同じディレクトリに「net.exe」というプログラムを置くと、「net.exe」はWindowsのシステムユーティリティnetの代わりに実行されます。さらに、攻撃者が「net.com」というプログラムを「net.exe」と同じディレクトリに置いた場合、PATHEXTで定義された実行可能拡張子の順序により、<code>cmd.exe /C net user</code>は「net.exe」の代わりに「net.com」を実行します。(引用: Microsoft Environment Property)\n\n検索順のハイジャックもDLLのロードをハイジャックするための一般的な方法で、[DLL](https://attack.mitre.org/techniques/T1574/001)でカバーされています。"
                },
                {
                    "id": "T1574.011",
                    "name_eng": "Services Registry Permissions Weakness",
                    "name_jp": "サービスレジストリアクセス許可の脆弱性",
                    "description_eng": "Adversaries may execute their own malicious payloads by hijacking the Registry entries used by services. Adversaries may use flaws in the permissions for Registry keys related to services to redirect from the originally specified executable to one that they control, in order to launch their own code when a service starts. Windows stores local service configuration information in the Registry under <code>HKLM\\SYSTEM\\CurrentControlSet\\Services</code>. The information stored under a service's Registry keys can be manipulated to modify a service's execution parameters through tools such as the service controller, sc.exe,  [PowerShell](https://attack.mitre.org/techniques/T1059/001), or [Reg](https://attack.mitre.org/software/S0075). Access to Registry keys is controlled through access control lists and user permissions. (Citation: Registry Key Security)(Citation: malware_hides_service)\n\nIf the permissions for users and groups are not properly set and allow access to the Registry keys for a service, adversaries may change the service's binPath/ImagePath to point to a different executable under their control. When the service starts or is restarted, then the adversary-controlled program will execute, allowing the adversary to establish persistence and/or privilege escalation to the account context the service is set to execute under (local/domain account, SYSTEM, LocalService, or NetworkService).\n\nAdversaries may also alter other Registry keys in the service’s Registry tree. For example, the <code>FailureCommand</code> key may be changed so that the service is executed in an elevated context anytime the service fails or is intentionally corrupted.(Citation: Kansa Service related collectors)(Citation: Tweet Registry Perms Weakness)\n\nThe <code>Performance</code> key contains the name of a driver service's performance DLL and the names of several exported functions in the DLL.(Citation: microsoft_services_registry_tree) If the <code>Performance</code> key is not already present and if an adversary-controlled user has the <code>Create Subkey</code> permission, adversaries may create the <code>Performance</code> key in the service’s Registry tree to point to a malicious DLL.(Citation: insecure_reg_perms)\n\nAdversaries may also add the <code>Parameters</code> key, which stores driver-specific data, or other custom subkeys for their malicious services to establish persistence or enable other malicious activities.(Citation: microsoft_services_registry_tree)(Citation: troj_zegost) Additionally, If adversaries launch their malicious services using svchost.exe, the service’s file may be identified using <code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\servicename\\Parameters\\ServiceDll</code>.(Citation: malware_hides_service)",
                    "description_jp": "攻撃者は、サービスが使用するレジストリ・エントリをハイジャックすることで、独自の悪意のあるペイロードを実行する可能性がある。攻撃者は、サービスに関連するレジストリ キーのパーミッションの欠陥を利用して、サービスの起動時に独自のコードを起動するために、本来指定されている実行可能ファイルから自分たちが制御する実行可能ファイルへとリダイレクトする可能性がある。Windowsは、レジストリの<code>HKLM\\SYSTEM\\CurrentControlSet\\Services</code>の下にローカルサービスのコンフィギュレーション情報を格納します。サービスのレジストリキーの下に格納された情報は、サービスコントローラー、sc.exe、 [PowerShell](https://attack.mitre.org/techniques/T1059/001)、または[Reg](https://attack.mitre.org/software/S0075)のようなツールを使って、サービスの実行パラメーターを変更するために操作することができる。レジストリ・キーへのアクセスは、アクセス制御リストとユーザー権限によって制御される。(引用：レジストリキーのセキュリティ）（引用：malware_hides_service）\n\nユーザーやグループのパーミッションが適切に設定されておらず、サービスのレジストリ・キーへのアクセスを許可している場合、敵対者はサービスのbinPath/ImagePathを変更し、自分のコントロール下にある別の実行ファイルを指すようにする可能性があります。サービスが開始または再起動されると、敵が制御するプログラムが実行され、サービスが実行されるように設定されたアカウントコンテキスト（ローカル/ドメインアカウント、SYSTEM、LocalService、またはNetworkService）への永続化および/または特権昇格が可能になります。\n\n逆境者はまた、サービスのレジストリツリー内の他のレジストリキーを変更する可能性があります。たとえば、<code>FailureCommand</code>キーが変更され、サービスに障害が発生したり、サービスが意図的に破損したりした場合に、いつでも昇格したコンテキストでサービスが実行されるようにすることができる。 (引用：Kansa サービス関連コレクター）（引用：Tweet Registry Perms Weakness)\n\n<code>Performance</code>キーには、ドライバ サービスのパフォーマンス DLL の名前と、DLL 内のいくつかのエクスポートされた関数の名前が含まれます。(引用: microsoft_services_registry_tree) <code>Performance</code> キーがまだ存在せず、敵に制御されたユーザーが <code>Create Subkey</code> 権限を持っている場合、敵はサービスのレジストリ ツリーに悪意のある DLL を指す <code>Performance</code> キーを作成する可能性があります。(引用: insecure_reg_perms)\n\nまた、ドライバ固有のデータを格納する <code>Parameters</code> キーや、その他のカスタム サブキーを悪意のあるサービスに追加して、永続性を確立したり、その他の悪意のある活動を可能にしたりすることもできます。(引用: microsoft_services_registry_tree)(引用: troj_zegost) さらに、敵対者が svchost.exe を使用して悪意のあるサービスを起動する場合、サービスのファイルは <code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\servicename\\Parameters\\ServiceDll</code> を使用して識別される可能性があります(引用: malware_hides_service)。"
                },
                {
                    "id": "T1574.012",
                    "name_eng": "COR_PROFILER",
                    "name_jp": "COR_PROFILER",
                    "description_eng": "Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)\n\nThe COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a [Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.(Citation: Microsoft COR_PROFILER Feb 2013)\n\nAdversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)) if the victim .NET process executes at a higher permission level, as well as to hook and [Impair Defenses](https://attack.mitre.org/techniques/T1562) provided by .NET processes.(Citation: RedCanary Mockingbird May 2020)(Citation: Red Canary COR_PROFILER May 2020)(Citation: Almond COR_PROFILER Apr 2019)(Citation: GitHub OmerYa Invisi-Shell)(Citation: subTee .NET Profilers May 2017)",
                    "description_jp": "攻撃者は COR_PROFILER 環境変数を利用して、.NET CLR をロードするプログラムの実行フローを乗っ取る可能性があります。COR_PROFILERは.NET Frameworkの機能で、開発者は共通言語ランタイム（CLR）をロードする各.NETプロセスにロードされるアンマネージド（または.NETの外部）プロファイリングDLLを指定できます。これらのプロファイラーは、.NET CLRで実行されるマネージドコードを監視、トラブルシューティング、デバッグするために設計されています。(引用: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)\n\nCOR_PROFILER 環境変数は、さまざまなスコープ（システム、ユーザー、またはプロセス）で設定でき、その結果、影響力のレベルが異なります。システムおよびユーザー全体の環境変数スコープは、[コンポーネントオブジェクトモデル](https://attack.mitre.org/techniques/T1559/001) (COM) オブジェクトをプロファイラ DLL として登録できるレジストリで指定されます。プロセススコープCOR_PROFILERは、レジストリを変更することなくメモリ内に作成することもできます。.NET Framework 4からは、COR_PROFILER_PATH環境変数にDLLの場所が指定されていれば、プロファイリングDLLを登録する必要はありません（引用：Microsoft COR_PROFILER 2013年2月）。\n\n攻撃者はCOR_PROFILERを悪用して、CLRが呼び出されるたびにすべての.NETプロセスのコンテキストで悪意のあるDLLを実行する永続性を確立する可能性があります。また、COR_PROFILERは、被害者である.NETプロセスがより高い権限レベルで実行されている場合、権限の昇格（例：[ユーザーアカウント制御のバイパス](https://attack.mitre.org/techniques/T1548/002)）や、フックおよび[防御の阻害](https://attack.mitre.org/techniques/T1562).NETプロセスによって提供される。(引用: RedCanary Mockingbird 2020年5月)(引用: Red Canary COR_PROFILER 2020年5月)(引用: Almond COR_PROFILER 2019年4月)(引用: GitHub OmerYa Invisi-Shell)(引用: subTee .NET Profilers 2017年5月)"
                }
            ]
        },
        {
            "id": "T1078",
            "name_eng": "Valid Accounts",
            "name_jp": "有効なアカウント",
            "description_eng": "Adversaries may obtain and abuse credentials of existing accounts as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Compromised credentials may be used to bypass access controls placed on various resources on systems within the network and may even be used for persistent access to remote systems and externally available services, such as VPNs, Outlook Web Access, network devices, and remote desktop.(Citation: volexity_0day_sophos_FW) Compromised credentials may also grant an adversary increased privilege to specific systems or access to restricted areas of the network. Adversaries may choose not to use malware or tools in conjunction with the legitimate access those credentials provide to make it harder to detect their presence.\n\nIn some cases, adversaries may abuse inactive accounts: for example, those belonging to individuals who are no longer part of an organization. Using these accounts may allow the adversary to evade detection, as the original account user will not be present to identify any anomalous activity taking place on their account.(Citation: CISA MFA PrintNightmare)\n\nThe overlap of permissions for local, domain, and cloud accounts across a network of systems is of concern because the adversary may be able to pivot across accounts and systems to reach a high level of access (i.e., domain or enterprise administrator) to bypass access controls set within the enterprise.(Citation: TechNet Credential Theft)",
            "description_jp": "攻撃者は、初期アクセス、永続化、権限昇格、または防御回避の手段として、既存のアカウントの資格情報を取得して悪用する可能性があります。侵害された資格情報は、ネットワーク内のシステムのさまざまなリソースに配置されたアクセス制御をバイパスするために使用される場合があり、VPN、Outlook Web Access、ネットワークデバイス、リモートデスクトップなど、リモートシステムや外部からアクセス可能なサービスへの永続的なアクセスに使用されることさえあります。(引用: volexity_0day_sophos_FW) 侵害された資格情報は、攻撃者に特定のシステムに対する権限の昇格や、ネットワークの制限された領域へのアクセスを許可する可能性もあります。攻撃者は、これらの資格情報が提供する正当なアクセスと組み合わせてマルウェアやツールを使用しないことを選択し、その存在を検出することをより困難にする場合があります。\n\n場合によっては、攻撃者は非アクティブなアカウントを悪用することがあります。例えば、組織の一員ではなくなった個人に属するアカウントなどです。これらのアカウントを使用すると、元のアカウントユーザーが自分のアカウントで行われている異常なアクティビティを特定するために存在しないため、攻撃者は検出を回避できる可能性があります。(引用: CISA MFA PrintNightmare)\n\nシステムのネットワーク全体にわたるローカル、ドメイン、およびクラウドアカウントの権限の重複は懸念事項です。なぜなら、攻撃者はアカウントやシステムをまたいでピボットし、高レベルのアクセス（つまり、ドメインまたはエンタープライズ管理者）に到達して、エンタープライズ内で設定されたアクセス制御をバイパスできる可能性があるためです。(引用: TechNet Credential Theft)",
            "subtechniques": [
                {
                    "id": "T1078.004",
                    "name_eng": "Cloud Accounts",
                    "name_jp": "クラウドアカウント",
                    "description_eng": "Valid accounts in cloud environments may allow adversaries to perform actions to achieve Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Cloud accounts are those created and configured by an organization for use by users, remote support, services, or for administration of resources within a cloud service provider or SaaS application. Cloud Accounts can exist solely in the cloud; alternatively, they may be hybrid-joined between on-premises systems and the cloud through syncing or federation with other identity sources such as Windows Active Directory.(Citation: AWS Identity Federation)(Citation: Google Federating GC)(Citation: Microsoft Deploying AD Federation)\n\nService or user accounts may be targeted by adversaries through [Brute Force](https://attack.mitre.org/techniques/T1110), [Phishing](https://attack.mitre.org/techniques/T1566), or various other means to gain access to the environment. Federated or synced accounts may be a pathway for the adversary to affect both on-premises systems and cloud environments - for example, by leveraging shared credentials to log onto [Remote Services](https://attack.mitre.org/techniques/T1021). High privileged cloud accounts, whether federated, synced, or cloud-only, may also allow pivoting to on-premises environments by leveraging SaaS-based [Software Deployment Tools](https://attack.mitre.org/techniques/T1072) to run commands on hybrid-joined devices.\n\nAn adversary may create long lasting [Additional Cloud Credentials](https://attack.mitre.org/techniques/T1098/001) on a compromised cloud account to maintain persistence in the environment. Such credentials may also be used to bypass security controls such as multi-factor authentication. \n\nCloud accounts may also be able to assume [Temporary Elevated Cloud Access](https://attack.mitre.org/techniques/T1548/005) or other privileges through various means within the environment. Misconfigurations in role assignments or role assumption policies may allow an adversary to use these mechanisms to leverage permissions outside the intended scope of the account. Such over privileged accounts may be used to harvest sensitive data from online storage accounts and databases through [Cloud API](https://attack.mitre.org/techniques/T1059/009) or other methods. For example, in Azure environments, adversaries may target Azure Managed Identities, which allow associated Azure resources to request access tokens. By compromising a resource with an attached Managed Identity, such as an Azure VM, adversaries may be able to [Steal Application Access Token](https://attack.mitre.org/techniques/T1528)s to move laterally across the cloud environment.(Citation: SpecterOps Managed Identity 2022)",
                    "description_jp": "クラウド環境の有効なアカウントにより、攻撃者は初期アクセス、永続化、権限昇格、または防御回避を達成するためのアクションを実行できる可能性があります。クラウドアカウントとは、ユーザー、リモートサポート、サービス、またはクラウドサービスプロバイダーやSaaSアプリケーション内のリソースの管理のために組織によって作成および構成されたものです。クラウドアカウントはクラウド内にのみ存在することも、Windows Active Directoryなどの他のIDソースとの同期またはフェデレーションを通じてオンプレミスシステムとクラウド間でハイブリッド結合することもできます。(引用: AWS Identity Federation)(引用: Google Federating GC)(引用: Microsoft Deploying AD Federation)\n\nサービスアカウントまたはユーザーアカウントは、[ブルートフォース](https://attack.mitre.org/techniques/T1110)、[フィッシング](https://attack.mitre.org/techniques/T1566)、またはその他のさまざまな手段を通じて攻撃者の標的となり、環境へのアクセスを取得する可能性があります。フェデレーションまたは同期されたアカウントは、攻撃者がオンプレミスシステムとクラウド環境の両方に影響を与える経路となる可能性があります。たとえば、共有資格情報を利用して[リモートサービス](https://attack.mitre.org/techniques/T1021)にログオンするなどです。フェデレーション、同期、またはクラウド専用であるかどうかにかかわらず、特権の高いクラウドアカウントは、ハイブリッド結合されたデバイスでコマンドを実行するためにSaaSベースの[ソフトウェア展開ツール](https://attack.mitre.org/techniques/T1072)を利用することにより、オンプレミス環境へのピボットを可能にする場合もあります。\n\n攻撃者は、環境内での永続性を維持するために、侵害されたクラウドアカウントに長期間有効な[追加のクラウド資格情報](https://attack.mitre.org/techniques/T1098/001)を作成する可能性があります。このような資格情報は、多要素認証などのセキュリティ制御をバイパスするためにも使用される場合があります。\n\nクラウドアカウントはまた、環境内のさまざまな手段を通じて[一時的な昇格されたクラウドアクセス](https://attack.mitre.org/techniques/T1548/005)またはその他の権限を取得できる場合もあります。ロールの割り当てまたはロールの引き受けポリシーの誤構成により、攻撃者はこれらのメカニズムを使用して、アカウントの意図された範囲外の権限を利用できる可能性があります。このような過剰な特権を持つアカウントは、[クラウドAPI](https://attack.mitre.org/techniques/T1059/009)またはその他の方法を通じて、オンラインストレージアカウントおよびデータベースから機密データを収集するために使用される場合があります。たとえば、Azure環境では、攻撃者は関連するAzureリソースがアクセストークンを要求できるようにするAzure Managed Identitiesを標的にする可能性があります。Azure VMなどの管理対象IDがアタッチされたリソースを侵害することにより、攻撃者は[アプリケーションアクセストークンの窃取](https://attack.mitre.org/techniques/T1528)を行い、クラウド環境全体を横断的に移動できる可能性があります。(引用: SpecterOps Managed Identity 2022)"
                },
                {
                    "id": "T1078.002",
                    "name_eng": "Domain Accounts",
                    "name_jp": "ドメインアカウント",
                    "description_eng": "Adversaries may obtain and abuse credentials of a domain account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion.(Citation: TechNet Credential Theft) Domain accounts are those managed by Active Directory Domain Services where access and permissions are configured across systems and services that are part of that domain. Domain accounts can cover users, administrators, and services.(Citation: Microsoft AD Accounts)\n\nAdversaries may compromise domain accounts, some with a high level of privileges, through various means such as [OS Credential Dumping](https://attack.mitre.org/techniques/T1003) or password reuse, allowing access to privileged resources of the domain.",
                    "description_jp": "攻撃者は、初期アクセス、永続化、権限昇格、または防御回避の手段として、ドメインアカウントの資格情報を取得して悪用する可能性があります。(引用: TechNet Credential Theft) ドメインアカウントとは、Active Directoryドメインサービスによって管理され、そのドメインの一部であるシステムおよびサービス全体でアクセスと権限が構成されるものです。ドメインアカウントには、ユーザー、管理者、およびサービスが含まれます。(引用: Microsoft AD Accounts)\n\n攻撃者は、[OS資格情報ダンピング](https://attack.mitre.org/techniques/T1003)やパスワードの再利用など、さまざまな手段を通じて、一部は高レベルの特権を持つドメインアカウントを侵害し、ドメインの特権リソースへのアクセスを許可する可能性があります。"
                },
                {
                    "id": "T1078.003",
                    "name_eng": "Local Accounts",
                    "name_jp": "ローカルアカウント",
                    "description_eng": "Adversaries may obtain and abuse credentials of a local account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Local accounts are those configured by an organization for use by users, remote support, services, or for administration on a single system or service.\n\nLocal Accounts may also be abused to elevate privileges and harvest credentials through [OS Credential Dumping](https://attack.mitre.org/techniques/T1003). Password reuse may allow the abuse of local accounts across a set of machines on a network for the purposes of Privilege Escalation and Lateral Movement.",
                    "description_jp": "攻撃者は、初期アクセス、永続化、権限昇格、または防御回避の手段として、ローカルアカウントの資格情報を取得して悪用する可能性があります。ローカルアカウントとは、ユーザー、リモートサポート、サービス、または単一のシステムやサービスの管理のために組織によって構成されたものです。\n\nローカルアカウントは、[OS資格情報ダンピング](https://attack.mitre.org/techniques/T1003)を通じて権限を昇格させたり、資格情報を収集したりするために悪用されることもあります。パスワードの再利用により、権限昇格や横方向の移動を目的として、ネットワーク上の一連のマシンでローカルアカウントが悪用される可能性があります。"
                },
                {
                    "id": "T1078.001",
                    "name_eng": "Default Accounts",
                    "name_jp": "デフォルトアカウント",
                    "description_eng": "Adversaries may obtain and abuse credentials of a default account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Default accounts are those that are built-into an OS, such as the Guest or Administrator accounts on Windows systems. Default accounts also include default factory/provider set accounts on other types of systems, software, or devices, including the root user account in AWS, the root user account in ESXi, and the default service account in Kubernetes.(Citation: Microsoft Local Accounts Feb 2019)(Citation: AWS Root User)(Citation: Threat Matrix for Kubernetes)\n\nDefault accounts are not limited to client machines; rather, they also include accounts that are preset for equipment such as network devices and computer applications, whether they are internal, open source, or commercial. Appliances that come preset with a username and password combination pose a serious threat to organizations that do not change it post installation, as they are easy targets for an adversary. Similarly, adversaries may also utilize publicly disclosed or stolen [Private Keys](https://attack.mitre.org/techniques/T1552/004) or credential materials to legitimately connect to remote environments via [Remote Services](https://attack.mitre.org/techniques/T1021).(Citation: Metasploit SSH Module)\n\nDefault accounts may be created on a system after initial setup by connecting or integrating it with another application. For example, when an ESXi server is connected to a vCenter server, a default privileged account called `vpxuser` is created on the ESXi server. If a threat actor is able to compromise this account’s credentials (for example, via [Exploitation for Credential Access](https://attack.mitre.org/techniques/T1212) on the vCenter host), they will then have access to the ESXi server.(Citation: Google Cloud Threat Intelligence VMWare ESXi Zero-Day 2023)(Citation: Pentera vCenter Information Disclosure)",
                    "description_jp": "攻撃者は、初期アクセス、永続化、権限昇格、または防御回避の手段として、デフォルトアカウントの資格情報を取得して悪用する可能性があります。デフォルトアカウントとは、WindowsシステムのゲストアカウントやAdministratorアカウントなど、OSに組み込まれているアカウントです。デフォルトアカウントには、AWSのルートユーザーアカウント、ESXiのルートユーザーアカウント、Kubernetesのデフォルトサービスアカウントなど、他の種類のシステム、ソフトウェア、またはデバイスのデフォルトの工場出荷時/プロバイダー設定アカウントも含まれます。(引用: Microsoft Local Accounts Feb 2019)(引用: AWS Root User)(引用: Threat Matrix for Kubernetes)\n\nデフォルトアカウントはクライアントマシンに限定されません。むしろ、内部、オープンソース、または商用であるかどうかにかかわらず、ネットワークデバイスやコンピュータアプリケーションなどの機器にあらかじめ設定されているアカウントも含まれます。ユーザー名とパスワードの組み合わせがあらかじめ設定されているアプライアンスは、インストール後に変更しない組織にとっては攻撃者の格好の標的となるため、深刻な脅威となります。同様に、攻撃者は、[リモートサービス](https://attack.mitre.org/techniques/T1021)を介してリモート環境に正当に接続するために、公に開示された、または盗まれた[秘密キー](https://attack.mitre.org/techniques/T1552/004)または資格情報資料を利用することもあります。(引用: Metasploit SSH Module)\n\nデフォルトアカウントは、別のアプリケーションに接続または統合することにより、初期設定後にシステム上に作成される場合があります。例えば、ESXiサーバーがvCenterサーバーに接続されると、ESXiサーバー上に`vpxuser`というデフォルトの特権アカウントが作成されます。脅威アクターがこのアカウントの資格情報を侵害できた場合（例えば、vCenterホスト上の[資格情報アクセスのための悪用](https://attack.mitre.org/techniques/T1212)を介して）、ESXiサーバーにアクセスできるようになります。(引用: Google Cloud Threat Intelligence VMWare ESXi Zero-Day 2023)(引用: Pentera vCenter Information Disclosure)"
                }
            ]
        },
        {
            "id": "T1068",
            "name_eng": "Exploitation for Privilege Escalation",
            "name_jp": "権限昇格のための悪用",
            "description_eng": "Adversaries may exploit software vulnerabilities in an attempt to elevate privileges. Exploitation of a software vulnerability occurs when an adversary takes advantage of a programming error in a program, service, or within the operating system software or kernel itself to execute adversary-controlled code. Security constructs such as permission levels will often hinder access to information and use of certain techniques, so adversaries will likely need to perform privilege escalation to include use of software exploitation to circumvent those restrictions.\n\nWhen initially gaining access to a system, an adversary may be operating within a lower privileged process which will prevent them from accessing certain resources on the system. Vulnerabilities may exist, usually in operating system components and software commonly running at higher permissions, that can be exploited to gain higher levels of access on the system. This could enable someone to move from unprivileged or user level permissions to SYSTEM or root permissions depending on the component that is vulnerable. This could also enable an adversary to move from a virtualized environment, such as within a virtual machine or container, onto the underlying host. This may be a necessary step for an adversary compromising an endpoint system that has been properly configured and limits other privilege escalation methods.\n\nAdversaries may bring a signed vulnerable driver onto a compromised machine so that they can exploit the vulnerability to execute code in kernel mode. This process is sometimes referred to as Bring Your Own Vulnerable Driver (BYOVD).(Citation: ESET InvisiMole June 2020)(Citation: Unit42 AcidBox June 2020) Adversaries may include the vulnerable driver with files delivered during Initial Access or download it to a compromised system via [Ingress Tool Transfer](https://attack.mitre.org/techniques/T1105) or [Lateral Tool Transfer](https://attack.mitre.org/techniques/T1570).",
            "description_jp": "攻撃者は、権限を昇格させる試みとしてソフトウェアの脆弱性を悪用する可能性があります。ソフトウェアの脆弱性の悪用は、攻撃者がプログラム、サービス、またはオペレーティングシステムのソフトウェアやカーネル自体のプログラミングエラーを利用して、攻撃者が制御するコードを実行する場合に発生します。権限レベルなどのセキュリティ構成体は、情報へのアクセスや特定のテクニックの使用を妨げることが多いため、攻撃者はこれらの制限を回避するためにソフトウェアの悪用を含む権限昇格を実行する必要があるでしょう。\n\n最初にシステムへのアクセスを取得したとき、攻撃者は権限の低いプロセス内で操作している可能性があり、これによりシステム上の特定のリソースへのアクセスが妨げられます。通常、より高い権限で実行されているオペレーティングシステムのコンポーネントやソフトウェアには、システム上でより高いレベルのアクセスを取得するために悪用できる脆弱性が存在する可能性があります。これにより、脆弱なコンポーネントに応じて、権限のないユーザーレベルの権限からSYSTEMまたはroot権限に移行できる可能性があります。また、これにより、攻撃者は仮想マシンやコンテナ内などの仮想化環境から基盤となるホストに移行できる可能性もあります。これは、適切に構成され、他の権限昇格方法を制限しているエンドポイントシステムを侵害する攻撃者にとって必要なステップである可能性があります。\n\n攻撃者は、署名済みの脆弱なドライバーを侵害されたマシンに持ち込み、その脆弱性を悪用してカーネルモードでコードを実行する可能性があります。このプロセスは、Bring Your Own Vulnerable Driver（BYOVD）と呼ばれることもあります。(引用: ESET InvisiMole June 2020)(引用: Unit42 AcidBox June 2020) 攻撃者は、初期アクセス中に配信されるファイルに脆弱なドライバーを含めたり、[Ingress Tool Transfer](https://attack.mitre.org/techniques/T1105)または[Lateral Tool Transfer](https://attack.mitre.org/techniques/T1570)を介して侵害されたシステムにダウンロードしたりする可能性があります。",
            "subtechniques": []
        },
        {
            "id": "T1546",
            "name_eng": "Event Triggered Execution",
            "name_jp": "イベントトリガー実行",
            "description_eng": "Adversaries may establish persistence and/or elevate privileges using system mechanisms that trigger execution based on specific events. Various operating systems have means to monitor and subscribe to events such as logons or other user activity such as running specific applications/binaries. Cloud environments may also support various functions and services that monitor and can be invoked in response to specific cloud events.(Citation: Backdooring an AWS account)(Citation: Varonis Power Automate Data Exfiltration)(Citation: Microsoft DART Case Report 001)\n\nAdversaries may abuse these mechanisms as a means of maintaining persistent access to a victim via repeatedly executing malicious code. After gaining access to a victim system, adversaries may create/modify event triggers to point to malicious content that will be executed whenever the event trigger is invoked.(Citation: FireEye WMI 2015)(Citation: Malware Persistence on OS X)(Citation: amnesia malware)\n\nSince the execution can be proxied by an account with higher permissions, such as SYSTEM or service accounts, an adversary may be able to abuse these triggered execution mechanisms to escalate their privileges.",
            "description_jp": "攻撃者は、特定のイベントに基づいて実行をトリガーするシステムメカニズムを使用して、永続性を確立したり、権限を昇格させたりする可能性があります。さまざまなオペレーティングシステムには、ログオンや特定のアプリケーション/バイナリの実行などの他のユーザーアクティビティなどのイベントを監視およびサブスクライブする手段があります。クラウド環境はまた、特定のクラウドイベントを監視し、それに応じて呼び出すことができるさまざまな機能やサービスをサポートしている場合があります。(引用: Backdooring an AWS account)(引用: Varonis Power Automate Data Exfiltration)(引用: Microsoft DART Case Report 001)\n\n攻撃者は、悪意のあるコードを繰り返し実行することにより、被害者への永続的なアクセスを維持する手段としてこれらのメカニズムを悪用する可能性があります。被害者システムへのアクセスを取得した後、攻撃者はイベントトリガーを作成/変更して、イベントトリガーが呼び出されるたびに実行される悪意のあるコンテンツを指すようにする可能性があります。(引用: FireEye WMI 2015)(引用: Malware Persistence on OS X)(引用: amnesia malware)\n\n実行はSYSTEMやサービスアカウントなどのより高い権限を持つアカウントによってプロキシされる可能性があるため、攻撃者はこれらのトリガーされた実行メカニズムを悪用して権限を昇格させることができる場合があります。",
            "subtechniques": [
                {
                    "id": "T1546.002",
                    "name_eng": "Screensaver",
                    "name_jp": "スクリーンセーバー",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by user inactivity. Screensavers are programs that execute after a configurable time of user inactivity and consist of Portable Executable (PE) files with a .scr file extension.(Citation: Wikipedia Screensaver) The Windows screensaver application scrnsave.scr is located in <code>C:\\Windows\\System32\\</code>, and <code>C:\\Windows\\sysWOW64\\</code>  on 64-bit Windows systems, along with screensavers included with base Windows installations.\n\nThe following screensaver settings are stored in the Registry (<code>HKCU\\Control Panel\\Desktop\\</code>) and could be manipulated to achieve persistence:\n\n* <code>SCRNSAVE.exe</code> - set to malicious PE path\n* <code>ScreenSaveActive</code> - set to '1' to enable the screensaver\n* <code>ScreenSaverIsSecure</code> - set to '0' to not require a password to unlock\n* <code>ScreenSaveTimeout</code> - sets user inactivity timeout before screensaver is executed\n\nAdversaries can use screensaver settings to maintain persistence by setting the screensaver to run malware after a certain timeframe of user inactivity.(Citation: ESET Gazer Aug 2017)",
                    "description_jp": "攻撃者は、ユーザーの非アクティブ状態によってトリガーされる悪意のあるコンテンツを実行することで、永続性を確立する可能性があります。スクリーンセーバーは、設定可能なユーザー非アクティブ時間の後に実行されるプログラムであり、.scrファイル拡張子を持つポータブル実行可能（PE）ファイルで構成されます。(引用: Wikipedia Screensaver) Windowsスクリーンセーバーアプリケーションscrnsave.scrは、基本のWindowsインストールに含まれるスクリーンセーバーとともに、64ビットWindowsシステムでは<code>C:\\Windows\\System32\\</code>および<code>C:\\Windows\\sysWOW64\\</code>にあります。\n\n次のスクリーンセーバー設定はレジストリ（<code>HKCU\\Control Panel\\Desktop\\</code>）に保存されており、永続性を実現するために操作される可能性があります：\n\n* <code>SCRNSAVE.exe</code> - 悪意のあるPEパスに設定\n* <code>ScreenSaveActive</code> - スクリーンセーバーを有効にするために「1」に設定\n* <code>ScreenSaverIsSecure</code> -ロック解除にパスワードを必要としないように「0」に設定\n* <code>ScreenSaveTimeout</code> - スクリーンセーバーが実行される前のユーザー非アクティブタイムアウトを設定\n\n攻撃者は、スクリーンセーバーの設定を使用して、特定のユーザー非アクティブ時間の後にマルウェアを実行するようにスクリーンセーバーを設定することにより、永続性を維持できます。(引用: ESET Gazer Aug 2017)"
                },
                {
                    "id": "T1546.013",
                    "name_eng": "PowerShell Profile",
                    "name_jp": "PowerShellプロファイル",
                    "description_eng": "Adversaries may gain persistence and elevate privileges by executing malicious content triggered by PowerShell profiles. A PowerShell profile  (<code>profile.ps1</code>) is a script that runs when [PowerShell](https://attack.mitre.org/techniques/T1059/001) starts and can be used as a logon script to customize user environments.\n\n[PowerShell](https://attack.mitre.org/techniques/T1059/001) supports several profiles depending on the user or host program. For example, there can be different profiles for [PowerShell](https://attack.mitre.org/techniques/T1059/001) host programs such as the PowerShell console, PowerShell ISE or Visual Studio Code. An administrator can also configure a profile that applies to all users and host programs on the local computer. (Citation: Microsoft About Profiles) \n\nAdversaries may modify these profiles to include arbitrary commands, functions, modules, and/or [PowerShell](https://attack.mitre.org/techniques/T1059/001) drives to gain persistence. Every time a user opens a [PowerShell](https://attack.mitre.org/techniques/T1059/001) session the modified script will be executed unless the <code>-NoProfile</code> flag is used when it is launched. (Citation: ESET Turla PowerShell May 2019) \n\nAn adversary may also be able to escalate privileges if a script in a PowerShell profile is loaded and executed by an account with higher privileges, such as a domain administrator. (Citation: Wits End and Shady PowerShell Profiles)",
                    "description_jp": "攻撃者は、PowerShellプロファイルによってトリガーされる悪意のあるコンテンツを実行することで、永続性を獲得し、権限を昇格させる可能性があります。PowerShellプロファイル（<code>profile.ps1</code>）は、[PowerShell](https://attack.mitre.org/techniques/T1059/001)が起動するときに実行されるスクリプトであり、ユーザー環境をカスタマイズするためのログオンスクリプトとして使用できます。\n\n[PowerShell](https://attack.mitre.org/techniques/T1059/001)は、ユーザーまたはホストプログラムに応じていくつかのプロファイルをサポートしています。たとえば、PowerShellコンソール、PowerShell ISE、Visual Studio Codeなどの[PowerShell](https://attack.mitre.org/techniques/T1059/001)ホストプログラム用に異なるプロファイルが存在する可能性があります。管理者は、ローカルコンピューター上のすべてのユーザーおよびホストプログラムに適用されるプロファイルを構成することもできます。(引用: Microsoft About Profiles)\n\n攻撃者はこれらのプロファイルを変更して、任意のコマンド、関数、モジュール、および/または[PowerShell](https://attack.mitre.org/techniques/T1059/001)ドライブを含めて永続性を獲得する可能性があります。ユーザーが[PowerShell](https://attack.mitre.org/techniques/T1059/001)セッションを開くたびに、起動時に<code>-NoProfile</code>フラグが使用されない限り、変更されたスクリプトが実行されます。(引用: ESET Turla PowerShell May 2019)\n\nPowerShellプロファイル内のスクリプトが、ドメイン管理者などのより高い権限を持つアカウントによってロードおよび実行された場合、攻撃者は権限を昇格できる可能性もあります。(引用: Wits End and Shady PowerShell Profiles)"
                },
                {
                    "id": "T1546.016",
                    "name_eng": "Installer Packages",
                    "name_jp": "インストーラーパッケージ",
                    "description_eng": "Adversaries may establish persistence and elevate privileges by using an installer to trigger the execution of malicious content. Installer packages are OS specific and contain the resources an operating system needs to install applications on a system. Installer packages can include scripts that run prior to installation as well as after installation is complete. Installer scripts may inherit elevated permissions when executed. Developers often use these scripts to prepare the environment for installation, check requirements, download dependencies, and remove files after installation.(Citation: Installer Package Scripting Rich Trouton)\n\nUsing legitimate applications, adversaries have distributed applications with modified installer scripts to execute malicious content. When a user installs the application, they may be required to grant administrative permissions to allow the installation. At the end of the installation process of the legitimate application, content such as macOS `postinstall` scripts can be executed with the inherited elevated permissions. Adversaries can use these scripts to execute a malicious executable or install other malicious components (such as a [Launch Daemon](https://attack.mitre.org/techniques/T1543/004)) with the elevated permissions.(Citation: Application Bundle Manipulation Brandon Dalton)(Citation: wardle evilquest parti)(Citation: Windows AppleJeus GReAT)(Citation: Debian Manual Maintainer Scripts)\n\nDepending on the distribution, Linux versions of package installer scripts are sometimes called maintainer scripts or post installation scripts. These scripts can include `preinst`, `postinst`, `prerm`, `postrm` scripts and run as root when executed.\n\nFor Windows, the Microsoft Installer services uses `.msi` files to manage the installing, updating, and uninstalling of applications. These installation routines may also include instructions to perform additional actions that may be abused by adversaries.(Citation: Microsoft Installation Procedures)",
                    "description_jp": "攻撃者は、インストーラを使用して悪意のあるコンテンツを実行させることで、永続性を確立し、特権を昇格させる可能性があります。インストーラパッケージはOS固有のものであり、オペレーティングシステムがシステムにアプリケーションをインストールするために必要なリソースを含んでいます。インストーラパッケージには、インストール前に実行されるスクリプトと、インストール完了後に実行されるスクリプトが含まれることがあります。インストーラスクリプトは、実行時に昇格権限を継承する場合があります。開発者は多くの場合、これらのスクリプトを使用して、インストール環境の準備、要件の確認、依存関係のダウンロード、インストール後のファイルの削除を行います。(引用: Installer Package Scripting Rich Trouton)\n\n敵対者は、正規のアプリケーションを使用して、悪意のあるコンテンツを実行するようにインストーラスクリプトを変更したアプリケーションを配布しています。ユーザがアプリケーションをインストールする際、インストールを許可するために管理者権限を付与する必要がある場合があります。正規のアプリケーションのインストールプロセスの最後に、macOS の `postinstall` スクリプトなどのコンテンツが、継承された昇格権限で実行される可能性があります。攻撃者はこれらのスクリプトを使用して、悪意のある実行ファイルを実行したり、昇格した権限で他の悪意のあるコンポーネント（[起動デーモン](https://attack.mitre.org/techniques/T1543/004)など）をインストールしたりすることができます。（引用：Application Bundle Manipulation Brandon Dalton）（引用：wardle evilquest parti）（引用：Windows AppleJeus GReAT）（引用：Debian Manual Maintainer Scripts）\n\nディストリビューションによっては、Linux版のパッケージインストーラスクリプトは、メンテナースクリプトやポストインストールスクリプトと呼ばれることもあります。これらのスクリプトには `preinst`、`postinst`、`prerm`、`postrm` スクリプトが含まれ、実行時には root として実行されます。\n\nWindows の場合、Microsoft Installer サービスはアプリケーションのインストー ル、アップデート、アンインストールを管理するために `.msi` ファイルを使用します。これらのインストールルーチンには、敵対者に悪用される可能性のある追加アクションを実行する指示が含まれていることもあります。(引用: Microsoft Installation Procedures)"
                },
                {
                    "id": "T1546.003",
                    "name_eng": "Windows Management Instrumentation Event Subscription",
                    "name_jp": "Windows Management Instrumentationイベントサブスクリプション",
                    "description_eng": "Adversaries may establish persistence and elevate privileges by executing malicious content triggered by a Windows Management Instrumentation (WMI) event subscription. WMI can be used to install event filters, providers, consumers, and bindings that execute code when a defined event occurs. Examples of events that may be subscribed to are the wall clock time, user login, or the computer's uptime.(Citation: Mandiant M-Trends 2015)\n\nAdversaries may use the capabilities of WMI to subscribe to an event and execute arbitrary code when that event occurs, providing persistence on a system.(Citation: FireEye WMI SANS 2015)(Citation: FireEye WMI 2015) Adversaries may also compile WMI scripts – using `mofcomp.exe`  –into Windows Management Object (MOF) files (.mof extension) that can be used to create a malicious subscription.(Citation: Dell WMI Persistence)(Citation: Microsoft MOF May 2018)\n\nWMI subscription execution is proxied by the WMI Provider Host process (WmiPrvSe.exe) and thus may result in elevated SYSTEM privileges.",
                    "description_jp": "攻撃者は、Windows Management Instrumentation (WMI)イベントサブスクリプションによってトリガーされる悪意のあるコンテンツを実行することで、永続性を確立し、特権を昇格させる可能性があります。WMIは、定義されたイベントが発生したときにコードを実行するイベントフィルター、プロバイダー、コンシューマー、バインディングをインストールするために使用することができる。サブスクライブされるイベントの例としては、壁掛け時計の時刻、ユーザーログイン、コンピュータの稼働時間などが挙げられます（引用：Mandiant M-Trends 2015）。\n\n攻撃者は、WMIの機能を使用してイベントをサブスクライブし、そのイベントが発生したときに任意のコードを実行し、システム上に永続性を提供する可能性があります(引用: FireEye WMI SANS 2015)(引用: FireEye WMI 2015) また、攻撃者は、<code>mofcomp.exe</code>を使用して、悪意のあるサブスクリプションを作成するために使用できるWindows Management Object (MOF) ファイル(.mof 拡張子)にWMIスクリプトをコンパイルする可能性があります(引用: Dell WMI Persistence)(引用: Microsoft MOF May 2018)\n\nWMI サブスクリプションの実行は、WMI Provider Host プロセス (WmiPrvSe.exe) によってプロキシされるため、SYSTEM 権限が昇格する可能性があります。"
                },
                {
                    "id": "T1546.006",
                    "name_eng": "LC_LOAD_DYLIB Addition",
                    "name_jp": "LC_LOAD_DYLIB追加",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by the execution of tainted binaries. Mach-O binaries have a series of headers that are used to perform certain operations when a binary is loaded. The LC_LOAD_DYLIB header in a Mach-O binary tells macOS and OS X which dynamic libraries (dylibs) to load during execution time. These can be added ad-hoc to the compiled binary as long as adjustments are made to the rest of the fields and dependencies.(Citation: Writing Bad Malware for OSX) There are tools available to perform these changes.\n\nAdversaries may modify Mach-O binary headers to load and execute malicious dylibs every time the binary is executed. Although any changes will invalidate digital signatures on binaries because the binary is being modified, this can be remediated by simply removing the LC_CODE_SIGNATURE command from the binary so that the signature isn’t checked at load time.(Citation: Malware Persistence on OS X)",
                    "description_jp": "攻撃者は、汚染されたバイナリの実行をトリガーとして悪意のあるコンテンツを実行することで、永続性を確立する可能性がある。Mach-Oバイナリは、バイナリがロードされたときに特定の操作を実行するために使用される一連のヘッダを持っています。Mach-OバイナリのLC_LOAD_DYLIBヘッダは、実行時にどのダイナミックライブラリ(dylibs)をロードするかをmacOSとOS Xに伝えます。これらは、残りのフィールドと依存関係を調整する限り、コンパイルされたバイナリにアドホックに追加することができます（引用：Writing Bad Malware for OSX）これらの変更を実行するために利用可能なツールがあります。\n\n攻撃者は、バイナリが実行されるたびに悪意のあるdylibをロードして実行するように、Mach-Oバイナリのヘッダを変更することができます。バイナリが変更されているため、いかなる変更もバイナリのデジタル署名を無効にしますが、バイナリからLC_CODE_SIGNATUREコマンドを削除するだけで、ロード時に署名がチェックされないようにすることができます。(引用: Malware Persistence on OS X)"
                },
                {
                    "id": "T1546.011",
                    "name_eng": "Application Shimming",
                    "name_jp": "アプリケーションシミング",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by application shims. The Microsoft Windows Application Compatibility Infrastructure/Framework (Application Shim) was created to allow for backward compatibility of software as the operating system codebase changes over time. For example, the application shimming feature allows developers to apply fixes to applications (without rewriting code) that were created for Windows XP so that it will work with Windows 10. (Citation: Elastic Process Injection July 2017)\n\nWithin the framework, shims are created to act as a buffer between the program (or more specifically, the Import Address Table) and the Windows OS. When a program is executed, the shim cache is referenced to determine if the program requires the use of the shim database (.sdb). If so, the shim database uses hooking to redirect the code as necessary in order to communicate with the OS. \n\nA list of all shims currently installed by the default Windows installer (sdbinst.exe) is kept in:\n\n* <code>%WINDIR%\\AppPatch\\sysmain.sdb</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\installedsdb</code>\n\nCustom databases are stored in:\n\n* <code>%WINDIR%\\AppPatch\\custom & %WINDIR%\\AppPatch\\AppPatch64\\Custom</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\custom</code>\n\nTo keep shims secure, Windows designed them to run in user mode so they cannot modify the kernel and you must have administrator privileges to install a shim. However, certain shims can be used to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002) (UAC and RedirectEXE), inject DLLs into processes (InjectDLL), disable Data Execution Prevention (DisableNX) and Structure Exception Handling (DisableSEH), and intercept memory addresses (GetProcAddress).\n\nUtilizing these shims may allow an adversary to perform several malicious acts such as elevate privileges, install backdoors, disable defenses like Windows Defender, etc. (Citation: FireEye Application Shimming) Shims can also be abused to establish persistence by continuously being invoked by affected programs.",
                    "description_jp": "攻撃者は、アプリケーションシムによって引き起こされる悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。Microsoft Windows Application Compatibility Infrastructure/Framework（アプリケーションシム）は、オペレーティングシステムのコードベースが時とともに変化する中で、ソフトウェアの後方互換性を可能にするために作成されました。例えば、アプリケーションシム機能により、開発者はWindows XP用に作成されたアプリケーションに（コードを書き換えることなく）修正を適用し、Windows 10でも動作するようにすることができる。(引用：Elastic Process Injection 2017年7月号）\n\nフレームワーク内では、シムはプログラム（より具体的にはインポートアドレステーブル）とWindows OSの間のバッファとして機能するように作成されます。プログラムが実行されると、シムキャッシュが参照され、プログラムがシムデータベース（.sdb）の使用を必要とするかどうかが判断されます。もしそうであれば、シムデータベースはフッキングを使用して、OSと通信するために必要に応じてコードをリダイレクトします。\n\nデフォルトのWindowsインストーラー（sdbinst.exe）によって現在インストールされているすべてのシムのリストは、以下に保持されています：\n\n* <code>%WINDIR%\\AppPatch\\sysmain.sdb</code> および\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\installedsdb</code>\n\nカスタムデータベースは以下に保存されます：\n\n* <code>%WINDIR%\\AppPatch\\custom & %WINDIR%\\AppPatch\\AppPatch64\\Custom</code> および\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\custom</code>\n\nシムの安全性を保つため、Windows はシムをユーザーモードで実行するように設計しているため、シムはカーネルを変更できず、シムをインストールするには管理者権限が必要です。しかし、特定のシムは[ユーザーアカウント制御のバイパス](https://attack.mitre.org/techniques/T1548/002)（UACおよびRedirectEXE）、プロセスへのDLLの注入（InjectDLL）、データ実行防止（DisableNX）および構造化例外処理（DisableSEH）の無効化、およびメモリアドレスの傍受（GetProcAddress）に使用できます。\n\nこれらのシムを利用することで、敵は特権の昇格、バックドアのインストール、Windows Defenderのような防御機能の無効化など、いくつかの悪意のある行為を実行できる可能性がある（引用：FireEye Application Shimming）。シムはまた、影響を受けるプログラムから継続的に呼び出されることで、永続性を確立するために悪用される可能性もある。"
                },
                {
                    "id": "T1546.015",
                    "name_eng": "Component Object Model Hijacking",
                    "name_jp": "コンポーネントオブジェクトモデルハイジャック",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by hijacked references to Component Object Model (COM) objects. COM is a system within Windows to enable interaction between software components through the operating system.(Citation: Microsoft Component Object Model)  References to various COM objects are stored in the Registry. \n\nAdversaries can use the COM system to insert malicious code that can be executed in place of legitimate software through hijacking the COM references and relationships as a means for persistence. Hijacking a COM object requires a change in the Registry to replace a reference to a legitimate system component which may cause that component to not work when executed. When that system component is executed through normal system operation the adversary's code will be executed instead.(Citation: GDATA COM Hijacking) An adversary is likely to hijack objects that are used frequently enough to maintain a consistent level of persistence, but are unlikely to break noticeable functionality within the system as to avoid system instability that could lead to detection.",
                    "description_jp": "攻撃者は、Component Object Model（COM）オブジェクトへのハイジャックされた参照をトリガーとして悪意のあるコンテンツを実行することで、永続性を確立する可能性があります。COM は、オペレーティング・システムを通じてソフトウェア・コンポーネント間の相互作用を可能にする Windows 内のシステムである（引用：Microsoft Component Object Model） 様々な COM オブジェクトへの参照は、レジストリに格納される。\n\n攻撃者は COM システムを利用し、永続化の手段として COM の参照とリレーションシップをハイジャックすることで、正当なソフトウェアの代わりに実行可能な悪意のあるコードを挿入することができます。COM オブジェクトをハイジャックするには、レジストリを変更し、正規のシステム・コンポーネントへの参照を置き換える必要があります。これにより、実行時にそのコンポーネントが機能しなくなる可能性があります。そのシステムコンポーネントが通常のシステム操作を通じて実行されると、代わりに攻撃者のコードが実行されます。(引用：GDATA COM Hijacking）敵対者は、一貫したレベルの永続性を維持するのに十分な頻度で使用されるオブジェクトをハイジャックする可能性が高いが、検知につながる可能性のあるシステムの不安定性を回避するため、システム内の顕著な機能を破壊する可能性は低い。"
                },
                {
                    "id": "T1546.004",
                    "name_eng": "Unix Shell Configuration Modification",
                    "name_jp": "Unixシェル設定変更",
                    "description_eng": "Adversaries may establish persistence through executing malicious commands triggered by a user’s shell. User [Unix Shell](https://attack.mitre.org/techniques/T1059/004)s execute several configuration scripts at different points throughout the session based on events. For example, when a user opens a command-line interface or remotely logs in (such as via SSH) a login shell is initiated. The login shell executes scripts from the system (<code>/etc</code>) and the user’s home directory (<code>~/</code>) to configure the environment. All login shells on a system use /etc/profile when initiated. These configuration scripts run at the permission level of their directory and are often used to set environment variables, create aliases, and customize the user’s environment. When the shell exits or terminates, additional shell scripts are executed to ensure the shell exits appropriately. \n\nAdversaries may attempt to establish persistence by inserting commands into scripts automatically executed by shells. Using bash as an example, the default shell for most GNU/Linux systems, adversaries may add commands that launch malicious binaries into the <code>/etc/profile</code> and <code>/etc/profile.d</code> files.(Citation: intezer-kaiji-malware)(Citation: bencane blog bashrc) These files typically require root permissions to modify and are executed each time any shell on a system launches. For user level permissions, adversaries can insert malicious commands into <code>~/.bash_profile</code>, <code>~/.bash_login</code>, or <code>~/.profile</code> which are sourced when a user opens a command-line interface or connects remotely.(Citation: anomali-rocke-tactics)(Citation: Linux manual bash invocation) Since the system only executes the first existing file in the listed order, adversaries have used <code>~/.bash_profile</code> to ensure execution. Adversaries have also leveraged the <code>~/.bashrc</code> file which is additionally executed if the connection is established remotely or an additional interactive shell is opened, such as a new tab in the command-line interface.(Citation: Tsunami)(Citation: anomali-rocke-tactics)(Citation: anomali-linux-rabbit)(Citation: Magento) Some malware targets the termination of a program to trigger execution, adversaries can use the <code>~/.bash_logout</code> file to execute malicious commands at the end of a session. \n\nFor macOS, the functionality of this technique is similar but may leverage zsh, the default shell for macOS 10.15+. When the Terminal.app is opened, the application launches a zsh login shell and a zsh interactive shell. The login shell configures the system environment using <code>/etc/profile</code>, <code>/etc/zshenv</code>, <code>/etc/zprofile</code>, and <code>/etc/zlogin</code>.(Citation: ScriptingOSX zsh)(Citation: PersistentJXA_leopitt)(Citation: code_persistence_zsh)(Citation: macOS MS office sandbox escape) The login shell then configures the user environment with <code>~/.zprofile</code> and <code>~/.zlogin</code>. The interactive shell uses the <code>~/.zshrc</code> to configure the user environment. Upon exiting, <code>/etc/zlogout</code> and <code>~/.zlogout</code> are executed. For legacy programs, macOS executes <code>/etc/bashrc</code> on startup.",
                    "description_jp": "攻撃者は、ユーザのシェルによって引き起こされる悪意のあるコマンドを実行することで、永続性を確立することができる。ユーザーの[Unix Shell](https://attack.mitre.org/techniques/T1059/004)は、イベントに基づいてセッション中の異なる時点でいくつかの設定スクリプトを実行します。例えば、ユーザがコマンドラインインターフェースを開いたり、(SSH経由などで)リモートログインすると、ログインシェルが起動します。ログインシェルはシステム (<code>/etc</code>) とユーザーのホームディレクトリ (<code>~/</code>) からスクリプトを実行して環境を設定します。システム上のすべてのログインシェルは、起動時に /etc/profile を使用します。これらの設定スクリプトは、そのディレクトリの権限レベルで実行され、環境変数の設定、エイリアスの作成、ユーザー環境のカスタマイズによく使われます。シェルが終了または終了すると、シェルが適切に終了するように、追加のシェルスクリプトが実行されます。\n\n攻撃者は、シェルによって自動的に実行されるスクリプトにコマンドを挿入することで、永続性を確立しようとする場合がある。ほとんどのGNU/Linuxシステムのデフォルトシェルであるbashを例にとると、敵対者は悪意のあるバイナリを起動するコマンドを<code>/etc/profile</code>ファイルと<code>/etc/profile.d</code>ファイルに追加する可能性があります。(引用：intezer-kaiji-malware)(引用：bencane blog bashrc) これらのファイルは通常、変更するためにrootパーミッションを必要とし、システム上のシェルが起動するたびに実行されます。ユーザーレベルのパーミッションの場合、敵対者は悪意のあるコマンドを <code>~/.bash_profile</code>、<code>~/.bash_login</code>、<code>~/.profile</code> に挿入することができます。(引用: anomali-rocke-tactics)(Citation: Linux manual bash invocation) システムはリストされた順序で最初に存在するファイルのみを実行するので、敵対者は実行を確実にするために<code>~/.bash_profile</code>を使用してきました。敵はまた、リモートで接続が確立されたり、コマンドラインインターフェイスの新しいタブなど、追加の対話型シェルが開かれた場合に追加で実行される<code>~/.bashrc</code>ファイルも活用しています。(引用：Tsunami)(引用：anomali-rocke-tactics)(引用：anomali-linux-rabbit)(引用：Magento) 実行をトリガーするためにプログラムの終了をターゲットにするマルウェアもあり、敵対者は <code>~/.bash_logout</code> ファイルを使用して、セッションの終了時に悪意のあるコマンドを実行することができます。\n\nmacOSの場合、このテクニックの機能は似ていますが、macOS 10.15+のデフォルトシェルであるzshを活用する可能性があります。Terminal.appを開くと、アプリケーションはzshログインシェルとzsh対話シェルを起動します。ログインシェルは、<code>/etc/profile</code>、<code>/etc/zshenv</code>、<code>/etc/zprofile</code>、<code>/etc/zlogin</code>を使用してシステム環境を設定します。(Citation: ScriptingOSX zsh)(Citation: PersistentJXA_leopitt)(Citation: code_persistence_zsh)(Citation: macOS MS office sandbox escape) ログインシェルは、<code>~/.zprofile</code>と<code>~/.zlogin</code>でユーザー環境を設定します。対話型シェルは <code>~/.zshrc</code> を使ってユーザー環境を設定します。終了時には、<code>/etc/zlogout</code>と<code>~/.zlogout</code>が実行されます。レガシープログラムでは、macOSは起動時に<code>/etc/bashrc</code>を実行する。"
                },
                {
                    "id": "T1546.010",
                    "name_eng": "AppInit DLLs",
                    "name_jp": "AppInit DLL",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppInit_DLLs</code> value in the Registry keys <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> or <code>HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> are loaded by user32.dll into every process that loads user32.dll. In practice this is nearly every program, since user32.dll is a very common library. (Citation: Elastic Process Injection July 2017)\n\nSimilar to Process Injection, these values can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. (Citation: AppInit Registry) Malicious AppInit DLLs may also provide persistence by continuously being triggered by API activity. \n\nThe AppInit DLL functionality is disabled in Windows 8 and later versions when secure boot is enabled. (Citation: AppInit Secure Boot)",
                    "description_jp": "攻撃者は、プロセスにロードされた AppInit DLL をトリガーとして悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。レジストリキー <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> または <code>HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> の <code>AppInit_DLLs</code> 値で指定されているダイナミックリンクライブラリ (DLL) は、user32.dll をロードするすべてのプロセスにロードされます。dllは、user32.dllをロードするすべてのプロセスにロードされる。user32.dllは非常に一般的なライブラリであるため、実際にはほとんどすべてのプログラムにロードされます。(引用：Elastic Process Injection 2017年7月号）\n\n[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)と同様に、これらの値を悪用して悪意のあるDLLをロードさせ、コンピュータ上の別のプロセスのコンテキストで実行させることで、昇格した特権を取得することができます。(引用：AppInit Registry） また、悪意のあるAppInit DLLは、APIアクティビティによって継続的にトリガーされることで、永続性を提供する可能性もある。\n\nWindows 8 以降のバージョンでは、セキュアブートが有効になっている場合、AppInit DLL の機能は無効になります。(引用：AppInit セキュアブート）"
                },
                {
                    "id": "T1546.005",
                    "name_eng": "Trap",
                    "name_jp": "トラップ",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by an interrupt signal. The <code>trap</code> command allows programs and shells to specify commands that will be executed upon receiving interrupt signals. A common situation is a script allowing for graceful termination and handling of common keyboard interrupts like <code>ctrl+c</code> and <code>ctrl+d</code>.\n\nAdversaries can use this to register code to be executed when the shell encounters specific interrupts as a persistence mechanism. Trap commands are of the following format <code>trap 'command list' signals</code> where \"command list\" will be executed when \"signals\" are received.(Citation: Trap Manual)(Citation: Cyberciti Trap Statements)",
                    "description_jp": "攻撃者は、割り込みシグナルをトリガーとして悪意のあるコンテンツを実行することで、永続性を確立することができる。<code>trap</code>コマンドは、プログラムやシェルが割り込みシグナルを受信したときに実行されるコマンドを指定できるようにします。よくある状況は、<code>ctrl+c</code> や <code>ctrl+d</code>のような一般的なキーボード割り込みの優雅な終了と処理を可能にするスクリプトです。\n\n攻撃者はこれを利用して、シェルが特定の割り込みに遭遇したときに実行するコードを、永続化メカニズムとして登録することができる。トラップコマンドは以下の形式である。 <code>trap 'command list' signals</code> ここで、「command list」は「signals」を受信したときに実行される。(引用：トラップマニュアル)(引用：Cyberciti Trap Statements)"
                },
                {
                    "id": "T1546.007",
                    "name_eng": "Netsh Helper DLL",
                    "name_jp": "NetshヘルパーDLL",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by Netsh Helper DLLs. Netsh.exe (also referred to as Netshell) is a command-line scripting utility used to interact with the network configuration of a system. It contains functionality to add helper DLLs for extending functionality of the utility.(Citation: TechNet Netsh) The paths to registered netsh.exe helper DLLs are entered into the Windows Registry at <code>HKLM\\SOFTWARE\\Microsoft\\Netsh</code>.\n\nAdversaries can use netsh.exe helper DLLs to trigger execution of arbitrary code in a persistent manner. This execution would take place anytime netsh.exe is executed, which could happen automatically, with another persistence technique, or if other software (ex: VPN) is present on the system that executes netsh.exe as part of its normal functionality.(Citation: Github Netsh Helper CS Beacon)(Citation: Demaske Netsh Persistence)",
                    "description_jp": "攻撃者は、Netsh Helper DLL によって引き起こされる悪意のあるコンテンツを実行することで、永続性を確立する可能性があります。Netsh.exe (Netshell とも呼ばれる) は、システムのネットワーク構成と対話するために使用されるコマンドライン スクリプト ユーティリティです。このユーティリティには、ユーティリティの機能を拡張するためのヘルパー DLL を追加する機能が含まれています (引用: TechNet Netsh)。登録された netsh.exe ヘルパー DLL へのパスは、Windows レジストリの <code>HKLM\\SOFTWARE\\Microsoft\\Netsh</code> に入力されます。\n\n攻撃者は、netsh.exeヘルパーDLLを使用して、任意のコードを持続的に実行させることができる。この実行は、netsh.exeが実行されればいつでも行われることになり、自動的、別の永続化手法、または通常の機能の一部としてnetsh.exeを実行する他のソフトウェア（例：VPN）がシステム上に存在する場合に発生する可能性がある。(引用：Github Netsh Helper CS Beacon）（引用：Demaske Netsh Persistence）。"
                },
                {
                    "id": "T1546.012",
                    "name_eng": "Image File Execution Options Injection",
                    "name_jp": "イメージファイル実行オプションインジェクション",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by Image File Execution Options (IFEO) debuggers. IFEOs enable a developer to attach a debugger to an application. When a process is created, a debugger present in an application’s IFEO will be prepended to the application’s name, effectively launching the new process under the debugger (e.g., <code>C:\\dbg\\ntsd.exe -g  notepad.exe</code>). (Citation: Microsoft Dev Blog IFEO Mar 2010)\n\nIFEOs can be set directly via the Registry or in Global Flags via the GFlags tool. (Citation: Microsoft GFlags Mar 2017) IFEOs are represented as <code>Debugger</code> values in the Registry under <code>HKLM\\SOFTWARE{\\Wow6432Node}\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\<executable></code> where <code>&lt;executable&gt;</code> is the binary on which the debugger is attached. (Citation: Microsoft Dev Blog IFEO Mar 2010)\n\nIFEOs can also enable an arbitrary monitor program to be launched when a specified program silently exits (i.e. is prematurely terminated by itself or a second, non kernel-mode process). (Citation: Microsoft Silent Process Exit NOV 2017) (Citation: Oddvar Moe IFEO APR 2018) Similar to debuggers, silent exit monitoring can be enabled through GFlags and/or by directly modifying IFEO and silent process exit Registry values in <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\</code>. (Citation: Microsoft Silent Process Exit NOV 2017) (Citation: Oddvar Moe IFEO APR 2018)\n\nSimilar to [Accessibility Features](https://attack.mitre.org/techniques/T1546/008), on Windows Vista and later as well as Windows Server 2008 and later, a Registry key may be modified that configures \"cmd.exe,\" or another program that provides backdoor access, as a \"debugger\" for an accessibility program (ex: utilman.exe). After the Registry is modified, pressing the appropriate key combination at the login screen while at the keyboard or when connected with [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) will cause the \"debugger\" program to be executed with SYSTEM privileges. (Citation: Tilbury 2014)\n\nSimilar to [Process Injection](https://attack.mitre.org/techniques/T1055), these values may also be abused to obtain privilege escalation by causing a malicious executable to be loaded and run in the context of separate processes on the computer. (Citation: Elastic Process Injection July 2017) Installing IFEO mechanisms may also provide Persistence via continuous triggered invocation.\n\nMalware may also use IFEO to [Impair Defenses](https://attack.mitre.org/techniques/T1562) by registering invalid debuggers that redirect and effectively disable various system and security applications. (Citation: FSecure Hupigon) (Citation: Symantec Ushedix June 2008)",
                    "description_jp": "攻撃者は、イメージファイル実行オプション（IFEO）デバッガによって引き起こされる悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。IFEO は、開発者がアプリケーションにデバッガをアタッチすることを可能にします。プロセスが作成されると、アプリケーションの IFEO に存在するデバッガーがアプリケーション名の前に追加され、デバッガーの下で新しいプロセスが効果的に起動されます (例: <code>C:\\dbg\\ntsd.exe -g  notepad.exe</code>)。(引用: Microsoft Dev Blog IFEO Mar 2010)\n\nIFEOは、レジストリを介して直接設定するか、GFlagsツールを介してグローバルフラグに設定することができます。(引用: Microsoft GFlags Mar 2017) IFEO は、レジストリの <code>HKLM\\SOFTWARE{\\Wow6432Node}\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\<executable></code> の <code>Debugger</code> 値として表され、<code>&lt;executable&gt;</code> はデバッガーがアタッチされているバイナリです。(引用：Microsoft Dev Blog IFEO Mar 2010）\n\nIFEO を使用すると、指定したプログラムがサイレント終了 (それ自身または 2 番目の非カーネル モード プロセスによって早期終了) したときに、任意のモニター プログラムを起動することもできます。(引用: Microsoft Silent Process Exit NOV 2017) (引用: Oddvar Moe IFEO APR 2018) デバッガーと同様に、サイレント終了監視は、GFlags を通して、または <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\</code>のIFEOおよびサイレント終了レジストリ値を直接変更することによって有効にすることができます。(引用：Microsoft Silent Process Exit NOV 2017）（引用：Oddvar Moe IFEO APR 2018）\n\n[アクセシビリティ機能](https://attack.mitre.org/techniques/T1546/008)と同様に、Windows Vista以降およびWindows Server 2008以降では、「cmd.exe」またはバックドアアクセスを提供する別のプログラムを、アクセシビリティプログラム(ex: utilman.exe)の「デバッガ」として設定するレジストリキーが変更される可能性があります。レジストリが変更された後、キーボードを操作しているときにログイン画面で適切なキーの組み合わせを押すか、[リモート・デスクトップ・プロトコル](https://attack.mitre.org/techniques/T1021/001)で接続すると、「デバッガー」プログラムがSYSTEM権限で実行されるようになります。(引用：ティルベリー2014）\n\n[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)と同様に、これらの値を悪用して、悪意のある実行ファイルをコンピュータ上の別のプロセスのコンテキストで読み込ませて実行させることで、特権の昇格を得ることもできます。(引用: Elastic Process Injection July 2017) IFEO メカニズムをインストールすることは、継続的なトリガー呼び出しによって永続性を提供する可能性もある。\n\nまた、マルウェアはIFEOを使用して、様々なシステムやセキュリティアプリケーションをリダイレクトし、効果的に無効にする無効なデバッガを登録することで、[防御の阻害](https://attack.mitre.org/techniques/T1562)を行う可能性があります。(引用：FSecure Hupigon) (引用：Symantec Ushedix June 2008)"
                },
                {
                    "id": "T1546.001",
                    "name_eng": "Change Default File Association",
                    "name_jp": "デフォルトのファイル関連付けの変更",
                    "description_eng": "Adversaries may establish persistence by executing malicious content triggered by a file type association. When a file is opened, the default program used to open the file (also called the file association or handler) is checked. File association selections are stored in the Windows Registry and can be edited by users, administrators, or programs that have Registry access or by administrators using the built-in assoc utility.(Citation: Microsoft Change Default Programs)(Citation: Microsoft File Handlers)(Citation: Microsoft Assoc Oct 2017) Applications can modify the file association for a given file extension to call an arbitrary program when a file with the given extension is opened.\n\nSystem file associations are listed under <code>HKEY_CLASSES_ROOT\\.[extension]</code>, for example <code>HKEY_CLASSES_ROOT\\.txt</code>. The entries point to a handler for that extension located at <code>HKEY_CLASSES_ROOT\\\\[handler]</code>. The various commands are then listed as subkeys underneath the shell key at <code>HKEY_CLASSES_ROOT\\\\[handler]\\shell\\\\[action]\\command</code>. For example: \n\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\open\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\print\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\printto\\command</code>\n\nThe values of the keys listed are commands that are executed when the handler opens the file extension. Adversaries can modify these values to continually execute arbitrary commands.(Citation: TrendMicro TROJ-FAKEAV OCT 2012)",
                    "description_jp": "攻撃者は、ファイルタイプの関連付けをトリガーとして悪意のあるコンテンツを実行することで、永続性を確立する可能性がある。ファイルを開くと、そのファイルを開くために使用されるデフォルトのプログラム（ファイルの関連付けまたはハンドラとも呼ばれる）がチェックされる。ファイルの関連付けの選択は Windows レジストリに保存され、レジストリにアクセスできるユーザー、管理者、プログラム、または管理者が組み込みの assoc ユーティリティを使用して編集することができます。(引用: Microsoft Change Default Programs)(Citation: Microsoft File Handlers)(Citation: Microsoft Assoc Oct 2017) アプリケーションは、指定された拡張子のファイルが開かれたときに任意のプログラムを呼び出すように、指定された拡張子のファイルの関連付けを変更することができます。\n\nシステムファイルの関連付けは、<code>HKEY_CLASSES_ROOT\\.[extension]</code>の下にリストされており、例えば<code>HKEY_CLASSES_ROOT\\.txt</code>のようになる。エントリは、<code>HKEY_CLASSES_ROOT\\\\[handler]</code>にあるその拡張のハンドラを指す。そして、様々なコマンドは、<code>HKEY_CLASSES_ROOT\\\\[handler]\\shell\\\\[action]\\command</code>にあるシェルキーの下のサブキーとしてリストされる。例えば：\n\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\open\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\print\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\printto\\command</code>\n\n列挙されたキーの値は、ハンドラーがファイル拡張子を開いたときに実行されるコマンドである。攻撃者はこれらの値を変更することで、任意のコマンドを継続的に実行することができます。(引用: TrendMicro TROJ-FAKEAV OCT 2012)"
                },
                {
                    "id": "T1546.009",
                    "name_eng": "AppCert DLLs",
                    "name_jp": "AppCert DLL",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppCert DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppCertDLLs</code> Registry key under <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\</code> are loaded into every process that calls the ubiquitously used application programming interface (API) functions <code>CreateProcess</code>, <code>CreateProcessAsUser</code>, <code>CreateProcessWithLoginW</code>, <code>CreateProcessWithTokenW</code>, or <code>WinExec</code>. (Citation: Elastic Process Injection July 2017)\n\nSimilar to [Process Injection](https://attack.mitre.org/techniques/T1055), this value can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. Malicious AppCert DLLs may also provide persistence by continuously being triggered by API activity.",
                    "description_jp": "攻撃者は、プロセスにロードされたAppCert DLLをトリガーとして悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性があります。<code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\</code>下の<code>AppCertDLLs</code>レジストリキーで指定されるダイナミックリンクライブラリ（DLL）は、広く使用されているアプリケーションプログラミングインターフェース（API）関数<code>CreateProcess</code>、<code>CreateProcessAsUser</code>、<code>CreateProcessWithLoginW</code>、<code>CreateProcessWithTokenW</code>、または<code>WinExec</code>を呼び出すすべてのプロセスにロードされます。(引用：Elastic Process Injection 2017年7月号）\n\n[プロセスインジェクション](https://attack.mitre.org/techniques/T1055)と同様に、この値を悪用して、悪意のあるDLLをロードさせ、コンピュータ上の別のプロセスのコンテキストで実行させることで、昇格した特権を取得することができます。また、悪意のあるAppCert DLLは、APIアクティビティによって継続的にトリガーされることで、永続性を提供する可能性もある。"
                },
                {
                    "id": "T1546.017",
                    "name_eng": "Udev Rules",
                    "name_jp": "Udevルール",
                    "description_eng": "Adversaries may maintain persistence through executing malicious content triggered using udev rules. Udev is the Linux kernel device manager that dynamically manages device nodes, handles access to pseudo-device files in the `/dev` directory, and responds to hardware events, such as when external devices like hard drives or keyboards are plugged in or removed. Udev uses rule files with `match keys` to specify the conditions a hardware event must meet and `action keys` to define the actions that should follow. Root permissions are required to create, modify, or delete rule files located in `/etc/udev/rules.d/`, `/run/udev/rules.d/`, `/usr/lib/udev/rules.d/`, `/usr/local/lib/udev/rules.d/`, and `/lib/udev/rules.d/`. Rule priority is determined by both directory and by the digit prefix in the rule filename.(Citation: Ignacio Udev research 2024)(Citation: Elastic Linux Persistence 2024)\n\nAdversaries may abuse the udev subsystem by adding or modifying rules in udev rule files to execute malicious content. For example, an adversary may configure a rule to execute their binary each time the pseudo-device file, such as `/dev/random`, is accessed by an application. Although udev is limited to running short tasks and is restricted by systemd-udevd's sandbox (blocking network and filesystem access), attackers may use scripting commands under the action key `RUN+=` to detach and run the malicious content’s process in the background to bypass these controls.(Citation: Reichert aon sedexp 2024)",
                    "description_jp": "攻撃者は、udev ルールを使用してトリガーされた悪意のあるコンテンツを実行することで、永続性を維持する可能性があります。Udev は Linux カーネルのデバイス・マネージャーで、デバイス・ノードを動的に管理し、`/dev` ディレクトリにある擬似デバイス・ファイルへのアクセスを処理し、ハード・ドライブやキーボードなどの外部デバイスが接続されたり取り外されたりしたときのようなハードウェア・イベントに応答します。Udev は `match キー` でハードウェアイベントが満たすべき条件を指定し、`action キー` でその後のアクションを定義するルールファイルを使用する。`/etc/udev/rules.d/`、`/run/udev/rules.d/`、`/usr/lib/udev/rules.d/`、`/usr/local/lib/udev/rules.d/`、`/lib/udev/rules.d/` にあるルールファイルを作成、変更、削除するには root 権限が必要です。ルールの優先順位は、ディレクトリと、ルールファイル名に含まれる数字のプレフィックスによって決まる。(引用: Ignacio Udev research 2024)(Citation: Elastic Linux Persistence 2024)\n\n攻撃者は、悪意のあるコンテンツを実行するためにudevルールファイルにルールを追加または変更することで、udevサブシステムを悪用する可能性があります。例えば、敵は `/dev/random` のような疑似デバイスファイルがアプリケーションによってアクセスされるたびに、自分のバイナリを実行するようにルールを設定するかもしれません。udevは短いタスクの実行に制限されており、systemd-udevdのサンドボックス（ネットワークとファイルシステムへのアクセスをブロック）によって制限されていますが、攻撃者はアクションキー`RUN+=`の下でスクリプトコマンドを使用して、これらの制御をバイパスするためにバックグラウンドで悪意のあるコンテンツのプロセスを切り離して実行することができます（引用：Reichert aon sedexp 2024）。"
                },
                {
                    "id": "T1546.014",
                    "name_eng": "Emond",
                    "name_jp": "Emond",
                    "description_eng": "Adversaries may gain persistence and elevate privileges by executing malicious content triggered by the Event Monitor Daemon (emond). Emond is a [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) that accepts events from various services, runs them through a simple rules engine, and takes action. The emond binary at <code>/sbin/emond</code> will load any rules from the <code>/etc/emond.d/rules/</code> directory and take action once an explicitly defined event takes place.\n\nThe rule files are in the plist format and define the name, event type, and action to take. Some examples of event types include system startup and user authentication. Examples of actions are to run a system command or send an email. The emond service will not launch if there is no file present in the QueueDirectories path <code>/private/var/db/emondClients</code>, specified in the [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) configuration file at<code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>.(Citation: xorrior emond Jan 2018)(Citation: magnusviri emond Apr 2016)(Citation: sentinelone macos persist Jun 2019)\n\nAdversaries may abuse this service by writing a rule to execute commands when a defined event occurs, such as system start up or user authentication.(Citation: xorrior emond Jan 2018)(Citation: magnusviri emond Apr 2016)(Citation: sentinelone macos persist Jun 2019) Adversaries may also be able to escalate privileges from administrator to root as the emond service is executed with root privileges by the [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) service.",
                    "description_jp": "攻撃者は、Event Monitor Daemon (emond)によってトリガーされた悪意のあるコンテンツを実行することで、永続性を獲得し、特権を昇格させる可能性がある。emondは[起動デーモン](https://attack.mitre.org/techniques/T1543/004)であり、様々なサービスからイベントを受け取り、シンプルなルールエンジンを通して実行し、アクションを起こします。<code>/sbin/emond</code> にある emond バイナリは、<code>/etc/emond.d/rules/</code> ディレクトリから任意のルールをロードし、明示的に定義されたイベントが発生するとアクションを実行します。\n\nルールファイルは plist 形式で、名前、イベントタイプ、実行するアクションを定義します。イベントタイプの例としては、システムの起動やユーザー認証などがあります。アクションの例としては、システムコマンドの実行や電子メールの送信などがあります。<code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>にある[起動デーモン](https://attack.mitre.org/techniques/T1543/004)設定ファイルで指定されたQueueDirectoriesパス<code>/private/var/db/emondClients</code>にファイルが存在しない場合、emondサービスは起動しません。(引用: xorrior emond 2018年1月)(引用: magnusviri emond 2016年4月)(引用: sentinelone macos persist 2019年6月)\n\nシステム起動やユーザー認証など、定義されたイベントが発生したときにコマンドを実行するルールを記述することで、このサービスを悪用する可能性がある(引用: xorrior emond 2018年1月)(引用: magnusviri emond 2016年4月)(引用: sentinelone macos persist 2019年6月) また、emondサービスは[起動デーモン](https://attack.mitre.org/techniques/T1543/004) サービスによってroot権限で実行されるため、悪用者は管理者からrootに権限を昇格させることができる可能性がある。"
                },
                {
                    "id": "T1546.008",
                    "name_eng": "Accessibility Features",
                    "name_jp": "アクセシビリティ機能",
                    "description_eng": "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by accessibility features. Windows contains accessibility features that may be launched with a key combination before a user has logged in (ex: when the user is on the Windows logon screen). An adversary can modify the way these programs are launched to get a command prompt or backdoor without logging in to the system.\n\nTwo common accessibility programs are <code>C:\\Windows\\System32\\sethc.exe</code>, launched when the shift key is pressed five times and <code>C:\\Windows\\System32\\utilman.exe</code>, launched when the Windows + U key combination is pressed. The sethc.exe program is often referred to as \"sticky keys\", and has been used by adversaries for unauthenticated access through a remote desktop login screen. (Citation: FireEye Hikit Rootkit)\n\nDepending on the version of Windows, an adversary may take advantage of these features in different ways. Common methods used by adversaries include replacing accessibility feature binaries or pointers/references to these binaries in the Registry. In newer versions of Windows, the replaced binary needs to be digitally signed for x64 systems, the binary must reside in <code>%systemdir%\\</code>, and it must be protected by Windows File or Resource Protection (WFP/WRP). (Citation: DEFCON2016 Sticky Keys) The [Image File Execution Options Injection](https://attack.mitre.org/techniques/T1546/012) debugger method was likely discovered as a potential workaround because it does not require the corresponding accessibility feature binary to be replaced.\n\nFor simple binary replacement on Windows XP and later as well as and Windows Server 2003/R2 and later, for example, the program (e.g., <code>C:\\Windows\\System32\\utilman.exe</code>) may be replaced with \"cmd.exe\" (or another program that provides backdoor access). Subsequently, pressing the appropriate key combination at the login screen while sitting at the keyboard or when connected over [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) will cause the replaced file to be executed with SYSTEM privileges. (Citation: Tilbury 2014)\n\nOther accessibility features exist that may also be leveraged in a similar fashion: (Citation: DEFCON2016 Sticky Keys)(Citation: Narrator Accessibility Abuse)\n\n* On-Screen Keyboard: <code>C:\\Windows\\System32\\osk.exe</code>\n* Magnifier: <code>C:\\Windows\\System32\\Magnify.exe</code>\n* Narrator: <code>C:\\Windows\\System32\\Narrator.exe</code>\n* Display Switcher: <code>C:\\Windows\\System32\\DisplaySwitch.exe</code>\n* App Switcher: <code>C:\\Windows\\System32\\AtBroker.exe</code>",
                    "description_jp": "攻撃者は、アクセシビリティ機能をトリガーとして悪意のあるコンテンツを実行することで、永続性を確立したり、特権を昇格させたりする可能性がある。Windowsには、ユーザがログインする前（例：ユーザがWindowsのログオン画面にいるとき）に、キーの組み合わせで起動できるアクセシビリティ機能があります。敵は、これらのプログラムの起動方法を変更することで、システムにログインせずにコマンドプロンプトやバックドアを取得することができます。\n\n一般的なアクセシビリティプログラムは、シフトキーを5回押したときに起動する<code>C:\\Windows\\System32\\sethc.exe</code>と、Windows + Uキーの組み合わせを押したときに起動する<code>C:\\Windows\\System32\\utilman.exe</code>の2つです。sethc.exeプログラムは、しばしば「スティッキーキー」と呼ばれ、敵対者によってリモートデスクトップのログイン画面を介して認証されていないアクセスに使用されている。(引用：FireEye Hikit Rootkit)\n\nWindowsのバージョンによって、敵対者はさまざまな方法でこれらの機能を利用する可能性がある。敵対者が使用する一般的な方法には、レジストリ内のアクセシビリティ機能のバイナリ、またはこれらのバイナリへのポインタ/参照を置き換えることが含まれます。Windows の新しいバージョンでは、置き換えられたバイナリは x64 システム用にデジタル署名されている必要があり、バイナリは <code>%systemdir%\\</code> に存在する必要があり、Windows File or Resource Protection (WFP/WRP) によって保護されている必要があります。(引用: DEFCON2016 Sticky Keys) [イメージファイル実行オプションインジェクション](https://attack.mitre.org/techniques/T1546/012)デバッガー手法は、対応するアクセシビリティ機能バイナリを置き換える必要がないため、潜在的な回避策として発見された可能性が高い。\n\nWindows XP以降やWindows Server 2003/R2以降での単純なバイナリの置き換えでは、例えば、プログラム（例えば、<code>C:\\Windows\\System32\\utilman.exe</code>）を「cmd.exe」（またはバックドアアクセスを提供する他のプログラム）に置き換えることができる。その後、キーボードの前に座った状態でログイン画面で適切なキーの組み合わせを押すか、[リモートデスクトッププロトコル](https://attack.mitre.org/techniques/T1021/001)で接続すると、置き換えられたファイルがSYSTEM権限で実行されます。(引用：Tilbury 2014）\n\n同様の方法で活用される可能性のある他のアクセシビリティ機能も存在する：(引用：DEFCON2016 Sticky Keys)(引用：Narrator Accessibility Abuse)\n\n* オンスクリーンキーボード：<code>C:\\Windows\\System32\\osk.exe</code>\n* 拡大鏡：<code>C:\\Windows\\System32\\Magnify.exe</code>\n* ナレーター：<code>C:\\Windows\\System32\\Narrator.exe</code>\n* ディスプレイスイッチャー：<code>C:\\Windows\\System32\\DisplaySwitch.exe</code>\n* App Switcher：<code>C:\\Windows\\System32\\AtBroker.exe</code>"
                }
            ]
        },
        {
            "id": "T1134",
            "name_eng": "Access Token Manipulation",
            "name_jp": "アクセストークン操作",
            "description_eng": "Adversaries may modify access tokens to operate under a different user or system security context to perform actions and bypass access controls. Windows uses access tokens to determine the ownership of a running process. A user can manipulate access tokens to make a running process appear as though it is the child of a different process or belongs to someone other than the user that started the process. When this occurs, the process also takes on the security context associated with the new token.\n\nAn adversary can use built-in Windows API functions to copy access tokens from existing processes; this is known as token stealing. These token can then be applied to an existing process (i.e. [Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001)) or used to spawn a new process (i.e. [Create Process with Token](https://attack.mitre.org/techniques/T1134/002)). An adversary must already be in a privileged user context (i.e. administrator) to steal a token. However, adversaries commonly use token stealing to elevate their security context from the administrator level to the SYSTEM level. An adversary can then use a token to authenticate to a remote system as the account for that token if the account has appropriate permissions on the remote system.(Citation: Pentestlab Token Manipulation)\n\nAny standard user can use the <code>runas</code> command, and the Windows API functions, to create impersonation tokens; it does not require access to an administrator account. There are also other mechanisms, such as Active Directory fields, that can be used to modify access tokens.",
            "description_jp": "攻撃者は、アクションを実行しアクセス制御をバイパスするために、異なるユーザーまたはシステムのセキュリティコンテキストで動作するようにアクセストークンを変更する可能性があります。Windowsはアクセストークンを使用して、実行中のプロセスの所有権を決定します。ユーザーはアクセストークンを操作して、実行中のプロセスを別のプロセスのサブプロセスであるかのように見せかけたり、プロセスを開始したユーザー以外の誰かに属しているかのように見せかけたりすることができます。これが発生すると、プロセスは新しいトークンに関連付けられたセキュリティコンテキストも引き継ぎます。\n\n攻撃者は、組み込みのWindows API関数を使用して既存のプロセスからアクセストークンをコピーできます。これはトークン窃取として知られています。これらのトークンは、既存のプロセスに適用したり（つまり、[トークン偽装/窃取](https://attack.mitre.org/techniques/T1134/001)）、新しいプロセスを生成するために使用したり（つまり、[トークンを使用したプロセスの作成](https://attack.mitre.org/techniques/T1134/002)）できます。攻撃者は、トークンを盗むためには既に特権ユーザーコンテキスト（つまり管理者）である必要があります。ただし、攻撃者は一般的に、管理者レベルからSYSTEMレベルにセキュリティコンテキストを昇格させるためにトークン窃取を使用します。アカウントがリモートシステム上で適切な権限を持っている場合、攻撃者はトークンを使用してそのトークンのアカウントとしてリモートシステムに認証できます。(引用: Pentestlab Token Manipulation)\n\n標準ユーザーは誰でも、<code>runas</code>コマンドおよびWindows API関数を使用して偽装トークンを作成できます。管理者アカウントへのアクセスは必要ありません。Active Directoryフィールドなど、アクセストークンを変更するために使用できる他のメカニズムもあります。",
            "subtechniques": [
                {
                    "id": "T1134.001",
                    "name_eng": "Token Impersonation/Theft",
                    "name_jp": "トークン偽装/窃取",
                    "description_eng": "Adversaries may duplicate then impersonate another user's existing token to escalate privileges and bypass access controls. For example, an adversary can duplicate an existing token using `DuplicateToken` or `DuplicateTokenEx`.(Citation: DuplicateToken function) The token can then be used with `ImpersonateLoggedOnUser` to allow the calling thread to impersonate a logged on user's security context, or with `SetThreadToken` to assign the impersonated token to a thread.\n\nAn adversary may perform [Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001) when they have a specific, existing process they want to assign the duplicated token to. For example, this may be useful for when the target user has a non-network logon session on the system.\n\nWhen an adversary would instead use a duplicated token to create a new process rather than attaching to an existing process, they can additionally [Create Process with Token](https://attack.mitre.org/techniques/T1134/002) using `CreateProcessWithTokenW` or `CreateProcessAsUserW`. [Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001) is also distinct from [Make and Impersonate Token](https://attack.mitre.org/techniques/T1134/003) in that it refers to duplicating an existing token, rather than creating a new one.",
                    "description_jp": "攻撃者は、権限を昇格させアクセス制御をバイパスするために、別のユーザーの既存のトークンを複製して偽装する可能性があります。例えば、攻撃者は`DuplicateToken`または`DuplicateTokenEx`を使用して既存のトークンを複製できます。(引用: DuplicateToken function) その後、トークンは`ImpersonateLoggedOnUser`と共に使用して呼び出しスレッドがログオンユーザーのセキュリティコンテキストを偽装できるようにするか、`SetThreadToken`と共に使用して偽装トークンをスレッドに割り当てることができます。\n\n攻撃者は、複製したトークンを割り当てたい特定の既存のプロセスがある場合に、[トークン偽装/窃取](https://attack.mitre.org/techniques/T1134/001)を実行する可能性があります。例えば、これはターゲットユーザーがシステム上で非ネットワークログオンセッションを持っている場合に役立つ可能性があります。\n\n攻撃者が既存のプロセスにアタッチするのではなく、複製したトークンを使用して新しいプロセスを作成する場合は、追加で`CreateProcessWithTokenW`または`CreateProcessAsUserW`を使用して[トークンを使用したプロセスの作成](https://attack.mitre.org/techniques/T1134/002)を行うことができます。[トークン偽装/窃取](https://attack.mitre.org/techniques/T1134/001)は、新しいトークンを作成するのではなく、既存のトークンを複製することを指すため、[トークンの作成と偽装](https://attack.mitre.org/techniques/T1134/003)とも区別されます。"
                },
                {
                    "id": "T1134.004",
                    "name_eng": "Parent PID Spoofing",
                    "name_jp": "親PIDスプーフィング",
                    "description_eng": "Adversaries may spoof the parent process identifier (PPID) of a new process to evade process-monitoring defenses or to elevate privileges. New processes are typically spawned directly from their parent, or calling, process unless explicitly specified. One way of explicitly assigning the PPID of a new process is via the <code>CreateProcess</code> API call, which supports a parameter that defines the PPID to use.(Citation: DidierStevens SelectMyParent Nov 2009) This functionality is used by Windows features such as User Account Control (UAC) to correctly set the PPID after a requested elevated process is spawned by SYSTEM (typically via <code>svchost.exe</code> or <code>consent.exe</code>) rather than the current user context.(Citation: Microsoft UAC Nov 2018)\n\nAdversaries may abuse these mechanisms to evade defenses, such as those blocking processes spawning directly from Office documents, and analysis targeting unusual/potentially malicious parent-child process relationships, such as spoofing the PPID of [PowerShell](https://attack.mitre.org/techniques/T1059/001)/[Rundll32](https://attack.mitre.org/techniques/T1218/011) to be <code>explorer.exe</code> rather than an Office document delivered as part of [Spearphishing Attachment](https://attack.mitre.org/techniques/T1566/001).(Citation: CounterCept PPID Spoofing Dec 2018) This spoofing could be executed via [Visual Basic](https://attack.mitre.org/techniques/T1059/005) within a malicious Office document or any code that can perform [Native API](https://attack.mitre.org/techniques/T1106).(Citation: CTD PPID Spoofing Macro Mar 2019)(Citation: CounterCept PPID Spoofing Dec 2018)\n\nExplicitly assigning the PPID may also enable elevated privileges given appropriate access rights to the parent process. For example, an adversary in a privileged user context (i.e. administrator) may spawn a new process and assign the parent as a process running as SYSTEM (such as <code>lsass.exe</code>), causing the new process to be elevated via the inherited access token.(Citation: XPNSec PPID Nov 2017)",
                    "description_jp": "攻撃者は、プロセス監視防御を回避したり権限を昇格させたりするために、新しいプロセスの親プロセス識別子（PPID）を偽装する可能性があります。新しいプロセスは、明示的に指定されない限り、通常、その親プロセスまたは呼び出し元プロセスから直接生成されます。新しいプロセスのPPIDを明示的に割り当てる1つの方法は、使用するPPIDを定義するパラメータをサポートする<code>CreateProcess</code> API呼び出しを介することです。(引用: DidierStevens SelectMyParent Nov 2009) この機能は、要求された昇格プロセスが現在のユーザーコンテキストではなくSYSTEM（通常は<code>svchost.exe</code>または<code>consent.exe</code>を介して）によって生成された後、PPIDを正しく設定するために、ユーザーアカウント制御（UAC）などのWindows機能によって使用されます。(引用: Microsoft UAC Nov 2018)\n\n攻撃者はこれらのメカニズムを悪用して、Officeドキュメントから直接生成されるプロセスをブロックするものなどの防御を回避したり、[スピアフィッシング添付ファイル](https://attack.mitre.org/techniques/T1566/001)の一部として配信されたOfficeドキュメントではなく<code>explorer.exe</code>であるかのように[PowerShell](https://attack.mitre.org/techniques/T1059/001)/[Rundll32](https://attack.mitre.org/techniques/T1218/011)のPPIDを偽装するなど、異常な/潜在的に悪意のある親子プロセス関係をターゲットとする分析を回避したりする可能性があります。(引用: CounterCept PPID Spoofing Dec 2018) この偽装は、悪意のあるOfficeドキュメント内の[Visual Basic](https://attack.mitre.org/techniques/T1059/005)または[ネイティブAPI](https://attack.mitre.org/techniques/T1106)を実行できる任意のコードを介して実行される可能性があります。(引用: CTD PPID Spoofing Macro Mar 2019)(引用: CounterCept PPID Spoofing Dec 2018)\n\nPPIDを明示的に割り当てることは、親プロセスへの適切なアクセス権があれば、昇格された権限を有効にすることもできます。例えば、特権ユーザーコンテキスト（つまり管理者）の攻撃者は、新しいプロセスを生成し、親をSYSTEMとして実行されているプロセス（<code>lsass.exe</code>など）として割り当てることで、継承されたアクセストークンを介して新しいプロセスを昇格させることができます。(引用: XPNSec PPID Nov 2017)"
                },
                {
                    "id": "T1134.005",
                    "name_eng": "SID-History Injection",
                    "name_jp": "SID履歴インジェクション",
                    "description_eng": "Adversaries may use SID-History Injection to escalate privileges and bypass access controls. The Windows security identifier (SID) is a unique value that identifies a user or group account. SIDs are used by Windows security in both security descriptors and access tokens. (Citation: Microsoft SID) An account can hold additional SIDs in the SID-History Active Directory attribute (Citation: Microsoft SID-History Attribute), allowing inter-operable account migration between domains (e.g., all values in SID-History are included in access tokens).\n\nWith Domain Administrator (or equivalent) rights, harvested or well-known SID values (Citation: Microsoft Well Known SIDs Jun 2017) may be inserted into SID-History to enable impersonation of arbitrary users/groups such as Enterprise Administrators. This manipulation may result in elevated access to local resources and/or access to otherwise inaccessible domains via lateral movement techniques such as [Remote Services](https://attack.mitre.org/techniques/T1021), [SMB/Windows Admin Shares](https://attack.mitre.org/techniques/T1021/002), or [Windows Remote Management](https://attack.mitre.org/techniques/T1021/006).",
                    "description_jp": "攻撃者はSID履歴インジェクションを使用して権限を昇格させ、アクセス制御をバイパスする可能性があります。Windowsセキュリティ識別子（SID）は、ユーザーまたはグループアカウントを識別する一意の値です。SIDは、セキュリティ記述子とアクセストークンの両方でWindowsセキュリティによって使用されます。(引用: Microsoft SID) アカウントは、SID履歴Active Directory属性に追加のSIDを保持でき(引用: Microsoft SID-History Attribute)、ドメイン間の相互運用可能なアカウント移行を可能にします（例：SID履歴のすべての値がアクセストークンに含まれます）。\n\nドメイン管理者（または同等の）権限があれば、収集されたまたはよく知られているSID値（引用: Microsoft Well Known SIDs Jun 2017）をSID履歴に挿入して、エンタープライズ管理者などの任意のユーザー/グループの偽装を有効にすることができます。この操作により、ローカルリソースへの昇格されたアクセスや、[リモートサービス](https://attack.mitre.org/techniques/T1021)、[SMB/Windows管理共有](https://attack.mitre.org/techniques/T1021/002)、または[Windowsリモート管理](https://attack.mitre.org/techniques/T1021/006)などの横方向の移動テクニックを介した、それ以外ではアクセスできないドメインへのアクセスが可能になる場合があります。"
                },
                {
                    "id": "T1134.002",
                    "name_eng": "Create Process with Token",
                    "name_jp": "トークンを使用したプロセスの作成",
                    "description_eng": "Adversaries may create a new process with an existing token to escalate privileges and bypass access controls. Processes can be created with the token and resulting security context of another user using features such as <code>CreateProcessWithTokenW</code> and <code>runas</code>.(Citation: Microsoft RunAs)\n\nCreating processes with a token not associated with the current user may require the credentials of the target user, specific privileges to impersonate that user, or access to the token to be used. For example, the token could be duplicated via [Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001) or created via [Make and Impersonate Token](https://attack.mitre.org/techniques/T1134/003) before being used to create a process.\n\nWhile this technique is distinct from [Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001), the techniques can be used in conjunction where a token is duplicated and then used to create a new process.",
                    "description_jp": "攻撃者は、既存のトークンを使用して新しいプロセスを作成し、権限を昇格させアクセス制御をバイパスする可能性があります。プロセスは、<code>CreateProcessWithTokenW</code>や<code>runas</code>などの機能を使用して、別のユーザーのトークンと結果のセキュリティコンテキストで作成できます。(引用: Microsoft RunAs)\n\n現在のユーザーに関連付けられていないトークンを使用してプロセスを作成するには、ターゲットユーザーの資格情報、そのユーザーを偽装するための特定の権限、または使用するトークンへのアクセスが必要になる場合があります。例えば、トークンは[トークン偽装/窃取](https://attack.mitre.org/techniques/T1134/001)によって複製されたり、[トークンの作成と偽装](https://attack.mitre.org/techniques/T1134/003)によって作成されたりしてから、プロセスを作成するために使用されることがあります。\n\nこのテクニックは[トークン偽装/窃取](https://attack.mitre.org/techniques/T1134/001)とは異なりますが、トークンが複製されてから新しいプロセスの作成に使用される場合には、これらのテクニックを組み合わせて使用できます。"
                },
                {
                    "id": "T1134.003",
                    "name_eng": "Make and Impersonate Token",
                    "name_jp": "トークンの作成と偽装",
                    "description_eng": "Adversaries may make new tokens and impersonate users to escalate privileges and bypass access controls. For example, if an adversary has a username and password but the user is not logged onto the system the adversary can then create a logon session for the user using the `LogonUser` function.(Citation: LogonUserW function) The function will return a copy of the new session's access token and the adversary can use `SetThreadToken` to assign the token to a thread.\n\nThis behavior is distinct from [Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001) in that this refers to creating a new user token instead of stealing or duplicating an existing one.",
                    "description_jp": "攻撃者は新しいトークンを作成し、ユーザーを偽装して権限を昇格させ、アクセス制御をバイパスする可能性があります。例えば、攻撃者がユーザー名とパスワードを持っているが、ユーザーがシステムにログオンしていない場合、攻撃者は`LogonUser`関数を使用してユーザーのログオンセッションを作成できます。(引用: LogonUserW function) この関数は新しいセッションのアクセストークンのコピーを返し、攻撃者は`SetThreadToken`を使用してトークンをスレッドに割り当てることができます。\n\nこの動作は、既存のトークンを盗んだり複製したりするのではなく、新しいユーザートークンを作成することを指すため、[トークン偽装/窃取](https://attack.mitre.org/techniques/T1134/001)とは異なります。"
                }
            ]
        },
        {
            "id": "T1484",
            "name_eng": "Domain or Tenant Policy Modification",
            "name_jp": "ドメインまたはテナントポリシーの変更",
            "description_eng": "Adversaries may modify the configuration settings of a domain or identity tenant to evade defenses and/or escalate privileges in centrally managed environments. Such services provide a centralized means of managing identity resources such as devices and accounts, and often include configuration settings that may apply between domains or tenants such as trust relationships, identity syncing, or identity federation.\n\nModifications to domain or tenant settings may include altering domain Group Policy Objects (GPOs) in Microsoft Active Directory (AD) or changing trust settings for domains, including federation trusts relationships between domains or tenants.\n\nWith sufficient permissions, adversaries can modify domain or tenant policy settings. Since configuration settings for these services apply to a large number of identity resources, there are a great number of potential attacks malicious outcomes that can stem from this abuse. Examples of such abuse include:  \n\n* modifying GPOs to push a malicious [Scheduled Task](https://attack.mitre.org/techniques/T1053/005) to computers throughout the domain environment(Citation: ADSecurity GPO Persistence 2016)(Citation: Wald0 Guide to GPOs)(Citation: Harmj0y Abusing GPO Permissions)\n* modifying domain trusts to include an adversary-controlled domain, allowing adversaries to  forge access tokens that will subsequently be accepted by victim domain resources(Citation: Microsoft - Customer Guidance on Recent Nation-State Cyber Attacks)\n* changing configuration settings within the AD environment to implement a [Rogue Domain Controller](https://attack.mitre.org/techniques/T1207).\n* adding new, adversary-controlled federated identity providers to identity tenants, allowing adversaries to authenticate as any user managed by the victim tenant (Citation: Okta Cross-Tenant Impersonation 2023)\n\nAdversaries may temporarily modify domain or tenant policy, carry out a malicious action(s), and then revert the change to remove suspicious indicators.",
            "description_jp": "攻撃者は、ドメインまたはIDテナントの構成設定を変更して、一元管理された環境で防御を回避したり権限を昇格させたりする可能性があります。このようなサービスは、デバイスやアカウントなどのIDリソースを管理するための一元的な手段を提供し、多くの場合、信頼関係、ID同期、IDフェデレーションなど、ドメイン間またはテナント間に適用される可能性のある構成設定を含みます。\n\nドメインまたはテナント設定の変更には、Microsoft Active Directory (AD)のドメイングループポリシーオブジェクト(GPO)の変更や、ドメインまたはテナント間のフェデレーショントラスト関係を含むドメインのトラスト設定の変更が含まれる場合があります。\n\n十分な権限があれば、攻撃者はドメインまたはテナントポリシー設定を変更できます。これらのサービスの構成設定は多数のIDリソースに適用されるため、この悪用から生じる可能性のある潜在的な攻撃の悪意のある結果は多数あります。このような悪用の例としては、次のようなものがあります：\n\n* ドメイン環境全体のコンピュータに悪意のある[スケジュールタスク](https://attack.mitre.org/techniques/T1053/005)をプッシュするためのGPOの変更(引用: ADSecurity GPO Persistence 2016)(引用: Wald0 Guide to GPOs)(引用: Harmj0y Abusing GPO Permissions)\n* 攻撃者が制御するドメインを含めるためのドメイン信頼関係の変更。これにより、攻撃者は被害者ドメインリソースによって後で受け入れられるアクセストークンを偽造できるようになります(引用: Microsoft - Customer Guidance on Recent Nation-State Cyber Attacks)\n* [不正なドメインコントローラー](https://attack.mitre.org/techniques/T1207)を実装するためのAD環境内の構成設定の変更。\n* 新しい、攻撃者が制御するフェデレーションIDプロバイダーをIDテナントに追加し、攻撃者が被害者テナントによって管理されている任意のユーザーとして認証できるようにします。(引用: Okta Cross-Tenant Impersonation 2023)\n\n攻撃者は、ドメインまたはテナントポリシーを一時的に変更し、悪意のあるアクションを実行した後、変更を元に戻して疑わしいインジケータを削除する可能性があります。",
            "subtechniques": [
                {
                    "id": "T1484.002",
                    "name_eng": "Trust Modification",
                    "name_jp": "信頼関係の変更",
                    "description_eng": "Adversaries may add new domain trusts, modify the properties of existing domain trusts, or otherwise change the configuration of trust relationships between domains and tenants to evade defenses and/or elevate privileges.Trust details, such as whether or not user identities are federated, allow authentication and authorization properties to apply between domains or tenants for the purpose of accessing shared resources.(Citation: Microsoft - Azure AD Federation) These trust objects may include accounts, credentials, and other authentication material applied to servers, tokens, and domains.\n\nManipulating these trusts may allow an adversary to escalate privileges and/or evade defenses by modifying settings to add objects which they control. For example, in Microsoft Active Directory (AD) environments, this may be used to forge [SAML Tokens](https://attack.mitre.org/techniques/T1606/002) without the need to compromise the signing certificate to forge new credentials. Instead, an adversary can manipulate domain trusts to add their own signing certificate. An adversary may also convert an AD domain to a federated domain using Active Directory Federation Services (AD FS), which may enable malicious trust modifications such as altering the claim issuance rules to log in any valid set of credentials as a specified user.(Citation: AADInternals zure AD Federated Domain) \n\nAn adversary may also add a new federated identity provider to an identity tenant such as Okta or AWS IAM Identity Center, which may enable the adversary to authenticate as any user of the tenant.(Citation: Okta Cross-Tenant Impersonation 2023) This may enable the threat actor to gain broad access into a variety of cloud-based services that leverage the identity tenant. For example, in AWS environments, an adversary that creates a new identity provider for an AWS Organization will be able to federate into all of the AWS Organization member accounts without creating identities for each of the member accounts.(Citation: AWS RE:Inforce Threat Detection 2024)",
                    "description_jp": "攻撃者は、新しいドメイン信頼を追加したり、既存のドメイン信頼のプロパティを変更したり、あるいはドメインとテナント間の信頼関係の構成をその他の方法で変更して、防御を回避したり権限を昇格させたりする可能性があります。ユーザーIDがフェデレーションされているかどうかなどの信頼の詳細は、共有リソースへのアクセスの目的でドメイン間またはテナント間に認証および承認プロパティを適用できるようにします。(引用: Microsoft - Azure AD Federation) これらの信頼オブジェクトには、アカウント、資格情報、およびサーバー、トークン、ドメインに適用されるその他の認証マテリアルが含まれる場合があります。\n\nこれらの信頼関係を操作することにより、攻撃者は、制御するオブジェクトを追加するように設定を変更することで、権限を昇格させたり防御を回避したりできる可能性があります。例えば、Microsoft Active Directory (AD) 環境では、署名証明書を侵害して新しい資格情報を偽造する必要なく、[SAMLトークン](https://attack.mitre.org/techniques/T1606/002)を偽造するためにこれを使用できます。代わりに、攻撃者はドメイン信頼関係を操作して独自の署名証明書を追加できます。攻撃者はまた、Active Directory Federation Services (AD FS) を使用してADドメインをフェデレーションドメインに変換することもでき、これにより、指定されたユーザーとして任意の有効な資格情報セットでログインするためのクレーム発行規則の変更など、悪意のある信頼関係の変更が可能になる場合があります。(引用: AADInternals zure AD Federated Domain)\n\n攻撃者はまた、OktaやAWS IAM Identity CenterなどのIDテナントに新しいフェデレーションIDプロバイダーを追加する可能性があり、これにより攻撃者はテナントの任意のユーザーとして認証できるようになる可能性があります。(引用: Okta Cross-Tenant Impersonation 2023) これにより、脅威アクターはIDテナントを利用するさまざまなクラウドベースのサービスへの広範なアクセスを取得できる可能性があります。例えば、AWS環境では、AWS組織の新しいIDプロバイダーを作成する攻撃者は、各メンバーアカウントのIDを作成することなく、すべてのAWS組織メンバーアカウントにフェデレーションできるようになります。(引用: AWS RE:Inforce Threat Detection 2024)"
                },
                {
                    "id": "T1484.001",
                    "name_eng": "Group Policy Modification",
                    "name_jp": "グループポリシーの変更",
                    "description_eng": "Adversaries may modify Group Policy Objects (GPOs) to subvert the intended discretionary access controls for a domain, usually with the intention of escalating privileges on the domain. Group policy allows for centralized management of user and computer settings in Active Directory (AD). GPOs are containers for group policy settings made up of files stored within a predictable network path `\\<DOMAIN>\\SYSVOL\\<DOMAIN>\\Policies\\`.(Citation: TechNet Group Policy Basics)(Citation: ADSecurity GPO Persistence 2016) \n\nLike other objects in AD, GPOs have access controls associated with them. By default all user accounts in the domain have permission to read GPOs. It is possible to delegate GPO access control permissions, e.g. write access, to specific users or groups in the domain.\n\nMalicious GPO modifications can be used to implement many other malicious behaviors such as [Scheduled Task/Job](https://attack.mitre.org/techniques/T1053), [Disable or Modify Tools](https://attack.mitre.org/techniques/T1562/001), [Ingress Tool Transfer](https://attack.mitre.org/techniques/T1105), [Create Account](https://attack.mitre.org/techniques/T1136), [Service Execution](https://attack.mitre.org/techniques/T1569/002),  and more.(Citation: ADSecurity GPO Persistence 2016)(Citation: Wald0 Guide to GPOs)(Citation: Harmj0y Abusing GPO Permissions)(Citation: Mandiant M Trends 2016)(Citation: Microsoft Hacking Team Breach) Since GPOs can control so many user and machine settings in the AD environment, there are a great number of potential attacks that can stem from this GPO abuse.(Citation: Wald0 Guide to GPOs)\n\nFor example, publicly available scripts such as <code>New-GPOImmediateTask</code> can be leveraged to automate the creation of a malicious [Scheduled Task/Job](https://attack.mitre.org/techniques/T1053) by modifying GPO settings, in this case modifying <code>&lt;GPO_PATH&gt;\\Machine\\Preferences\\ScheduledTasks\\ScheduledTasks.xml</code>.(Citation: Wald0 Guide to GPOs)(Citation: Harmj0y Abusing GPO Permissions) In some cases an adversary might modify specific user rights like SeEnableDelegationPrivilege, set in <code>&lt;GPO_PATH&gt;\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf</code>, to achieve a subtle AD backdoor with complete control of the domain because the user account under the adversary's control would then be able to modify GPOs.(Citation: Harmj0y SeEnableDelegationPrivilege Right)",
                    "description_jp": "攻撃者は、ドメインの意図した任意アクセス制御を破壊するためにグループポリシーオブジェクト（GPO）を変更する可能性があり、通常はドメイン上の権限を昇格させることを目的としています。グループポリシーは、Active Directory（AD）内のユーザーとコンピューターの設定を一元管理できるようにします。GPOは、予測可能なネットワークパス`\\<DOMAIN>\\SYSVOL\\<DOMAIN>\\Policies\\`内に保存されているファイルで構成されるグループポリシー設定のコンテナーです。(引用: TechNet Group Policy Basics)(引用: ADSecurity GPO Persistence 2016)\n\nAD内の他のオブジェクトと同様に、GPOにはアクセス制御が関連付けられています。デフォルトでは、ドメイン内のすべてのユーザーアカウントがGPOの読み取り権限を持っています。GPOアクセス制御権限（書き込みアクセスなど）をドメイン内の特定のユーザーまたはグループに委任することが可能です。\n\n悪意のあるGPOの変更は、[スケジュールされたタスク/ジョブ](https://attack.mitre.org/techniques/T1053)、[ツールの無効化または変更](https://attack.mitre.org/techniques/T1562/001)、[イングレスツール転送](https://attack.mitre.org/techniques/T1105)、[アカウントの作成](https://attack.mitre.org/techniques/T1136)、[サービス実行](https://attack.mitre.org/techniques/T1569/002)など、他の多くの悪意のある動作を実装するために使用できます。(引用: ADSecurity GPO Persistence 2016)(引用: Wald0 Guide to GPOs)(引用: Harmj0y Abusing GPO Permissions)(引用: Mandiant M Trends 2016)(引用: Microsoft Hacking Team Breach) GPOはAD環境内の非常に多くのユーザーとマシンの設定を制御できるため、このGPOの悪用から生じる可能性のある潜在的な攻撃は多数あります。(引用: Wald0 Guide to GPOs)\n\n例えば、`New-GPOImmediateTask`などの一般に入手可能なスクリプトを利用して、GPO設定を変更することにより、悪意のある[スケジュールされたタスク/ジョブ](https://attack.mitre.org/techniques/T1053)の作成を自動化できます。この場合、`&lt;GPO_PATH&gt;\\Machine\\Preferences\\ScheduledTasks\\ScheduledTasks.xml`を変更します。(引用: Wald0 Guide to GPOs)(引用: Harmj0y Abusing GPO Permissions) 場合によっては、攻撃者は、`&lt;GPO_PATH&gt;\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf`で設定されているSeEnableDelegationPrivilegeなどの特定のユーザー権限を変更して、攻撃者の制御下にあるユーザーアカウントがGPOを変更できるようになるため、ドメインを完全に制御できる巧妙なADバックドアを実現する可能性があります。(引用: Harmj0y SeEnableDelegationPrivilege Right)"
                }
            ]
        }
    ]
}